<!-- This file can be parsed by haxe.rtti.XmlParser -->
<haxe>
	<abstract path="Any" params="" file="/opt/hostedtoolcache/haxe/4.3.2/x64/std/Any.hx">
		<from><icast><d/></icast></from>
		<this><d/></this>
		<to><icast field="__promote"><c path="__promote.T"/></icast></to>
		<haxe_doc>`Any` is a type that is compatible with any other in both ways.

	This means that a value of any type can be assigned to `Any`, and
	vice-versa, a value of `Any` type can be assigned to any other type.

	It's a more type-safe alternative to `Dynamic`, because it doesn't
	support field access or operators and it's bound to monomorphs. So,
	to work with the actual value, it needs to be explicitly promoted
	to another type.</haxe_doc>
		<meta><m n=":forward.variance"/></meta>
		<impl><class path="_Any.Any_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.3.2/x64/std/Any.hx" private="1" module="Any" final="1">
	<__promote params="T" get="inline" set="null" line="37" static="1">
		<f a="this">
			<d/>
			<c path="__promote.T"/>
		</f>
		<meta>
			<m n=":noCompletion"/>
			<m n=":to"/>
		</meta>
	</__promote>
	<toString get="inline" set="null" line="40" static="1">
		<f a="this">
			<d/>
			<c path="String"/>
		</f>
		<meta><m n=":noCompletion"/></meta>
	</toString>
	<meta><m n=":keep"/></meta>
</class></impl>
	</abstract>
	<class path="_Any.Any_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.3.2/x64/std/Any.hx" private="1" module="Any" final="1">
		<__promote params="T" get="inline" set="null" line="37" static="1">
			<f a="this">
				<d/>
				<c path="__promote.T"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":to"/>
			</meta>
		</__promote>
		<toString get="inline" set="null" line="40" static="1">
			<f a="this">
				<d/>
				<c path="String"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</toString>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="Array" params="T" file="/opt/hostedtoolcache/haxe/4.3.2/x64/std/js/_std/Array.hx" extern="1">
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The length of `this` Array.</haxe_doc>
		</length>
		<concat public="1" set="method">
			<f a="a">
				<c path="Array"><c path="Array.T"/></c>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Returns a new Array by appending the elements of `a` to the elements of
		`this` Array.

		This operation does not modify `this` Array.

		If `a` is the empty Array `[]`, a copy of `this` Array is returned.

		The length of the returned Array is equal to the sum of `this.length`
		and `a.length`.

		If `a` is `null`, the result is unspecified.</haxe_doc>
		</concat>
		<join public="1" set="method">
			<f a="sep">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a string representation of `this` Array, with `sep` separating
		each element.

		The result of this operation is equal to `Std.string(this[0]) + sep +
		Std.string(this[1]) + sep + ... + sep + Std.string(this[this.length-1])`

		If `this` is the empty Array `[]`, the result is the empty String `""`.
		If `this` has exactly one element, the result is equal to a call to
		`Std.string(this[0])`.

		If `sep` is null, the result is unspecified.</haxe_doc>
		</join>
		<pop public="1" set="method">
			<f a=""><x path="Null"><c path="Array.T"/></x></f>
			<haxe_doc>Removes the last element of `this` Array and returns it.

		This operation modifies `this` Array in place.

		If `this` has at least one element, `this.length` will decrease by 1.

		If `this` is the empty Array `[]`, null is returned and the length
		remains 0.</haxe_doc>
		</pop>
		<push public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Adds the element `x` at the end of `this` Array and returns the new
		length of `this` Array.

		This operation modifies `this` Array in place.

		`this.length` increases by 1.</haxe_doc>
		</push>
		<shift public="1" set="method">
			<f a=""><x path="Null"><c path="Array.T"/></x></f>
			<haxe_doc>Removes the first element of `this` Array and returns it.

		This operation modifies `this` Array in place.

		If `this` has at least one element, `this`.length and the index of each
		remaining element is decreased by 1.

		If `this` is the empty Array `[]`, `null` is returned and the length
		remains 0.</haxe_doc>
		</shift>
		<slice public="1" set="method">
			<f a="pos:?end">
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Creates a shallow copy of the range of `this` Array, starting at and
		including `pos`, up to but not including `end`.

		This operation does not modify `this` Array.

		The elements are not copied and retain their identity.

		If `end` is omitted or exceeds `this.length`, it defaults to the end of
		`this` Array.

		If `pos` or `end` are negative, their offsets are calculated from the
		end of `this` Array by `this.length + pos` and `this.length + end`
		respectively. If this yields a negative value, 0 is used instead.

		If `pos` exceeds `this.length` or if `end` is less than or equals
		`pos`, the result is `[]`.</haxe_doc>
		</slice>
		<splice public="1" set="method">
			<f a="pos:len">
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc><![CDATA[Removes `len` elements from `this` Array, starting at and including
		`pos`, an returns them.

		This operation modifies `this` Array in place.

		If `len` is < 0 or `pos` exceeds `this`.length, an empty Array [] is
		returned and `this` Array is unchanged.

		If `pos` is negative, its value is calculated from the end	of `this`
		Array by `this.length + pos`. If this yields a negative value, 0 is
		used instead.

		If the sum of the resulting values for `len` and `pos` exceed
		`this.length`, this operation will affect the elements from `pos` to the
		end of `this` Array.

		The length of the returned Array is equal to the new length of `this`
		Array subtracted from the original length of `this` Array. In other
		words, each element of the original `this` Array either remains in
		`this` Array or becomes an element of the returned Array.]]></haxe_doc>
		</splice>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string representation of `this` Array.

		The result will include the individual elements' String representations
		separated by comma. The enclosing [ ] may be missing on some platforms,
		use `Std.string()` to get a String representation that is consistent
		across platforms.</haxe_doc>
		</toString>
		<indexOf public="1" set="method">
			<f a="x:?fromIndex">
				<c path="Array.T"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns position of the first occurrence of `x` in `this` Array, searching front to back.

		If `x` is found by checking standard equality, the function returns its index.

		If `x` is not found, the function returns -1.

		If `fromIndex` is specified, it will be used as the starting index to search from,
		otherwise search starts with zero index. If it is negative, it will be taken as the
		offset from the end of `this` Array to compute the starting index. If given or computed
		starting index is less than 0, the whole array will be searched, if it is greater than
		or equal to the length of `this` Array, the function returns -1.</haxe_doc>
		</indexOf>
		<iterator public="1" get="inline" set="null" line="88">
			<f a=""><c path="haxe.iterators.ArrayIterator"><c path="Array.T"/></c></f>
			<meta><m n=":runtime"/></meta>
			<haxe_doc>Returns an iterator of the Array values.</haxe_doc>
		</iterator>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Array.</haxe_doc>
		</new>
		<haxe_doc>An Array is a storage for values. You can access it using indexes or
	with its API.

	@see https://haxe.org/manual/std-Array.html
	@see https://haxe.org/manual/lf-array-comprehension.html</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<abstract path="Class" params="T" file="/opt/hostedtoolcache/haxe/4.3.2/x64/std/Class.hx">
		<this><x path="Class"><c path="Class.T"/></x></this>
		<haxe_doc>An abstract type that represents a Class.

	See `Type` for the Haxe Reflection API.

	@see https://haxe.org/manual/types-class-instance.html</haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<class path="Date" params="" file="/opt/hostedtoolcache/haxe/4.3.2/x64/std/js/_std/Date.hx" extern="1">
		<now public="1" get="inline" set="null" line="46" static="1">
			<f a=""><c path="Date"/></f>
			<haxe_doc>Returns a Date representing the current local time.</haxe_doc>
		</now>
		<fromTime public="1" get="inline" set="null" line="50" static="1">
			<f a="t">
				<x path="Float"/>
				<c path="Date"/>
			</f>
			<haxe_doc>Creates a Date from the timestamp (in milliseconds) `t`.</haxe_doc>
		</fromTime>
		<fromString public="1" get="inline" set="null" line="54" static="1">
			<f a="s">
				<c path="String"/>
				<c path="Date"/>
			</f>
			<haxe_doc>Creates a Date from the formatted string `s`. The following formats are
		accepted by the function:

		- `"YYYY-MM-DD hh:mm:ss"`
		- `"YYYY-MM-DD"`
		- `"hh:mm:ss"`

		The first two formats expressed a date in local time. The third is a time
		relative to the UTC epoch.</haxe_doc>
		</fromString>
		<getTime public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns the timestamp (in milliseconds) of `this` date.
		On cpp and neko, this function only has a second resolution, so the
		result will always be a multiple of `1000.0`, e.g. `1454698271000.0`.
		To obtain the current timestamp with better precision on cpp and neko,
		see the `Sys.time` API.

		For measuring time differences with millisecond accuracy on
		all platforms, see `haxe.Timer.stamp`.</haxe_doc>
		</getTime>
		<getHours public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the hours of `this` Date (0-23 range) in the local timezone.</haxe_doc>
		</getHours>
		<getMinutes public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the minutes of `this` Date (0-59 range) in the local timezone.</haxe_doc>
		</getMinutes>
		<getSeconds public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the seconds of `this` Date (0-59 range) in the local timezone.</haxe_doc>
		</getSeconds>
		<getFullYear public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the full year of `this` Date (4 digits) in the local timezone.</haxe_doc>
		</getFullYear>
		<getMonth public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the month of `this` Date (0-11 range) in the local timezone.
		Note that the month number is zero-based.</haxe_doc>
		</getMonth>
		<getDate public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the day of `this` Date (1-31 range) in the local timezone.</haxe_doc>
		</getDate>
		<getDay public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the day of the week of `this` Date (0-6 range, where `0` is Sunday)
		in the local timezone.</haxe_doc>
		</getDay>
		<getUTCHours public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the hours of `this` Date (0-23 range) in UTC.</haxe_doc>
		</getUTCHours>
		<getUTCMinutes public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the minutes of `this` Date (0-59 range) in UTC.</haxe_doc>
		</getUTCMinutes>
		<getUTCSeconds public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the seconds of `this` Date (0-59 range) in UTC.</haxe_doc>
		</getUTCSeconds>
		<getUTCFullYear public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the full year of `this` Date (4 digits) in UTC.</haxe_doc>
		</getUTCFullYear>
		<getUTCMonth public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the month of `this` Date (0-11 range) in UTC.
		Note that the month number is zero-based.</haxe_doc>
		</getUTCMonth>
		<getUTCDate public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the day of `this` Date (1-31 range) in UTC.</haxe_doc>
		</getUTCDate>
		<getUTCDay public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the day of the week of `this` Date (0-6 range, where `0` is Sunday)
		in UTC.</haxe_doc>
		</getUTCDay>
		<getTimezoneOffset public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the time zone difference of `this` Date in the current locale
		to UTC, in minutes.

		Assuming the function is executed on a machine in a UTC+2 timezone,
		`Date.now().getTimezoneOffset()` will return `-120`.</haxe_doc>
		</getTimezoneOffset>
		<toString public="1" get="inline" set="null" line="42">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string representation of `this` Date in the local timezone
		using the standard format `YYYY-MM-DD HH:MM:SS`. See `DateTools.format` for
		other formatting rules.</haxe_doc>
		</toString>
		<new public="1" set="method">
			<f a="year:month:day:hour:min:sec">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new date object from the given arguments.

		The behaviour of a Date instance is only consistent across platforms if
		the the arguments describe a valid date.

		- month: 0 to 11 (note that this is zero-based)
		- day: 1 to 31
		- hour: 0 to 23
		- min: 0 to 59
		- sec: 0 to 59</haxe_doc>
		</new>
		<haxe_doc>The Date class provides a basic structure for date and time related
	information. Date instances can be created by

	- `new Date()` for a specific date,
	- `Date.now()` to obtain information about the current time,
	- `Date.fromTime()` with a given timestamp or
	- `Date.fromString()` by parsing from a String.

	There are some extra functions available in the `DateTools` class.

	In the context of Haxe dates, a timestamp is defined as the number of
	milliseconds elapsed since 1st January 1970 UTC.

	## Supported range

	Due to platform limitations, only dates in the range 1970 through 2038 are
	supported consistently. Some targets may support dates outside this range,
	depending on the OS at runtime. The `Date.fromTime` method will not work with
	timestamps outside the range on any target.</haxe_doc>
		<meta><m n=":coreApi"/></meta>
	</class>
	<class path="js.lib.RegExp" params="" file="/opt/hostedtoolcache/haxe/4.3.2/x64/std/js/lib/RegExp.hx" extern="1">
		<global public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>Indicates whether or not the "g" flag is used with the regular expression.</haxe_doc>
		</global>
		<ignoreCase public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>Indicates whether or not the "i" flag is used with the regular expression.</haxe_doc>
		</ignoreCase>
		<multiline public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>Indicates whether or not the "m" flag is used with the regular expression.</haxe_doc>
		</multiline>
		<source public="1" set="null">
			<c path="String"/>
			<haxe_doc>The source text of the regexp object, it doesn't contain the two forward slashes on both sides and any flags.</haxe_doc>
		</source>
		<lastIndex public="1">
			<x path="Int"/>
			<haxe_doc>The index at which to start the next match.</haxe_doc>
		</lastIndex>
		<exec public="1" set="method">
			<f a="str">
				<c path="String"/>
				<x path="Null"><c path="js.lib.RegExpMatch"/></x>
			</f>
			<haxe_doc>Execute a search for a match in a specified string.
		Returns a result array, or null.</haxe_doc>
		</exec>
		<test public="1" set="method">
			<f a="str">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Execute a search for a match between a regular expression and a specified string.
		Returns true or false.</haxe_doc>
		</test>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Return a string representing the regular expression.</haxe_doc>
		</toString>
		<new public="1" set="method">
			<f a="pattern:?flags">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Create a regular expression object for matching text with a pattern.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[Native JavaScript regular expressions.

	For cross-platform regular expressions, use Haxe `EReg` class or
	[regexp literals](https://haxe.org/manual/std-regex.html).

	@see <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp>]]></haxe_doc>
		<meta><m n=":native"><e>"RegExp"</e></m></meta>
	</class>
	<class path="_EReg.HaxeRegExp" params="" file="/opt/hostedtoolcache/haxe/4.3.2/x64/std/js/_std/EReg.hx" private="1" module="EReg" extern="1">
		<extends path="js.lib.RegExp"/>
		<m public="1"><c path="js.lib.RegExpMatch"/></m>
		<s public="1"><c path="String"/></s>
		<meta><m n=":native"><e>"RegExp"</e></m></meta>
	</class>
	<abstract path="Enum" params="T" file="/opt/hostedtoolcache/haxe/4.3.2/x64/std/Enum.hx">
		<this><x path="Enum"><c path="Enum.T"/></x></this>
		<haxe_doc>An abstract type that represents an Enum type.

	The corresponding enum instance type is `EnumValue`.

	See `Type` for the Haxe Reflection API.

	@see https://haxe.org/manual/types-enum-instance.html</haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="EnumValue" params="" file="/opt/hostedtoolcache/haxe/4.3.2/x64/std/EnumValue.hx">
		<this><x path="EnumValue"/></this>
		<haxe_doc>An abstract type that represents any enum value.
	See `Type` for the Haxe Reflection API.

	@see https://haxe.org/manual/types-enum-instance.html</haxe_doc>
		<meta><m n=":coreType"/></meta>
		<impl><class path="_EnumValue.EnumValue_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.3.2/x64/std/EnumValue.hx" private="1" module="EnumValue" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="js.Syntax" params="" file="/opt/hostedtoolcache/haxe/4.3.2/x64/std/js/Syntax.hx" extern="1">
		<code public="1" set="method" static="1">
			<f a="code:args">
				<c path="String"/>
				<t path="haxe.extern.Rest"><d/></t>
				<d/>
			</f>
			<haxe_doc>Inject `code` directly into generated source.

		`code` must be a string constant.

		Additional `args` are supported to provide code interpolation, for example:
		```haxe
		Syntax.code("console.log({0}, {1})", "hi", 42);
		```
		will generate
		```haxe
		console.log("hi", 42);
		```

		Emits a compilation error if the count of `args` does not match the count of placeholders in `code`.</haxe_doc>
		</code>
		<plainCode public="1" set="method" static="1">
			<f a="code">
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>Inject `code` directly into generated source.
		The same as `js.Syntax.code` except this one does not provide code interpolation.</haxe_doc>
		</plainCode>
		<construct public="1" params="T" set="method" static="1">
			<f a="cl:args">
				<x path="Class"><c path="construct.T"/></x>
				<t path="haxe.extern.Rest"><d/></t>
				<c path="construct.T"/>
			</f>
			<haxe_doc>Generate `new cl(...args)` expression.</haxe_doc>
			<overloads><construct public="1" set="method">
	<f a="cl:args">
		<c path="String"/>
		<t path="haxe.extern.Rest"><d/></t>
		<d/>
	</f>
	<haxe_doc>Generate `new cl(...args)` expression.</haxe_doc>
</construct></overloads>
		</construct>
		<instanceof public="1" set="method" static="1">
			<f a="v:cl">
				<d/>
				<x path="Class"><d/></x>
				<x path="Bool"/>
			</f>
			<haxe_doc>Generate `v instanceof cl` expression.</haxe_doc>
		</instanceof>
		<typeof public="1" set="method" static="1">
			<f a="o">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>Generate `typeof o` expression.</haxe_doc>
		</typeof>
		<strictEq public="1" set="method" static="1">
			<f a="a:b">
				<d/>
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Genearte `a === b` expression.</haxe_doc>
		</strictEq>
		<strictNeq public="1" set="method" static="1">
			<f a="a:b">
				<d/>
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Genearte `a !== b` expression.</haxe_doc>
		</strictNeq>
		<delete public="1" set="method" static="1">
			<f a="o:f">
				<d/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Generate `delete o[f]` expression.</haxe_doc>
			<overloads><delete public="1" set="method">
	<f a="o:f">
		<d/>
		<x path="Int"/>
		<x path="Bool"/>
	</f>
	<haxe_doc>Generate `delete o[f]` expression.</haxe_doc>
</delete></overloads>
		</delete>
		<field public="1" set="method" static="1">
			<f a="o:f">
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>Generate `o.f` expression, if `f` is a constant string,
		or `o[f]` if it's any other expression.</haxe_doc>
		</field>
		<haxe_doc>Generate JavaScript syntax not directly supported by Haxe.
	Use only at low-level when specific target-specific code-generation is required.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":noClosure"/>
		</meta>
	</class>
	<class path="js.lib.Date" params="" file="/opt/hostedtoolcache/haxe/4.3.2/x64/std/js/lib/Date.hx" extern="1">
		<fromHaxeDate public="1" get="inline" set="null" line="40" static="1">
			<f a="date">
				<t path="_Date.HaxeDate"/>
				<c path="js.lib.Date"/>
			</f>
			<haxe_doc>Cast Haxe's Date to js.lib.Date.</haxe_doc>
		</fromHaxeDate>
		<toHaxeDate public="1" get="inline" set="null" line="47" static="1">
			<f a="date">
				<c path="js.lib.Date"/>
				<t path="_Date.HaxeDate"/>
			</f>
			<haxe_doc>Cast js.lib.Date to Haxe's Date.</haxe_doc>
		</toHaxeDate>
		<now public="1" set="method" static="1">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns the numeric value corresponding to the current time - the number of milliseconds elapsed since January 1, 1970 00:00:00 UTC, with leap seconds ignored</haxe_doc>
		</now>
		<parse public="1" set="method" static="1">
			<f a="str">
				<c path="String"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Parses a string representation of a date and returns the number of milliseconds since 1 January, 1970, 00:00:00, UTC, with leap seconds ignored.</haxe_doc>
		</parse>
		<UTC public="1" set="method" static="1">
			<f a="year:month:?day:?hours:?minutes:?seconds:?milliseconds">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the number of milliseconds since January 1, 1970, 00:00:00 UTC, with leap seconds ignored.</haxe_doc>
		</UTC>
		<getDate public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the day of the month (1-31) for the specified date according to local time.</haxe_doc>
		</getDate>
		<getDay public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the day of the week (0-6) for the specified date according to local time.</haxe_doc>
		</getDay>
		<getFullYear public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the year (4 digits for 4-digit years) of the specified date according to local time.</haxe_doc>
		</getFullYear>
		<getHours public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the hour (0-23) in the specified date according to local time.</haxe_doc>
		</getHours>
		<getMilliseconds public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the milliseconds (0-999) in the specified date according to local time.</haxe_doc>
		</getMilliseconds>
		<getMinutes public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the minutes (0-59) in the specified date according to local time.</haxe_doc>
		</getMinutes>
		<getMonth public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the month (0-11) in the specified date according to local time.</haxe_doc>
		</getMonth>
		<getSeconds public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the seconds (0-59) in the specified date according to local time.</haxe_doc>
		</getSeconds>
		<getTime public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns the numeric value of the specified date as the number of milliseconds since January 1, 1970, 00:00:00 UTC (negative for prior times).</haxe_doc>
		</getTime>
		<getTimezoneOffset public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the time-zone offset in minutes for the current locale.</haxe_doc>
		</getTimezoneOffset>
		<getUTCDate public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the day (date) of the month (1-31) in the specified date according to universal time.</haxe_doc>
		</getUTCDate>
		<getUTCDay public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the day of the week (0-6) in the specified date according to universal time.</haxe_doc>
		</getUTCDay>
		<getUTCFullYear public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the year (4 digits for 4-digit years) in the specified date according to universal time.</haxe_doc>
		</getUTCFullYear>
		<getUTCHours public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the hours (0-23) in the specified date according to universal time.</haxe_doc>
		</getUTCHours>
		<getUTCMilliseconds public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the milliseconds (0-999) in the specified date according to universal time.</haxe_doc>
		</getUTCMilliseconds>
		<getUTCMinutes public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the minutes (0-59) in the specified date according to universal time.</haxe_doc>
		</getUTCMinutes>
		<getUTCMonth public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the month (0-11) in the specified date according to universal time.</haxe_doc>
		</getUTCMonth>
		<getUTCSeconds public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the seconds (0-59) in the specified date according to universal time.</haxe_doc>
		</getUTCSeconds>
		<setDate public="1" set="method">
			<f a="value">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the day of the month for a specified date according to local time.</haxe_doc>
		</setDate>
		<setFullYear public="1" set="method">
			<f a="value">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the full year (e.g. 4 digits for 4-digit years) for a specified date according to local time.</haxe_doc>
		</setFullYear>
		<setHours public="1" set="method">
			<f a="value">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the hours for a specified date according to local time.</haxe_doc>
		</setHours>
		<setMilliseconds public="1" set="method">
			<f a="value">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the milliseconds for a specified date according to local time.</haxe_doc>
		</setMilliseconds>
		<setMinutes public="1" set="method">
			<f a="value">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the minutes for a specified date according to local time.</haxe_doc>
		</setMinutes>
		<setMonth public="1" set="method">
			<f a="value">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the month for a specified date according to local time.</haxe_doc>
		</setMonth>
		<setSeconds public="1" set="method">
			<f a="value">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the seconds for a specified date according to local time.</haxe_doc>
		</setSeconds>
		<setTime public="1" set="method">
			<f a="value">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the Date object to the time represented by a number of milliseconds since January 1, 1970, 00:00:00 UTC, allowing for negative numbers for times prior.</haxe_doc>
		</setTime>
		<setUTCDate public="1" set="method">
			<f a="value">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the day of the month for a specified date according to universal time.</haxe_doc>
		</setUTCDate>
		<setUTCFullYear public="1" set="method">
			<f a="value">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the full year (e.g. 4 digits for 4-digit years) for a specified date according to universal time.</haxe_doc>
		</setUTCFullYear>
		<setUTCHours public="1" set="method">
			<f a="value">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the hour for a specified date according to universal time.</haxe_doc>
		</setUTCHours>
		<setUTCMilliseconds public="1" set="method">
			<f a="value">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the milliseconds for a specified date according to universal time.</haxe_doc>
		</setUTCMilliseconds>
		<setUTCMinutes public="1" set="method">
			<f a="value">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the minutes for a specified date according to universal time.</haxe_doc>
		</setUTCMinutes>
		<setUTCMonth public="1" set="method">
			<f a="value">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the month for a specified date according to universal time.</haxe_doc>
		</setUTCMonth>
		<setUTCSeconds public="1" set="method">
			<f a="value">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the seconds for a specified date according to universal time.</haxe_doc>
		</setUTCSeconds>
		<toDateString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the "date" portion of the Date as a human-readable string.</haxe_doc>
		</toDateString>
		<toISOString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Converts a date to a string following the ISO 8601 Extended Format.</haxe_doc>
		</toISOString>
		<toJSON public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string representing the Date using toISOString(). Intended for use by JSON.stringify().</haxe_doc>
		</toJSON>
		<toLocaleDateString public="1" set="method">
			<f a="?locales:?options">
				<c path="String"/>
				<d><d/></d>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a string with a locality sensitive representation of the date portion of this date based on system settings.</haxe_doc>
			<overloads><toLocaleDateString public="1" set="method">
	<f a="?locales:?options">
		<c path="Array"><c path="String"/></c>
		<d><d/></d>
		<c path="String"/>
	</f>
	<haxe_doc>Returns a string with a locality sensitive representation of the date portion of this date based on system settings.</haxe_doc>
</toLocaleDateString></overloads>
		</toLocaleDateString>
		<toLocaleFormat public="1" set="method">
			<f a="format">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Converts a date to a string, using a format string.</haxe_doc>
		</toLocaleFormat>
		<toLocaleString public="1" set="method">
			<f a="?locales:?options">
				<c path="String"/>
				<d><d/></d>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a string with a locality sensitive representation of this date. Overrides the Object.prototype.toLocaleString() method.</haxe_doc>
			<overloads><toLocaleString public="1" set="method">
	<f a="?locales:?options">
		<c path="Array"><c path="String"/></c>
		<d><d/></d>
		<c path="String"/>
	</f>
	<haxe_doc>Returns a string with a locality sensitive representation of this date. Overrides the Object.prototype.toLocaleString() method.</haxe_doc>
</toLocaleString></overloads>
		</toLocaleString>
		<toLocaleTimeString public="1" set="method">
			<f a="?locales:?options">
				<c path="String"/>
				<d><d/></d>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a string with a locality sensitive representation of the time portion of this date based on system settings.</haxe_doc>
			<overloads><toLocaleTimeString public="1" set="method">
	<f a="?locales:?options">
		<c path="Array"><c path="String"/></c>
		<d><d/></d>
		<c path="String"/>
	</f>
	<haxe_doc>Returns a string with a locality sensitive representation of the time portion of this date based on system settings.</haxe_doc>
</toLocaleTimeString></overloads>
		</toLocaleTimeString>
		<toSource public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string representing the source for an equivalent Date object; you can use this value to create a new object. Overrides the Object.prototype.toSource() method.</haxe_doc>
		</toSource>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string representing the specified Date object. Overrides the Object.prototype.toString() method.</haxe_doc>
		</toString>
		<toTimeString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the "time" portion of the Date as a human-readable string.</haxe_doc>
		</toTimeString>
		<toUTCString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Converts a date to a string using the UTC timezone.</haxe_doc>
		</toUTCString>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<overloads>
				<new public="1" set="method"><f a="value">
	<x path="Float"/>
	<x path="Void"/>
</f></new>
				<new public="1" set="method"><f a="dateString">
	<c path="String"/>
	<x path="Void"/>
</f></new>
				<new public="1" set="method"><f a="year:month:?day:?hours:?minutes:?seconds:?milliseconds">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
			</overloads>
		</new>
		<haxe_doc>Creates a JavaScript Date instance that represents a single moment in time. Date objects are based on a time value that is the number of milliseconds since 1 January 1970 UTC.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"Date"</e></m>
		</meta>
	</class>
	<class path="Math" params="" file="/opt/hostedtoolcache/haxe/4.3.2/x64/std/js/_std/Math.hx" extern="1">
		<PI public="1" set="null" static="1"><x path="Float"/></PI>
		<abs public="1" set="method" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></abs>
		<atan2 public="1" set="method" static="1"><f a="y:x">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></atan2>
		<cos public="1" set="method" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></cos>
		<floor public="1" set="method" static="1"><f a="v">
	<x path="Float"/>
	<x path="Int"/>
</f></floor>
		<max public="1" set="method" static="1"><f a="a:b">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></max>
		<min public="1" set="method" static="1"><f a="a:b">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></min>
		<sin public="1" set="method" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></sin>
		<sqrt public="1" set="method" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></sqrt>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":keepInit"/>
		</meta>
	</class>
	<class path="Reflect" params="" file="/opt/hostedtoolcache/haxe/4.3.2/x64/std/js/_std/Reflect.hx">
		<field public="1" set="method" line="29" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>Returns the value of the field named `field` on object `o`.

		If `o` is not an object or has no field named `field`, the result is
		null.

		If the field is defined as a property, its accessors are ignored. Refer
		to `Reflect.getProperty` for a function supporting property accessors.

		If `field` is null, the result is unspecified.</haxe_doc>
		</field>
		<fields public="1" set="method" line="60" static="1">
			<f a="o">
				<d/>
				<c path="Array"><c path="String"/></c>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the fields of structure `o`.

		This method is only guaranteed to work on anonymous structures. Refer to
		`Type.getInstanceFields` for a function supporting class instances.

		If `o` is null, the result is unspecified.</haxe_doc>
		</fields>
		<copy public="1" params="T" set="method" line="106" static="1">
			<f a="o">
				<x path="Null"><c path="copy.T"/></x>
				<x path="Null"><c path="copy.T"/></x>
			</f>
			<haxe_doc>Copies the fields of structure `o`.

		This is only guaranteed to work on anonymous structures.

		If `o` is null, the result is `null`.</haxe_doc>
		</copy>
		<haxe_doc>The Reflect API is a way to manipulate values dynamically through an
	abstract interface in an untyped manner. Use with care.

	@see https://haxe.org/manual/std-reflection.html</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="String" params="" file="/opt/hostedtoolcache/haxe/4.3.2/x64/std/js/_std/String.hx" extern="1">
		<fromCharCode public="1" get="inline" set="null" line="43" static="1">
			<f a="code">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the String corresponding to the character code `code`.

		If `code` is negative or has another invalid value, the result is
		unspecified.</haxe_doc>
		</fromCharCode>
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The number of characters in `this` String.</haxe_doc>
		</length>
		<toUpperCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a String where all characters of `this` String are upper case.</haxe_doc>
		</toUpperCase>
		<toLowerCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a String where all characters of `this` String are lower case.</haxe_doc>
		</toLowerCase>
		<charAt public="1" set="method">
			<f a="index">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the character at position `index` of `this` String.

		If `index` is negative or exceeds `this.length`, the empty String `""`
		is returned.</haxe_doc>
		</charAt>
		<indexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the position of the leftmost occurrence of `str` within `this`
		String.

		If `startIndex` is given, the search is performed within the substring
		of `this` String starting from `startIndex`.

		If `startIndex` exceeds `this.length`, -1 is returned.

		If `startIndex` is negative, the result is unspecifed.

		Otherwise the search is performed within `this` String. In either case,
		the returned position is relative to the beginning of `this` String.

		If `str` cannot be found, -1 is returned.</haxe_doc>
		</indexOf>
		<lastIndexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the position of the rightmost occurrence of `str` within `this`
		String.

		If `startIndex` is given, the search is performed within the substring
		of `this` String from 0 to `startIndex + str.length`. Otherwise the search
		is performed within `this` String. In either case, the returned position
		is relative to the beginning of `this` String.

		If `startIndex` is negative, the result is unspecifed.

		If `str` cannot be found, -1 is returned.</haxe_doc>
		</lastIndexOf>
		<split public="1" set="method">
			<f a="delimiter">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Splits `this` String at each occurrence of `delimiter`.

		If `this` String is the empty String `""`, the result is not consistent
		across targets and may either be `[]` (on Js, Cpp) or `[""]`.

		If `delimiter` is the empty String `""`, `this` String is split into an
		Array of `this.length` elements, where the elements correspond to the
		characters of `this` String.

		If `delimiter` is not found within `this` String, the result is an Array
		with one element, which equals `this` String.

		If `delimiter` is null, the result is unspecified.

		Otherwise, `this` String is split into parts at each occurrence of
		`delimiter`. If `this` String starts (or ends) with `delimiter`, the
		result `Array` contains a leading (or trailing) empty String `""` element.
		Two subsequent delimiters also result in an empty String `""` element.</haxe_doc>
		</split>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the String itself.</haxe_doc>
		</toString>
		<substring public="1" set="method">
			<f a="startIndex:?endIndex">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the part of `this` String from `startIndex` to but not including `endIndex`.

		If `startIndex` or `endIndex` are negative, 0 is used instead.

		If `startIndex` exceeds `endIndex`, they are swapped.

		If the (possibly swapped) `endIndex` is omitted or exceeds
		`this.length`, `this.length` is used instead.

		If the (possibly swapped) `startIndex` exceeds `this.length`, the empty
		String `""` is returned.</haxe_doc>
		</substring>
		<charCodeAt public="1" get="inline" set="null" line="35">
			<f a="index">
				<x path="Int"/>
				<x path="Null"><x path="Int"/></x>
			</f>
			<haxe_doc>Returns the character code at position `index` of `this` String.

		If `index` is negative or exceeds `this.length`, `null` is returned.

		To obtain the character code of a single character, `"x".code` can be
		used instead to inline the character code at compile time. Note that
		this only works on String literals of length 1.</haxe_doc>
		</charCodeAt>
		<substr public="1" get="inline" set="null" line="39">
			<f a="pos:?len">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns `len` characters of `this` String, starting at position `pos`.

		If `len` is omitted, all characters from position `pos` to the end of
		`this` String are included.

		If `pos` is negative, its value is calculated from the end of `this`
		String by `this.length + pos`. If this yields a negative value, 0 is
		used instead.

		If the calculated position + `len` exceeds `this.length`, the characters
		from that position to the end of `this` String are returned.

		If `len` is negative, the result is unspecified.</haxe_doc>
		</substr>
		<new public="1" set="method">
			<f a="string">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a copy from a given String.</haxe_doc>
		</new>
		<haxe_doc>The basic String class.

	A Haxe String is immutable, it is not possible to modify individual
	characters. No method of this class changes the state of `this` String.

	Strings can be constructed using the String literal syntax `"string value"`.

	String can be concatenated by using the `+` operator. If an operand is not a
	String, it is passed through `Std.string()` first.

	@see https://haxe.org/manual/std-String.html</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="Std" params="" file="/opt/hostedtoolcache/haxe/4.3.2/x64/std/js/_std/Std.hx">
		<string public="1" set="method" line="47" static="1">
			<f a="s">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>Converts any value to a String.

		If `s` is of `String`, `Int`, `Float` or `Bool`, its value is returned.

		If `s` is an instance of a class and that class or one of its parent classes has
		a `toString` method, that method is called. If no such method is present, the result
		is unspecified.

		If `s` is an enum constructor without argument, the constructor's name is returned. If
		arguments exists, the constructor's name followed by the String representations of
		the arguments is returned.

		If `s` is a structure, the field names along with their values are returned. The field order
		and the operator separating field names and values are unspecified.

		If s is null, "null" is returned.</haxe_doc>
		</string>
		<haxe_doc>The Std class provides standard methods for manipulating basic types.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":keepInit"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<abstract path="Void" params="" file="/opt/hostedtoolcache/haxe/4.3.2/x64/std/StdTypes.hx" module="StdTypes">
		<this><x path="Void"/></this>
		<haxe_doc>The standard `Void` type. Only `null` values can be of the type `Void`.

	@see https://haxe.org/manual/types-void.html</haxe_doc>
		<meta><m n=":coreType"/></meta>
	</abstract>
	<abstract path="Float" params="" file="/opt/hostedtoolcache/haxe/4.3.2/x64/std/StdTypes.hx" module="StdTypes">
		<this><x path="Float"/></this>
		<haxe_doc><![CDATA[The standard `Float` type, this is a double-precision IEEE 64bit float.

	On static targets, `null` cannot be assigned to Float. If this is necessary,
	`Null<Float>` can be used instead.

	`Std.int` converts a `Float` to an `Int`, rounded towards 0.
	`Std.parseFloat` converts a `String` to a `Float`.

	@see https://haxe.org/manual/types-basic-types.html
	@see https://haxe.org/manual/types-nullability.html]]></haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Int" params="" file="/opt/hostedtoolcache/haxe/4.3.2/x64/std/StdTypes.hx" module="StdTypes">
		<this><x path="Int"/></this>
		<to><icast><x path="Float"/></icast></to>
		<haxe_doc><![CDATA[The standard `Int` type. Its precision depends on the platform.

	On static targets, `null` cannot be assigned to `Int`. If this is necessary,
	`Null<Int>` can be used instead.

	`Std.int` converts a `Float` to an `Int`, rounded towards 0.
	`Std.parseInt` converts a `String` to an `Int`.

	@see https://haxe.org/manual/types-basic-types.html
	@see https://haxe.org/manual/std-math-integer-math.html
	@see https://haxe.org/manual/types-nullability.html]]></haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Null" params="T" file="/opt/hostedtoolcache/haxe/4.3.2/x64/std/StdTypes.hx" module="StdTypes">
		<from><icast><c path="Null.T"/></icast></from>
		<this><x path="Null"><c path="Null.T"/></x></this>
		<to><icast><c path="Null.T"/></icast></to>
		<haxe_doc><![CDATA[`Null<T>` is a wrapper that can be used to make the basic types `Int`,
	`Float` and `Bool` nullable on static targets.

	If null safety is enabled, only types wrapped in `Null<T>` are nullable.

	Otherwise, it has no effect on non-basic-types, but it can be useful as a way to document
	that `null` is an acceptable value for a method argument, return value or variable.

	@see https://haxe.org/manual/types-nullability.html]]></haxe_doc>
		<meta>
			<m n=":forward"/>
			<m n=":coreType"/>
		</meta>
	</abstract>
	<abstract path="Bool" params="" file="/opt/hostedtoolcache/haxe/4.3.2/x64/std/StdTypes.hx" module="StdTypes">
		<this><x path="Bool"/></this>
		<haxe_doc><![CDATA[The standard Boolean type, which can either be `true` or `false`.

	On static targets, `null` cannot be assigned to `Bool`. If this is necessary,
	`Null<Bool>` can be used instead.

	@see https://haxe.org/manual/types-bool.html
	@see https://haxe.org/manual/types-nullability.html]]></haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Dynamic" params="T" file="/opt/hostedtoolcache/haxe/4.3.2/x64/std/StdTypes.hx" module="StdTypes">
		<this><x path="Dynamic"><c path="Dynamic.T"/></x></this>
		<haxe_doc>`Dynamic` is a special type which is compatible with all other types.

	Use of `Dynamic` should be minimized as it prevents several compiler
	checks and optimizations. See `Any` type for a safer alternative for
	representing values of any type.

	@see https://haxe.org/manual/types-dynamic.html</haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<typedef path="Iterator" params="T" file="/opt/hostedtoolcache/haxe/4.3.2/x64/std/StdTypes.hx" module="StdTypes">
		<a>
			<next set="method">
				<f a=""><c path="Iterator.T"/></f>
				<haxe_doc>Returns the current item of the `Iterator` and advances to the next one.

		This method is not required to check `hasNext()` first. A call to this
		method while `hasNext()` is `false` yields unspecified behavior.

		On the other hand, iterators should not require a call to `hasNext()`
		before the first call to `next()` if an element is available.</haxe_doc>
			</next>
			<hasNext set="method">
				<f a=""><x path="Bool"/></f>
				<haxe_doc>Returns `false` if the iteration is complete, `true` otherwise.

		Usually iteration is considered to be complete if all elements of the
		underlying data structure were handled through calls to `next()`. However,
		in custom iterators any logic may be used to determine the completion
		state.</haxe_doc>
			</hasNext>
		</a>
		<haxe_doc>An `Iterator` is a structure that permits iteration over elements of type `T`.

	Any class with matching `hasNext()` and `next()` fields is considered an `Iterator`
	and can then be used e.g. in `for`-loops. This makes it easy to implement
	custom iterators.

	@see https://haxe.org/manual/lf-iterators.html</haxe_doc>
	</typedef>
	<typedef path="Iterable" params="T" file="/opt/hostedtoolcache/haxe/4.3.2/x64/std/StdTypes.hx" module="StdTypes">
		<a><iterator set="method"><f a=""><t path="Iterator"><c path="Iterable.T"/></t></f></iterator></a>
		<haxe_doc>An `Iterable` is a data structure which has an `iterator()` method.
	See `Lambda` for generic functions on iterable structures.

	@see https://haxe.org/manual/lf-iterators.html</haxe_doc>
	</typedef>
	<typedef path="KeyValueIterator" params="K:V" file="/opt/hostedtoolcache/haxe/4.3.2/x64/std/StdTypes.hx" module="StdTypes">
		<t path="Iterator"><a>
	<value><c path="KeyValueIterator.V"/></value>
	<key><c path="KeyValueIterator.K"/></key>
</a></t>
		<haxe_doc>A `KeyValueIterator` is an `Iterator` that has a key and a value.</haxe_doc>
	</typedef>
	<typedef path="KeyValueIterable" params="K:V" file="/opt/hostedtoolcache/haxe/4.3.2/x64/std/StdTypes.hx" module="StdTypes">
		<a><keyValueIterator set="method"><f a=""><t path="KeyValueIterator">
	<c path="KeyValueIterable.K"/>
	<c path="KeyValueIterable.V"/>
</t></f></keyValueIterator></a>
		<haxe_doc>A `KeyValueIterable` is a data structure which has a `keyValueIterator()`
	method to iterate over key-value-pairs.</haxe_doc>
	</typedef>
	<class path="ArrayAccess" params="T" file="/opt/hostedtoolcache/haxe/4.3.2/x64/std/StdTypes.hx" module="StdTypes" extern="1" interface="1"><haxe_doc>`ArrayAccess` is used to indicate a class that can be accessed using brackets.
	The type parameter represents the type of the elements stored.

	This interface should be used for externs only. Haxe does not support custom
	array access on classes. However, array access can be implemented for
	abstract types.

	@see https://haxe.org/manual/types-abstract-array-access.html</haxe_doc></class>
	<class path="Type" params="" file="/opt/hostedtoolcache/haxe/4.3.2/x64/std/js/_std/Type.hx">
		<createInstance public="1" params="T" set="method" line="136" static="1">
			<f a="cl:args">
				<x path="Class"><c path="createInstance.T"/></x>
				<c path="Array"><d/></c>
				<c path="createInstance.T"/>
			</f>
			<haxe_doc>Creates an instance of class `cl`, using `args` as arguments to the
		class constructor.

		This function guarantees that the class constructor is called.

		Default values of constructors arguments are not guaranteed to be
		taken into account.

		If `cl` or `args` are null, or if the number of elements in `args` does
		not match the expected number of constructor arguments, or if any
		argument has an invalid type,  or if `cl` has no own constructor, the
		result is unspecified.

		In particular, default values of constructor arguments are not
		guaranteed to be taken into account.</haxe_doc>
		</createInstance>
		<haxe_doc>The Haxe Reflection API allows retrieval of type information at runtime.

	This class complements the more lightweight Reflect class, with a focus on
	class and enum instances.

	@see https://haxe.org/manual/types.html
	@see https://haxe.org/manual/std-reflection.html</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="echo.util.Disposable" params="" file="/home/runner/work/echo/echo/echo/util/Disposable.hx" interface="1">
		<dispose public="1" set="method"><f a=""><x path="Void"/></f></dispose>
		<meta><m n=":using"><e>echo.util.Disposable</e></m></meta>
	</class>
	<class path="echo.Body" params="" file="/home/runner/work/echo/echo/echo/Body.hx">
		<implements path="echo.util.Disposable"/>
		<defaults public="1" get="accessor" set="null" static="1">
			<t path="echo.data.BodyOptions"/>
			<haxe_doc>* Default Body Options</haxe_doc>
		</defaults>
		<default_mass public="1" expr="AUTO" line="26" static="1">
			<x path="echo.data.MassType"/>
			<meta><m n=":value"><e>AUTO</e></m></meta>
		</default_mass>
		<minimum_mass final="1" public="1" set="null" expr="0.0001" line="28" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0.0001</e></m></meta>
		</minimum_mass>
		<ids expr="0" line="30" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</ids>
		<get_defaults set="method" line="568" static="1"><f a=""><t path="echo.data.BodyOptions"/></f></get_defaults>
		<id public="1" set="null">
			<x path="Int"/>
			<haxe_doc>* Unique id of the Body.</haxe_doc>
		</id>
		<x public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc>* The Body's position on the X axis.</haxe_doc>
		</x>
		<y public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc>* The Body's position on the Y axis.</haxe_doc>
		</y>
		<rotation public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc>* Body's current rotational angle as Degrees.</haxe_doc>
		</rotation>
		<scale_x public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc>* Body's scale on the X axis.</haxe_doc>
		</scale_x>
		<scale_y public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc>* Body's scale on the Y axis.</haxe_doc>
		</scale_y>
		<shape public="1" get="accessor" set="accessor">
			<x path="Null"><c path="echo.Shape"/></x>
			<haxe_doc>* The Body's first `Shape` object in the `shapes` array. If it **isn't** null, this `Shape` object act as the Body's Collider, allowing it to be checked for Collisions.</haxe_doc>
		</shape>
		<shapes public="1" set="null">
			<c path="Array"><c path="echo.Shape"/></c>
			<haxe_doc>* The Body's array of `Shape` objects. If the array **isn't** empty, these `Shape` objects act as the Body's Collider, allowing it to be checked for Collisions.
   *
   * NOTE: If adding shapes directly to this Array, make sure to parent the Shape to the Body (ie `shape.set_parent(body.frame);`).</haxe_doc>
		</shapes>
		<kinematic public="1">
			<x path="Bool"/>
			<haxe_doc>* Flag to set how a Body is affected by Collisions.
   *
   * If set to true, the Body will still Collide and move through the world, but it will not be moved by external collision forces.
   * This is useful for things like moving platforms.</haxe_doc>
		</kinematic>
		<mass public="1" set="accessor">
			<x path="Float"/>
			<haxe_doc>* The Body's mass. Affects how the Body reacts to Collisions and Acceleration Forces. The higher a Body's mass, the more resistant it is to those forces.
   * 
   * If a Body's mass is set to `0`, it becomes static - unmovable by forces and collisions.</haxe_doc>
		</mass>
		<material public="1" expr="Material.global">
			<c path="echo.Material"/>
			<meta><m n=":value"><e>Material.global</e></m></meta>
		</material>
		<elasticity public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":deprecated"><e>"Elasticity Value has been moved into the Material object. Use `body.material.elasticity instead."</e></m></meta>
			<haxe_doc>* Value to determine how much of a Body's `velocity` should be retained during collisions (or how much should the `Body` "bounce", in other words).</haxe_doc>
		</elasticity>
		<velocity public="1" expr="new Vector2(0, 0)">
			<x path="echo.math.Vector2"/>
			<meta><m n=":value"><e>new Vector2(0, 0)</e></m></meta>
			<haxe_doc>* The units/second that a `Body` moves.</haxe_doc>
		</velocity>
		<acceleration public="1" expr="new Vector2(0, 0)">
			<x path="echo.math.Vector2"/>
			<meta><m n=":value"><e>new Vector2(0, 0)</e></m></meta>
			<haxe_doc>* A measure of how fast a `Body` will change it's velocity.
   *
   * Can be thought of the sum of all external forces on an object during a step.</haxe_doc>
		</acceleration>
		<rotational_velocity public="1">
			<x path="Float"/>
			<haxe_doc>* The units/second that a `Body` will rotate.</haxe_doc>
		</rotational_velocity>
		<torque public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* A measure of how fast a `Body` will change it's rotational velocity.
   *
   * Can be thought of the sum of all external rotation forces on an object during a step.</haxe_doc>
		</torque>
		<max_velocity public="1" expr="new Vector2(0, 0)">
			<x path="echo.math.Vector2"/>
			<meta><m n=":value"><e>new Vector2(0, 0)</e></m></meta>
			<haxe_doc>* The maximum values a Body's velocity's x and y components can be. If set to 0, the Body has no restrictions on how fast it can move.
   *
   * Note: this is calculated separately from a Body's `max_velocity_length`, so be careful when applying both.</haxe_doc>
		</max_velocity>
		<max_velocity_length public="1">
			<x path="Float"/>
			<haxe_doc>* The maximum velocity that a `Body` can have along the velocity's length. If set to 0, the Body has no restrictions on how fast it can move.
   *
   * Note: this is calculated separately from a Body's `max_velocity`, so be careful when applying both.</haxe_doc>
		</max_velocity_length>
		<max_rotational_velocity public="1">
			<x path="Float"/>
			<haxe_doc>* The maximum rotational velocity range that a `Body` can have.
   *
   * If set to 0, the Body has no restrictions on how fast it can rotate.</haxe_doc>
		</max_rotational_velocity>
		<drag public="1" expr="new Vector2(0, 0)">
			<x path="echo.math.Vector2"/>
			<meta><m n=":value"><e>new Vector2(0, 0)</e></m></meta>
			<haxe_doc>* A measure of how fast a Body will move its velocity's x and y components towards 0, when there is no acceleration.
   *
   * Note: this is calculated separately from a Body's `drag_length`, so be careful when applying both.</haxe_doc>
		</drag>
		<drag_length public="1">
			<x path="Float"/>
			<haxe_doc>* A measure of how fast a Body will move its velocity towards 0 along the velocity's length, when there is no acceleration.
   *
   * Note: this is calculated separately from a Body's `drag`, so be careful when applying both.</haxe_doc>
		</drag_length>
		<rotational_drag public="1">
			<x path="Float"/>
			<haxe_doc>* A measure of how fast a Body will move its `rotational_velocity` towards 0.</haxe_doc>
		</rotational_drag>
		<gravity_scale public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":deprecated"><e>"Gravity Value has been moved into the Material object. Use `body.material.gravity_scale instead."</e></m></meta>
			<haxe_doc>* Percentage value that represents how much a World's gravity affects the Body.</haxe_doc>
		</gravity_scale>
		<inverse_mass public="1" set="null">
			<x path="Float"/>
			<haxe_doc>* Cached value of 1 divided by the Body's mass. Used in Internal calculations.</haxe_doc>
		</inverse_mass>
		<active public="1">
			<x path="Bool"/>
			<haxe_doc>* Flag to set if the Body is active and will participate in a World's Physics calculations or Collision querys.</haxe_doc>
		</active>
		<layers public="1" expr="new BitMask()">
			<x path="echo.util.BitMask"/>
			<meta><m n=":value"><e>new BitMask()</e></m></meta>
			<haxe_doc>* Collision layers that this Body belongs to. Combine with `layer_mask` to filter collisions between layers.
   *
   * Note: a maximum of 32 layers are supported.</haxe_doc>
		</layers>
		<layer_mask public="1" expr="new BitMask()">
			<x path="echo.util.BitMask"/>
			<meta><m n=":value"><e>new BitMask()</e></m></meta>
			<haxe_doc>* Collision layers that this Body will collide with. Combine with `layers` to filter collisions between layers.
   *
   * Note: a maximum of 32 layers are supported.</haxe_doc>
		</layer_mask>
		<disposed public="1" set="null"><x path="Bool"/></disposed>
		<sleeping>
			<x path="Bool"/>
			<meta>
				<m n=":dox"><e>hide</e></m>
				<m n=":noCompletion"/>
			</meta>
			<haxe_doc>* TODO - sleeping support
   *
   * Flag to check if the Body is in a sleeping state. A Body is awake if it has any acceleration, velocity, or has changed its position/rotation since the last step.
   * If the Body's World has the `sleeping_bodies` optimization on, this flag determines if the Body will participate in a World's Physics calculations or Collision querys.</haxe_doc>
		</sleeping>
		<world public="1" set="null">
			<c path="echo.World"/>
			<meta><m n=":allow"><e>echo.World</e></m></meta>
			<haxe_doc>* The `World` that this body is attached to. It can only be a part of one `World` at a time.</haxe_doc>
		</world>
		<data public="1" set="null">
			<d/>
			<haxe_doc>* Dynamic Object to store any user data on the `Body`. Useful for Callbacks.</haxe_doc>
		</data>
		<collided public="1">
			<x path="Bool"/>
			<haxe_doc>* Flag to check if the Body collided with something during the step.
   * Used for debug drawing.</haxe_doc>
		</collided>
		<transform public="1" expr="new Transform()">
			<c path="echo.util.Transform"/>
			<meta><m n=":value"><e>new Transform()</e></m></meta>
			<haxe_doc>* Structure to help perform matrix calculations for the Body's position, rotation, and scale.</haxe_doc>
		</transform>
		<dirty public="1">
			<x path="Bool"/>
			<haxe_doc>* Flag to check if the Body has changed its position, rotation, or shape colliders.
   * Used for Collision optimization.</haxe_doc>
		</dirty>
		<on_move public="1">
			<x path="Null"><f a=":">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></x>
			<haxe_doc>* If set, this method is called whenever the Body's X or Y changes.</haxe_doc>
		</on_move>
		<on_rotate public="1">
			<x path="Null"><f a="">
	<x path="Float"/>
	<x path="Void"/>
</f></x>
			<haxe_doc>* If set, this method is called whenever the Body's rotation changes.</haxe_doc>
		</on_rotate>
		<last_x public="1" set="null">
			<x path="Float"/>
			<meta><m n=":allow"><e>echo.Physics.step_body</e></m></meta>
		</last_x>
		<last_y public="1" set="null">
			<x path="Float"/>
			<meta><m n=":allow"><e>echo.Physics.step_body</e></m></meta>
		</last_y>
		<last_rotation public="1" set="null">
			<x path="Float"/>
			<meta><m n=":allow"><e>echo.Physics.step_body</e></m></meta>
		</last_rotation>
		<quadtree_data>
			<c path="echo.data.QuadTreeData"/>
			<meta>
				<m n=":dox"><e>hide</e></m>
				<m n=":allow">
					<e>echo.World</e>
					<e>echo.Collisions</e>
					<e>echo.util.Debug</e>
				</m>
			</meta>
		</quadtree_data>
		<load_options public="1" set="method" line="234">
			<f a="?options">
				<x path="Null"><t path="echo.data.BodyOptions"/></x>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets a Body's values from a `BodyOptions` object.
   * @param options</haxe_doc>
		</load_options>
		<clone public="1" set="method" line="281"><f a=""><c path="echo.Body"/></f></clone>
		<create_shape public="1" get="inline" set="null" line="318">
			<f a="options:?position" v=":-1">
				<t path="echo.data.ShapeOptions"/>
				<x path="Int"/>
				<c path="echo.Shape"/>
			</f>
			<meta><m n=":value"><e>{ position : -1 }</e></m></meta>
			<haxe_doc>* Adds a new `Shape` to the Body based on the `ShapeOptions` passed in. 
   * 
   * If `mass` has not been manually set, It's recommended to call `calculate_mass()` after adding/removing a Body's shapes.
   * @param options
   * @param position The position in the Body's `shapes` array the Shape will be added to. If set to -1, the Shape is pushed to the end.
   * @return The newly created `Shape`.</haxe_doc>
		</create_shape>
		<add_shape public="1" get="inline" set="null" line="330">
			<f a="shape:?position" v=":-1">
				<c path="echo.Shape"/>
				<x path="Int"/>
				<c path="echo.Shape"/>
			</f>
			<meta><m n=":value"><e>{ position : -1 }</e></m></meta>
			<haxe_doc>* Adds a `Shape` to the Body.
   * 
   * If `mass` has not been manually set, It's recommended to call `calculate_mass()` after adding/removing a Body's shapes.
   * @param shape
   * @param position The position in the Body's `shapes` array the Shape will be added to. If set to -1, the Shape is pushed to the end.
   * @return The added `Shape`.</haxe_doc>
		</add_shape>
		<remove_shape public="1" get="inline" set="null" line="347">
			<f a="shape">
				<c path="echo.Shape"/>
				<c path="echo.Shape"/>
			</f>
			<haxe_doc>* Removes a `Shape` from the Body.
   * 
   * If `mass` has not been manually set, It's recommended to call `calculate_mass()` after adding/removing a Body's shapes.
   * @param shape The `Shape` to remove.
   * @return Shape The removed `Shape`.</haxe_doc>
		</remove_shape>
		<clear_shapes public="1" get="inline" set="null" line="360">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clears all Shapes from the Body, releasing them to their respective pools.
   * 
   * If `mass` has not been manually set, It's recommended to call `calculate_mass()` after adding/removing a Body's shapes.</haxe_doc>
		</clear_shapes>
		<get_position public="1" set="method" line="367">
			<f a="?vec2">
				<x path="echo.math.Vector2"/>
				<x path="echo.math.Vector2"/>
			</f>
			<haxe_doc>* Gets the Body's position as a new `Vector2` (or sets the `Vector2`, if passed in).</haxe_doc>
		</get_position>
		<set_position public="1" set="method" line="369">
			<f a="?x:?y" v="0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ y : 0, x : 0 }</e></m></meta>
		</set_position>
		<push public="1" set="method" line="381">
			<f a="?x:?y:?forward:?force_type" v="0:0:false:ACCELERATION">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="echo.data.ForceType"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ force_type : ACCELERATION, forward : false, y : 0, x : 0 }</e></m></meta>
			<haxe_doc>* Adds forces to a Body. 
   * 
   * Options are available to apply the forces relative to the Body's forward, or to configure whether the forces are applied to the Body's acceleration, velocity, or position.
   * @param x
   * @param y
   * @param forward Set as `true` to apply the forces relative to the Body's forward (based on the Body's `rotation`).
   * @param force_type Determines whether the forces are applied to the Body's acceleration, velocity, or position.</haxe_doc>
		</push>
		<bounds public="1" set="method" line="405">
			<f a="?aabb">
				<c path="echo.util.AABB"/>
				<c path="echo.util.AABB"/>
			</f>
			<haxe_doc><![CDATA[* If a Body has shapes, it will return an `AABB` representing the bounds of the Body's shapes relative to its position. If the Body does not have any shapes, this will return `null'.
   * @param aabb Optional `AABB` to set the values to. If the Body does not have any shapes, the AABB will not be set.
   * @return Null<AABB>]]></haxe_doc>
		</bounds>
		<remove public="1" get="inline" set="null" line="424">
			<f a=""><c path="echo.Body"/></f>
			<haxe_doc>* If the Body is attached to a World, it is removed.
   * @return The detached Body.</haxe_doc>
		</remove>
		<is_dynamic public="1" get="inline" set="null" line="433">
			<f a=""><x path="Bool"/></f>
			<haxe_doc><![CDATA[* Checks if the Body is Dynamic (if it's mass is greater than 0).
   * @return  body.mass > 0]]></haxe_doc>
		</is_dynamic>
		<is_static public="1" get="inline" set="null" line="438">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Checks if the Body is Static (if it's mass is equal to 0).
   * @return  body.mass == 0</haxe_doc>
		</is_static>
		<update_static_bounds public="1" get="inline" set="null" line="442">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* If the Body is Static, update it's Quadtree Bounds.</haxe_doc>
		</update_static_bounds>
		<calculate_mass public="1" get="inline" set="null" line="453">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Calculates the Body's mass based on the volume of it's shapes and the `density` defined in it's `Material`.
   * 
   * This should be called whenever a Body's overall shape is changed, such as in cases of changing the Body's scale - or if an individual shape on the Body has been added, removed, moved, rotated, or scaled.</haxe_doc>
		</calculate_mass>
		<moved public="1" get="inline" set="null" line="463">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Returns true if the Body has moved since the last `Physics.step()`.</haxe_doc>
		</moved>
		<dispose public="1" set="method" line="467">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Disposes the Body. DO NOT use the Body after disposing it, as it could lead to null reference errors.</haxe_doc>
		</dispose>
		<toString set="method" line="482"><f a=""><c path="String"/></f></toString>
		<on_dirty set="method" line="484"><f a="t">
	<c path="echo.util.Transform"/>
	<x path="Void"/>
</f></on_dirty>
		<get_x get="inline" set="null" line="489"><f a=""><x path="Float"/></f></get_x>
		<get_y get="inline" set="null" line="491"><f a=""><x path="Float"/></f></get_y>
		<get_rotation get="inline" set="null" line="493"><f a=""><x path="Float"/></f></get_rotation>
		<get_scale_x get="inline" set="null" line="495"><f a=""><x path="Float"/></f></get_scale_x>
		<get_scale_y get="inline" set="null" line="497"><f a=""><x path="Float"/></f></get_scale_y>
		<get_shape get="inline" set="null" line="499"><f a=""><x path="Null"><c path="echo.Shape"/></x></f></get_shape>
		<get_elasticity get="inline" set="null" line="501">
			<f a=""><x path="Float"/></f>
			<meta><m n=":deprecated"><e>"Elasticity Value has been moved into the Material object. Use `body.material.elasticity instead."</e></m></meta>
		</get_elasticity>
		<get_gravity_scale get="inline" set="null" line="503">
			<f a=""><x path="Float"/></f>
			<meta><m n=":deprecated"><e>"Gravity Value has been moved into the Material object. Use `body.material.gravity_scale instead."</e></m></meta>
		</get_gravity_scale>
		<set_x get="inline" set="null" line="506"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_x>
		<set_y get="inline" set="null" line="513"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_y>
		<set_rotation get="inline" set="null" line="520"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_rotation>
		<set_scale_x get="inline" set="null" line="527"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_scale_x>
		<set_scale_y get="inline" set="null" line="531"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_scale_y>
		<set_shape get="inline" set="null" line="535"><f a="value">
	<c path="echo.Shape"/>
	<x path="Null"><c path="echo.Shape"/></x>
</f></set_shape>
		<set_mass get="inline" set="null" line="544"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_mass>
		<set_elasticity get="inline" set="null" line="560">
			<f a="value">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":deprecated"><e>"Elasticity Value has been moved into the Material object. Use `body.material.elasticity instead."</e></m></meta>
		</set_elasticity>
		<set_gravity_scale get="inline" set="null" line="564">
			<f a="value">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":deprecated"><e>"Gravity Value has been moved into the Material object. Use `body.material.gravity_scale instead."</e></m></meta>
		</set_gravity_scale>
		<new public="1" set="method" line="221">
			<f a="?options">
				<x path="Null"><t path="echo.data.BodyOptions"/></x>
				<x path="Void"/>
			</f>
			<haxe_doc>* Creates a new Body.
   * @param options Optional values to configure the new Body</haxe_doc>
		</new>
		<haxe_doc>* A `Body` is an Object representing a Physical Body in a `World`.
 *
 * Bodies have position, velocity, mass, an optional collider shape, and many other properties that are used in a `World` simulation.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>echo.Macros.build_body()</e></m>
		</meta>
	</class>
	<class path="echo.Collisions" params="" file="/home/runner/work/echo/echo/echo/Collisions.hx">
		<update_quadtree public="1" set="method" line="14" static="1">
			<f a="world">
				<c path="echo.World"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Updates the World's dynamic QuadTree with any Bodies that have moved.</haxe_doc>
		</update_quadtree>
		<query public="1" set="method" line="38" static="1">
			<f a="world:?listeners">
				<c path="echo.World"/>
				<c path="echo.Listeners"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Queries a World's Listeners for Collisions.
   * @param world The World to query.
   * @param listeners Optional collection of listeners to query. If this is set, the World's listeners will not be queried.</haxe_doc>
		</query>
		<notify public="1" set="method" line="137" static="1">
			<f a="world:?listeners">
				<c path="echo.World"/>
				<c path="echo.Listeners"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Enacts the Callbacks defined in a World's Listeners</haxe_doc>
		</notify>
		<overlap_bodies_and_bodies_bounds public="1" set="method" line="182" static="1"><f a="a:b:world:results">
	<c path="Array"><c path="echo.Body"/></c>
	<c path="Array"><c path="echo.Body"/></c>
	<c path="echo.World"/>
	<c path="Array"><c path="echo.data.Collision"/></c>
	<x path="Void"/>
</f></overlap_bodies_and_bodies_bounds>
		<qr expr="[]" line="187" static="1">
			<c path="Array"><c path="echo.data.QuadTreeData"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</qr>
		<sqr expr="[]" line="188" static="1">
			<c path="Array"><c path="echo.data.QuadTreeData"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</sqr>
		<overlap_body_and_bodies_bounds public="1" set="method" line="190" static="1"><f a="body:bodies:world:results">
	<c path="echo.Body"/>
	<c path="Array"><c path="echo.Body"/></c>
	<c path="echo.World"/>
	<c path="Array"><c path="echo.data.Collision"/></c>
	<x path="Void"/>
</f></overlap_body_and_bodies_bounds>
		<overlap_body_and_body_bounds public="1" set="method" line="206" static="1"><f a="a:b">
	<c path="echo.Body"/>
	<c path="echo.Body"/>
	<x path="Null"><c path="echo.data.Collision"/></x>
</f></overlap_body_and_body_bounds>
		<layer_match get="inline" set="null" line="217" static="1"><f a="a:b">
	<c path="echo.Body"/>
	<c path="echo.Body"/>
	<x path="Bool"/>
</f></layer_match>
		<haxe_doc>* Class containing methods for performing Collisions on a World</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="echo.Listeners" params="" file="/home/runner/work/echo/echo/echo/Listener.hx" module="echo.Listener">
		<implements path="echo.util.Disposable"/>
		<members public="1"><c path="Array"><c path="echo.Listener"/></c></members>
		<add public="1" set="method" line="88">
			<f a="a:b:?options">
				<x path="echo.util.BodyOrBodies"/>
				<x path="echo.util.BodyOrBodies"/>
				<x path="Null"><t path="echo.data.ListenerOptions"/></x>
				<c path="echo.Listener"/>
			</f>
			<haxe_doc>* Add a new Listener to the collection.
   * @param a The first `Body` or Array of Bodies to collide against.
   * @param b The second `Body` or Array of Bodies to collide against.
   * @param options Options to define the Listener's behavior.
   * @return The new Listener.</haxe_doc>
		</add>
		<remove public="1" set="method" line="112">
			<f a="listener">
				<c path="echo.Listener"/>
				<c path="echo.Listener"/>
			</f>
			<haxe_doc>* Removes a Listener from the Container.
   * @param listener Listener to remove.
   * @return The removed Listener.</haxe_doc>
		</remove>
		<clear public="1" set="method" line="119">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clears the collection of all Listeners.</haxe_doc>
		</clear>
		<dispose public="1" set="method" line="125">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Disposes of the collection. Do not use once disposed.</haxe_doc>
		</dispose>
		<iterator public="1" get="inline" set="null" line="129"><f a=""><t path="Iterator"><c path="echo.Listener"/></t></f></iterator>
		<new public="1" set="method" line="78"><f a="?members">
	<c path="Array"><c path="echo.Listener"/></c>
	<x path="Void"/>
</f></new>
		<haxe_doc>* Container used to store Listeners</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="echo.Echo" params="" file="/home/runner/work/echo/echo/echo/Echo.hx">
		<cached_listeners final="1" set="null" expr="new Listeners()" line="22" static="1">
			<c path="echo.Listeners"/>
			<meta><m n=":value"><e>new Listeners()</e></m></meta>
			<haxe_doc>* Cache'd `Listeners` collection to help with memory management.</haxe_doc>
		</cached_listeners>
		<cached_collisions final="1" set="null" expr="[]" line="26" static="1">
			<c path="Array"><c path="echo.data.Collision"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
			<haxe_doc>* Cache'd `Collision` Array to help with memory management.</haxe_doc>
		</cached_collisions>
		<cached_body final="1" set="null" expr="new Body({ mass : 1 })" line="30" static="1">
			<c path="echo.Body"/>
			<meta><m n=":value"><e>new Body({ mass : 1 })</e></m></meta>
			<haxe_doc>* Cache'd `Body` to help with memory management.</haxe_doc>
		</cached_body>
		<start public="1" set="method" line="36" static="1">
			<f a="options">
				<t path="echo.data.WorldOptions"/>
				<c path="echo.World"/>
			</f>
			<haxe_doc>* Shortcut for creating a new `World`
   * @param options Options for the new `World`
   * @return World</haxe_doc>
		</start>
		<make public="1" set="method" line="43" static="1">
			<f a="world:options">
				<c path="echo.World"/>
				<t path="echo.data.BodyOptions"/>
				<c path="echo.Body"/>
			</f>
			<haxe_doc>* Shortcut for creating a new `Body` and adding it to the `World`
   * @param world the `World` to add the `Body` to
   * @param options Options for the new `Body`
   * @return Body</haxe_doc>
		</make>
		<listen public="1" set="method" line="52" static="1">
			<f a="world:?a:?b:?options">
				<c path="echo.World"/>
				<x path="echo.util.BodyOrBodies"/>
				<x path="echo.util.BodyOrBodies"/>
				<x path="Null"><t path="echo.data.ListenerOptions"/></x>
				<c path="echo.Listener"/>
			</f>
			<haxe_doc>* Shortcut for creating a new `Listener` for a set of Bodies in the `World`.
   * @param world the `World` to add the `Listener` to
   * @param a The first `Body` or Array of Bodies to collide against
   * @param b The second `Body` or Array of Bodies to collide against
   * @param options Options to define the Listener's behavior
   * @return Listener</haxe_doc>
		</listen>
		<check public="1" set="method" line="64" static="1">
			<f a="world:?a:?b:?options">
				<c path="echo.World"/>
				<x path="echo.util.BodyOrBodies"/>
				<x path="echo.util.BodyOrBodies"/>
				<x path="Null"><t path="echo.data.ListenerOptions"/></x>
				<x path="Void"/>
			</f>
			<haxe_doc>* Performs a one-time collision check.
   * @param world the `World` to check for collisions
   * @param a The first `Body` or Array of Bodies to collide against
   * @param b The second `Body` or Array of Bodies to collide against
   * @param options Options to define the Collision Check's behavior</haxe_doc>
		</check>
		<step public="1" set="method" line="82" static="1">
			<f a="world:dt:?rate" v="::0">
				<c path="echo.World"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ rate : 0 }</e></m></meta>
			<haxe_doc>* Steps a `World` forward.
   * @param world
   * @param dt The Delta Time to step the `World` Forward
   * @param rate The target rate of Step-Per-Second. If set to 0, the target rate is unlimited.</haxe_doc>
		</step>
		<linecast_floats public="1" get="inline" set="null" line="131" static="1">
			<f a="x:y:dx:dy:test:?world:?update_world_quadtree" v="::::::true">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="echo.util.BodyOrBodies"/>
				<c path="echo.World"/>
				<x path="Bool"/>
				<x path="Null"><c path="echo.data.Intersection"/></x>
			</f>
			<meta><m n=":value"><e>{ update_world_quadtree : true }</e></m></meta>
			<haxe_doc><![CDATA[* Casts a Line Created from the supplied floats, returning the Intersection with the closest Body.
   * @param x The X position to start the cast.
   * @param y The Y position to start the cast.
   * @param dx The X position to end the cast.
   * @param dy The Y position to end the cast.
   * @param test The Body or Array of Bodies to Cast the Line at.
   * @return Null<Intersection> the Intersection with the closest Body, if any occured.]]></haxe_doc>
		</linecast_floats>
		<linecast_vector public="1" get="inline" set="null" line="146" static="1">
			<f a="start:angle:length:test:?world:?update_world_quadtree" v=":::::true">
				<x path="echo.math.Vector2"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="echo.util.BodyOrBodies"/>
				<c path="echo.World"/>
				<x path="Bool"/>
				<x path="Null"><c path="echo.data.Intersection"/></x>
			</f>
			<meta><m n=":value"><e>{ update_world_quadtree : true }</e></m></meta>
			<haxe_doc><![CDATA[* Casts a Line Created from the supplied vector, angle, and length returning the Intersection with the closest Body.
   * @param start  The position to start the cast.
   * @param angle  The anglet of the casted Line.
   * @param length The lengh of the casted Line.
   * @param test The Body or Array of Bodies to Cast the Line at.
   * @return Null<Intersection> the Intersection with the closest Body, if any occured.]]></haxe_doc>
		</linecast_vector>
		<linecast_vectors public="1" get="inline" set="null" line="160" static="1">
			<f a="start:end:test:?world:?update_world_quadtree" v="::::true">
				<x path="echo.math.Vector2"/>
				<x path="echo.math.Vector2"/>
				<x path="echo.util.BodyOrBodies"/>
				<c path="echo.World"/>
				<x path="Bool"/>
				<x path="Null"><c path="echo.data.Intersection"/></x>
			</f>
			<meta><m n=":value"><e>{ update_world_quadtree : true }</e></m></meta>
			<haxe_doc><![CDATA[* Casts a Line Created from the supplied vectors, returning the Intersection with the closest Body.
   * @param start The position to start the cast.
   * @param end The position to end the cast.
   * @param test The Body or Array of Bodies to Cast the Line at.
   * @return Null<Intersection> the Intersection with the closest Body, if any occured.]]></haxe_doc>
		</linecast_vectors>
		<linecast public="1" set="method" line="172" static="1">
			<f a="line:test:?world:?update_world_quadtree" v=":::true">
				<c path="echo.Line"/>
				<x path="echo.util.BodyOrBodies"/>
				<c path="echo.World"/>
				<x path="Bool"/>
				<x path="Null"><c path="echo.data.Intersection"/></x>
			</f>
			<meta><m n=":value"><e>{ update_world_quadtree : true }</e></m></meta>
			<haxe_doc><![CDATA[* Casts a Line, returning the Intersection with the closest Body.
   * @param line Line to Cast.
   * @param test The Body or Array of Bodies to Cast the Line at.
   * @return Null<Intersection> the Intersection with the closest Body, if any occured.]]></haxe_doc>
		</linecast>
		<linecast_all public="1" set="method" line="244" static="1">
			<f a="line:test:?world:?update_world_quadtree" v=":::true">
				<c path="echo.Line"/>
				<x path="echo.util.BodyOrBodies"/>
				<c path="echo.World"/>
				<x path="Bool"/>
				<c path="Array"><c path="echo.data.Intersection"/></c>
			</f>
			<meta><m n=":value"><e>{ update_world_quadtree : true }</e></m></meta>
			<haxe_doc><![CDATA[* Casts a Line, returning all Intersections.
   * @param line Line to Cast.
   * @param test The Body or Array of Bodies to Cast the Line at.
   * @return Array<Intersection> All Intersections found. if none occured, the length will be 0.]]></haxe_doc>
		</linecast_all>
		<undo public="1" set="method" line="308" static="1">
			<f a="world">
				<c path="echo.World"/>
				<c path="echo.World"/>
			</f>
			<haxe_doc>* Undo the World's last step
   * @param world
   * @return World</haxe_doc>
		</undo>
		<redo public="1" set="method" line="334" static="1">
			<f a="world">
				<c path="echo.World"/>
				<c path="echo.World"/>
			</f>
			<haxe_doc>* Redo the World's last step
   * @param world
   * @return World</haxe_doc>
		</redo>
		<meta><m n=":expose"/></meta>
	</class>
	<class path="echo.util.Poolable" params="" file="/home/runner/work/echo/echo/echo/util/Poolable.hx" interface="1">
		<put public="1" set="method"><f a=""><x path="Void"/></f></put>
		<haxe_doc>*	Implementing this interface on a Class will run `PoolableMacros.build`, then remove itself.</haxe_doc>
		<meta><m n=":autoBuild"><e>echo.util.PoolableMacros.build()</e></m></meta>
	</class>
	<class path="echo.util.Proxy" params="" file="/home/runner/work/echo/echo/echo/util/Proxy.hx" interface="1">
		<haxe_doc>*	Implementing this interface on a Class will run `ProxyMacros.build`, then remove itself.</haxe_doc>
		<meta>
			<m n=":remove"/>
			<m n=":autoBuild"><e>echo.util.ProxyMacros.build()</e></m>
		</meta>
	</class>
	<class path="echo.util.Pool" params="T" file="/home/runner/work/echo/echo/echo/util/Poolable.hx" module="echo.util.Poolable" interface="1">
		<pre_allocate public="1" set="method"><f a="amount">
	<x path="Int"/>
	<x path="Void"/>
</f></pre_allocate>
		<clear public="1" set="method"><f a=""><c path="Array"><c path="echo.util.Pool.T"/></c></f></clear>
	</class>
	<class path="echo.Line" params="" file="/home/runner/work/echo/echo/echo/Line.hx">
		<implements path="echo.util.Poolable"/>
		<get public="1" get="inline" set="null" line="27" static="1">
			<f a="?x:?y:?dx:?dy" v="0:0:1:1">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="echo.Line"/>
			</f>
			<meta><m n=":value"><e>{ dy : 1, dx : 1, y : 0, x : 0 }</e></m></meta>
		</get>
		<get_from_vector public="1" get="inline" set="null" line="39" static="1">
			<f a="start:degrees:length">
				<x path="echo.math.Vector2"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="echo.Line"/>
			</f>
			<haxe_doc>* Gets a Line with the defined start point, angle (in degrees), and length.
   * @param start A Vector2 describing the starting position of the Line.
   * @param degrees The angle of the Line (in degrees).
   * @param length The length of the Line.</haxe_doc>
		</get_from_vector>
		<get_from_vectors public="1" get="inline" set="null" line="46" static="1"><f a="start:end">
	<x path="echo.math.Vector2"/>
	<x path="echo.math.Vector2"/>
	<c path="echo.Line"/>
</f></get_from_vectors>
		<pool expr="new echo.util.Poolable.GenericPool&lt;echo.Line&gt;(echo.Line)" line="89" static="1">
			<c path="echo.util.GenericPool_echo_Line"/>
			<meta><m n=":value"><e><![CDATA[new echo.util.Poolable.GenericPool<echo.Line>(echo.Line)]]></e></m></meta>
		</pool>
		<get_pool public="1" set="method" line="97" static="1"><f a=""><c path="echo.util.Pool"><c path="echo.Line"/></c></f></get_pool>
		<x public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":alias"><e>start.x</e></m></meta>
		</x>
		<y public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":alias"><e>start.y</e></m></meta>
		</y>
		<start public="1"><x path="echo.math.Vector2"/></start>
		<dx public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":alias"><e>end.x</e></m></meta>
		</dx>
		<dy public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":alias"><e>end.y</e></m></meta>
		</dy>
		<end public="1"><x path="echo.math.Vector2"/></end>
		<length public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":alias"><e>start.distanceTo(end)</e></m></meta>
		</length>
		<radians public="1" get="accessor" set="null"><x path="Float"/></radians>
		<set public="1" get="inline" set="null" line="55">
			<f a="?x:?y:?dx:?dy" v="0:0:1:1">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="echo.Line"/>
			</f>
			<meta><m n=":value"><e>{ dy : 1, dx : 1, y : 0, x : 0 }</e></m></meta>
		</set>
		<set_from_vector public="1" set="method" line="66">
			<f a="start:degrees:length">
				<x path="echo.math.Vector2"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="echo.Line"/>
			</f>
			<haxe_doc>* Sets the Line with the defined start point, angle (in degrees), and length.
   * @param start A Vector2 describing the starting position of the Line.
   * @param degrees The angle of the Line (in degrees).
   * @param length The length of the Line.</haxe_doc>
		</set_from_vector>
		<set_from_vectors public="1" get="inline" set="null" line="72"><f a="start:end">
	<x path="echo.math.Vector2"/>
	<x path="echo.math.Vector2"/>
	<c path="echo.Line"/>
</f></set_from_vectors>
		<put public="1" get="inline" set="null" line="76"><f a=""><x path="Void"/></f></put>
		<contains public="1" set="method" line="83"><f a="v">
	<x path="echo.math.Vector2"/>
	<x path="Bool"/>
</f></contains>
		<intersect public="1" get="inline" set="null" line="90"><f a="shape">
	<c path="echo.Shape"/>
	<x path="Null"><c path="echo.data.IntersectionData"/></x>
</f></intersect>
		<point_along_ratio public="1" get="inline" set="null" line="98">
			<f a="ratio">
				<x path="Float"/>
				<x path="echo.math.Vector2"/>
			</f>
			<haxe_doc>* Gets a position on the `Line` at the specified ratio.
   * @param ratio The ratio from the Line's `start` and `end` points (expects a value between 0.0 and 1.0).
   * @return Vector2</haxe_doc>
		</point_along_ratio>
		<ratio_of_point public="1" get="inline" set="null" line="102">
			<f a="point:?clamp" v=":true">
				<x path="echo.math.Vector2"/>
				<x path="Bool"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>{ clamp : true }</e></m></meta>
		</ratio_of_point>
		<project_point public="1" get="inline" set="null" line="110">
			<f a="point:?clamp" v=":true">
				<x path="echo.math.Vector2"/>
				<x path="Bool"/>
				<x path="echo.math.Vector2"/>
			</f>
			<meta><m n=":value"><e>{ clamp : true }</e></m></meta>
		</project_point>
		<side public="1" get="inline" set="null" line="116">
			<f a="point:?set">
				<x path="echo.math.Vector2"/>
				<x path="echo.math.Vector2"/>
				<x path="echo.math.Vector2"/>
			</f>
			<haxe_doc>* Gets the Line's normal based on the relative position of the point.</haxe_doc>
		</side>
		<to_aabb public="1" get="inline" set="null" line="126">
			<f a="?put_self" v="false">
				<x path="Bool"/>
				<x path="Null"><c path="echo.util.AABB"/></x>
			</f>
			<meta><m n=":value"><e>{ put_self : false }</e></m></meta>
		</to_aabb>
		<bounds public="1" get="inline" set="null" line="135"><f a="?aabb">
	<c path="echo.util.AABB"/>
	<x path="Null"><c path="echo.util.AABB"/></x>
</f></bounds>
		<get_length get="inline" set="null" line="163"><f a=""><x path="Float"/></f></get_length>
		<get_radians get="inline" set="null" line="165"><f a=""><x path="Float"/></f></get_radians>
		<set_length public="1" set="method" line="167"><f a="l">
	<x path="Float"/>
	<x path="Float"/>
</f></set_length>
		<set_radians public="1" set="method" line="175"><f a="r">
	<x path="Float"/>
	<x path="Float"/>
</f></set_radians>
		<toString set="method" line="182"><f a=""><c path="String"/></f></toString>
		<pooled public="1" set="null" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</pooled>
		<get_x set="method" line="118"><f a=""><x path="Float"/></f></get_x>
		<set_x set="method" line="132"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_x>
		<get_y set="method" line="118"><f a=""><x path="Float"/></f></get_y>
		<set_y set="method" line="132"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_y>
		<get_dx set="method" line="118"><f a=""><x path="Float"/></f></get_dx>
		<set_dx set="method" line="132"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_dx>
		<get_dy set="method" line="118"><f a=""><x path="Float"/></f></get_dy>
		<set_dy set="method" line="132"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_dy>
		<new get="inline" set="null" line="50">
			<f a="?x:?y:?dx:?dy" v="0:0:1:1">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ dy : 1, dx : 1, y : 0, x : 0 }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>echo.util.PoolableMacros.build()</e></m>
			<m n=":autoBuild"><e>echo.util.PoolableMacros.build()</e></m>
			<m n=":build"><e>echo.util.ProxyMacros.build()</e></m>
			<m n=":autoBuild"><e>echo.util.ProxyMacros.build()</e></m>
			<m n=":using"><e>echo.Echo</e></m>
		</meta>
	</class>
	<class path="echo.Listener" params="" file="/home/runner/work/echo/echo/echo/Listener.hx">
		<defaults public="1" get="accessor" set="null" static="1"><t path="echo.data.ListenerOptions"/></defaults>
		<get_defaults set="method" line="66" static="1"><f a=""><t path="echo.data.ListenerOptions"/></f></get_defaults>
		<a public="1">
			<e path="haxe.ds.Either">
				<c path="echo.Body"/>
				<c path="Array"><c path="echo.Body"/></c>
			</e>
			<haxe_doc>* The first Body or Array of Bodies the listener checks each step.</haxe_doc>
		</a>
		<b public="1">
			<e path="haxe.ds.Either">
				<c path="echo.Body"/>
				<c path="Array"><c path="echo.Body"/></c>
			</e>
			<haxe_doc>* The second Body or Array of Bodies the listener checks each step.</haxe_doc>
		</b>
		<separate public="1">
			<x path="Bool"/>
			<haxe_doc>* Flag that determines if Collisions found by this listener should separate the Bodies. Defaults to `true`.</haxe_doc>
		</separate>
		<collisions public="1">
			<c path="Array"><c path="echo.data.Collision"/></c>
			<haxe_doc>* Store of the latest Collisions.</haxe_doc>
		</collisions>
		<last_collisions public="1">
			<c path="Array"><c path="echo.data.Collision"/></c>
			<haxe_doc>* Store of the Collisions from the Prior Frame.</haxe_doc>
		</last_collisions>
		<enter public="1">
			<f a="::">
				<c path="echo.Body"/>
				<c path="echo.Body"/>
				<c path="Array"><c path="echo.data.CollisionData"/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":optional"/></meta>
			<haxe_doc>* A callback function that is called on the first frame that a collision starts.</haxe_doc>
		</enter>
		<stay public="1">
			<f a="::">
				<c path="echo.Body"/>
				<c path="echo.Body"/>
				<c path="Array"><c path="echo.data.CollisionData"/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":optional"/></meta>
			<haxe_doc>* A callback function that is called on frames when two Bodies are continuing to collide.</haxe_doc>
		</stay>
		<exit public="1">
			<f a=":">
				<c path="echo.Body"/>
				<c path="echo.Body"/>
				<x path="Void"/>
			</f>
			<meta><m n=":optional"/></meta>
			<haxe_doc>* A callback function that is called when a collision between two Bodies ends.</haxe_doc>
		</exit>
		<condition public="1">
			<f a="::">
				<c path="echo.Body"/>
				<c path="echo.Body"/>
				<c path="Array"><c path="echo.data.CollisionData"/></c>
				<x path="Bool"/>
			</f>
			<meta><m n=":optional"/></meta>
			<haxe_doc>* A callback function that allows extra logic to be run on a potential collision.
   *
   * If it returns true, the collision is valid. Otherwise the collision is discarded and no physics resolution/collision callbacks occur</haxe_doc>
		</condition>
		<quadtree_results public="1">
			<c path="Array"><c path="echo.data.Collision"/></c>
			<meta><m n=":optional"/></meta>
			<haxe_doc>* Store of the latest quadtree query results</haxe_doc>
		</quadtree_results>
		<percent_correction public="1">
			<x path="Float"/>
			<haxe_doc>* Percentage of correction along the collision normal to be applied to seperating bodies. Helps prevent objects sinking into each other.</haxe_doc>
		</percent_correction>
		<correction_threshold public="1">
			<x path="Float"/>
			<haxe_doc>* Threshold determining how close two separating bodies must be before position correction occurs. Helps reduce jitter.</haxe_doc>
		</correction_threshold>
		<new public="1" set="method" line="13">
			<f a="a:b:separate:collisions:last_collisions:?enter:?stay:?exit:?condition:?quadtree_results:percent_correction:correction_threshold">
				<e path="haxe.ds.Either">
					<c path="echo.Body"/>
					<c path="Array"><c path="echo.Body"/></c>
				</e>
				<e path="haxe.ds.Either">
					<c path="echo.Body"/>
					<c path="Array"><c path="echo.Body"/></c>
				</e>
				<x path="Bool"/>
				<c path="Array"><c path="echo.data.Collision"/></c>
				<c path="Array"><c path="echo.data.Collision"/></c>
				<f a="::">
					<c path="echo.Body"/>
					<c path="echo.Body"/>
					<c path="Array"><c path="echo.data.CollisionData"/></c>
					<x path="Void"/>
				</f>
				<f a="::">
					<c path="echo.Body"/>
					<c path="echo.Body"/>
					<c path="Array"><c path="echo.data.CollisionData"/></c>
					<x path="Void"/>
				</f>
				<f a=":">
					<c path="echo.Body"/>
					<c path="echo.Body"/>
					<x path="Void"/>
				</f>
				<f a="::">
					<c path="echo.Body"/>
					<c path="echo.Body"/>
					<c path="Array"><c path="echo.data.CollisionData"/></c>
					<x path="Bool"/>
				</f>
				<c path="Array"><c path="echo.data.Collision"/></c>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":compilerGenerated"/>
				<m n=":inheritDoc"/>
			</meta>
			<haxe_doc>@param correction_threshold * Threshold determining how close two separating bodies must be before position correction occurs. Helps reduce jitter.
@param percent_correction * Percentage of correction along the collision normal to be applied to seperating bodies. Helps prevent objects sinking into each other.
@param quadtree_results * Store of the latest quadtree query results
@param condition * A callback function that allows extra logic to be run on a potential collision.
   *
   * If it returns true, the collision is valid. Otherwise the collision is discarded and no physics resolution/collision callbacks occur
@param exit * A callback function that is called when a collision between two Bodies ends.
@param stay * A callback function that is called on frames when two Bodies are continuing to collide.
@param enter * A callback function that is called on the first frame that a collision starts.
@param last_collisions * Store of the Collisions from the Prior Frame.
@param collisions * Store of the latest Collisions.
@param separate * Flag that determines if Collisions found by this listener should separate the Bodies. Defaults to `true`.
@param b * The second Body or Array of Bodies the listener checks each step.
@param a * The first Body or Array of Bodies the listener checks each step.</haxe_doc>
		</new>
		<haxe_doc>* Data Structure used to listen for Collisions between Bodies.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="echo.Material" params="" file="/home/runner/work/echo/echo/echo/Material.hx">
		<global public="1" expr="{ }" line="10" static="1">
			<c path="echo.Material"/>
			<meta><m n=":value"><e>{ }</e></m></meta>
		</global>
		<elasticity public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Value to determine how much of a Body's `velocity` should be retained during collisions (or how much should the `Body` "bounce" in other words).</haxe_doc>
		</elasticity>
		<density public="1" expr="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
			<haxe_doc>*</haxe_doc>
		</density>
		<friction public="1" expr="0">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":dox"><e>hide</e></m>
				<m n=":noCompletion"/>
			</meta>
			<haxe_doc>* TODO</haxe_doc>
		</friction>
		<static_friction public="1" expr="0">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":dox"><e>hide</e></m>
				<m n=":noCompletion"/>
			</meta>
			<haxe_doc>* TODO</haxe_doc>
		</static_friction>
		<gravity_scale public="1" expr="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
			<haxe_doc>* Percentage value that represents how much a World's gravity affects the Body.</haxe_doc>
		</gravity_scale>
		<new public="1" set="method" line="9">
			<f a="?elasticity:?density:?friction:?static_friction:?gravity_scale">
				<x path="Null"><x path="Float"/></x>
				<x path="Null"><x path="Float"/></x>
				<x path="Null"><x path="Float"/></x>
				<x path="Null"><x path="Float"/></x>
				<x path="Null"><x path="Float"/></x>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":compilerGenerated"/>
				<m n=":inheritDoc"/>
			</meta>
			<haxe_doc>@param gravity_scale * Percentage value that represents how much a World's gravity affects the Body.
@param static_friction * TODO
@param friction * TODO
@param density *
@param elasticity * Value to determine how much of a Body's `velocity` should be retained during collisions (or how much should the `Body` "bounce" in other words).</haxe_doc>
		</new>
		<haxe_doc>* A Structure that describes the physical properties of a `Body`.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="echo.Physics" params="" file="/home/runner/work/echo/echo/echo/Physics.hx">
		<step public="1" set="method" line="17" static="1">
			<f a="world:dt">
				<c path="echo.World"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Applies movement forces to a World's Bodies
   * @param world World to step forward
   * @param dt elapsed time since the last step</haxe_doc>
		</step>
		<step_body public="1" get="inline" set="null" line="21" static="1"><f a="body:dt:gravity_x:gravity_y">
	<c path="echo.Body"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></step_body>
		<separate public="1" set="method" line="66" static="1">
			<f a="world:?listeners">
				<c path="echo.World"/>
				<c path="echo.Listeners"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Loops through all of a World's Listeners, separating all collided Bodies in the World. Use `Collisions.query()` before calling this to query the World's Listeners for collisions.
   * @param world
   * @param dt</haxe_doc>
		</separate>
		<resolve public="1" get="inline" set="null" line="81" static="1">
			<f a="a:b:cd:?correction_threshold:?percent_correction:?advanced" v=":::0.013:0.9:false">
				<c path="echo.Body"/>
				<c path="echo.Body"/>
				<c path="echo.data.CollisionData"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ advanced : false, percent_correction : 0.9, correction_threshold : 0.013 }</e></m></meta>
			<haxe_doc>* Resolves a Collision between two Bodies, separating them if the conditions are correct.
   * @param a the first `Body` in the Collision
   * @param b the second `Body` in the Collision
   * @param cd Data related to the Collision</haxe_doc>
		</resolve>
		<compute_velocity public="1" get="inline" set="null" line="142" static="1"><f a="v:a:d:m:dt">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></compute_velocity>
		<haxe_doc>* Class containing methods for performing Physics simulations on a World</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="echo.Shape" params="" file="/home/runner/work/echo/echo/echo/Shape.hx">
		<defaults public="1" get="accessor" set="null" static="1">
			<t path="echo.data.ShapeOptions"/>
			<haxe_doc>* Default Shape Options</haxe_doc>
		</defaults>
		<get public="1" set="method" line="23" static="1">
			<f a="options">
				<t path="echo.data.ShapeOptions"/>
				<c path="echo.Shape"/>
			</f>
			<haxe_doc>* Gets a Shape. If one is available, it will be grabbed from the Object Pool. Otherwise a new Shape will be created.
   * @param options
   * @return Shape</haxe_doc>
		</get>
		<rect public="1" get="inline" set="null" line="48" static="1">
			<f a="?x:?y:?width:?height:?scale_x:?scale_y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="echo.shape.Rect"/>
			</f>
			<haxe_doc>* Gets a `Rect` from the Rect Classes' Object Pool. Shortcut for `Rect.get()`.
   * @param x The X position of the Rect
   * @param y The Y position of the Rect
   * @param width The width of the Rect
   * @param height The height of the Rect
   * @return Rect</haxe_doc>
		</rect>
		<square public="1" get="inline" set="null" line="56" static="1">
			<f a="?x:?y:?width">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="echo.shape.Rect"/>
			</f>
			<haxe_doc>* Gets a `Rect` with uniform width/height from the Rect Classes' Object Pool. Shortcut for `Rect.get()`.
   * @param x The X position of the Rect
   * @param y The Y position of the Rect
   * @param width The width of the Rect
   * @return Rect</haxe_doc>
		</square>
		<circle public="1" get="inline" set="null" line="64" static="1">
			<f a="?x:?y:?radius:?scale_x:?scale_y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="echo.shape.Circle"/>
			</f>
			<haxe_doc>* Gets a `Circle` from the Circle Classes' Object Pool. Shortcut for `Circle.get()`.
   * @param x The X position of the Circle
   * @param y The Y position of the Circle
   * @param radius The radius of the Circle
   * @return Rect</haxe_doc>
		</circle>
		<get_defaults set="method" line="294" static="1"><f a=""><t path="echo.data.ShapeOptions"/></f></get_defaults>
		<type public="1">
			<x path="echo.data.ShapeType"/>
			<haxe_doc>* Enum value determining what shape this Object is (Rect, Circle, Polygon).</haxe_doc>
		</type>
		<x public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc>* The Shape's position on the X axis. For Rects, Circles, and simple Polygons, this position is based on the center of the Shape.
   *
   * If added to a `Body`, this value is relative to the Body's X position. To get the Shape's local X position in this case, use `local_x`.</haxe_doc>
		</x>
		<y public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc>* The Shape's position on the Y axis. For Rects, Circles, and simple Polygons, this position is based on the center of the Shape.
   *
   * If added to a `Body`, this value is relative to the Body's Y position. To get the Shape's local Y position in this case, use `local_y`.</haxe_doc>
		</y>
		<rotation public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc>* The Shape's angular rotation.
   *
   * If added to a `Body`, this value is relative to the Body's rotation. To get the Shape's local rotation in this case, use `local_rotation`.</haxe_doc>
		</rotation>
		<scale_x public="1" get="accessor" set="accessor"><x path="Float"/></scale_x>
		<scale_y public="1" get="accessor" set="accessor"><x path="Float"/></scale_y>
		<local_x public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc>* The Shape's position on the X axis. For Rects, Circles, and simple Polygons, this position is based on the center of the Shape.
   *
   * If added to a `Body`, this value is treated as an offset to the Body's X position.</haxe_doc>
		</local_x>
		<local_y public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc>* The Shape's position on the Y axis. For Rects, Circles, and simple Polygons, this position is based on the center of the Shape.
   *
   * If added to a `Body`, this value is treated as an offset to the Body's Y position.</haxe_doc>
		</local_y>
		<local_rotation public="1" get="accessor" set="accessor"><x path="Float"/></local_rotation>
		<local_scale_x public="1" get="accessor" set="accessor"><x path="Float"/></local_scale_x>
		<local_scale_y public="1" get="accessor" set="accessor"><x path="Float"/></local_scale_y>
		<transform public="1" expr="new Transform()">
			<c path="echo.util.Transform"/>
			<meta><m n=":value"><e>new Transform()</e></m></meta>
		</transform>
		<solid public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Flag to set whether the Shape collides with other Shapes.
   *
   * If false, this Shape's Body will not have its position or velocity affected by other Bodies, but it will still call collision callbacks</haxe_doc>
		</solid>
		<top public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>* The Upper Bounds of the Shape.</haxe_doc>
		</top>
		<bottom public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>* The Lower Bounds of the Shape.</haxe_doc>
		</bottom>
		<left public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>* The Left Bounds of the Shape.</haxe_doc>
		</left>
		<right public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>* The Right Bounds of the Shape.</haxe_doc>
		</right>
		<collided public="1">
			<x path="Bool"/>
			<haxe_doc>* Flag to determine if the Shape has collided in the last `World` step. Used Internally for Debugging.</haxe_doc>
		</collided>
		<parent set="null"><c path="echo.Body"/></parent>
		<put public="1" set="method" line="150"><f a=""><x path="Void"/></f></put>
		<get_position public="1" get="inline" set="null" line="158">
			<f a=""><x path="echo.math.Vector2"/></f>
			<haxe_doc>* Gets the Shape's position on the X and Y axis as a `Vector2`.</haxe_doc>
		</get_position>
		<get_local_position public="1" get="inline" set="null" line="160"><f a=""><x path="echo.math.Vector2"/></f></get_local_position>
		<set_position public="1" get="inline" set="null" line="162"><f a="position">
	<x path="echo.math.Vector2"/>
	<x path="Void"/>
</f></set_position>
		<set_local_position public="1" get="inline" set="null" line="166"><f a="position">
	<x path="echo.math.Vector2"/>
	<x path="Void"/>
</f></set_local_position>
		<set_parent public="1" set="method" line="170"><f a="?body">
	<c path="echo.Body"/>
	<x path="Void"/>
</f></set_parent>
		<bounds public="1" set="method" line="180">
			<f a="?aabb">
				<c path="echo.util.AABB"/>
				<c path="echo.util.AABB"/>
			</f>
			<haxe_doc>* Returns an `AABB` representing the bounds of the `Shape`.
   * @param aabb Optional `AABB` to set the values to.
   * @return AABB</haxe_doc>
		</bounds>
		<volume public="1" set="method" line="182"><f a=""><x path="Float"/></f></volume>
		<clone public="1" set="method" line="187">
			<f a=""><c path="echo.Shape"/></f>
			<haxe_doc>* Clones the Shape into a new Shape
   * @return Shape return new Shape(x, y)</haxe_doc>
		</clone>
		<scale public="1" set="method" line="193">
			<f a="v">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":dox"><e>hide</e></m>
				<m n=":noCompletion"/>
			</meta>
			<haxe_doc>* TODO</haxe_doc>
		</scale>
		<contains public="1" set="method" line="195"><f a="v">
	<x path="echo.math.Vector2"/>
	<x path="Bool"/>
</f></contains>
		<closest_point_on_edge public="1" set="method" line="201">
			<f a="v">
				<x path="echo.math.Vector2"/>
				<x path="echo.math.Vector2"/>
			</f>
			<meta>
				<m n=":dox"><e>hide</e></m>
				<m n=":noCompletion"/>
			</meta>
			<haxe_doc>* TODO</haxe_doc>
		</closest_point_on_edge>
		<intersect public="1" set="method" line="203"><f a="l">
	<c path="echo.Line"/>
	<x path="Null"><c path="echo.data.IntersectionData"/></x>
</f></intersect>
		<overlaps public="1" set="method" line="205"><f a="s">
	<c path="echo.Shape"/>
	<x path="Bool"/>
</f></overlaps>
		<collides public="1" set="method" line="207"><f a="s">
	<c path="echo.Shape"/>
	<x path="Null"><c path="echo.data.CollisionData"/></x>
</f></collides>
		<collide_rect set="method" line="209"><f a="r">
	<c path="echo.shape.Rect"/>
	<x path="Null"><c path="echo.data.CollisionData"/></x>
</f></collide_rect>
		<collide_circle set="method" line="211"><f a="c">
	<c path="echo.shape.Circle"/>
	<x path="Null"><c path="echo.data.CollisionData"/></x>
</f></collide_circle>
		<collide_polygon set="method" line="213"><f a="p">
	<c path="echo.shape.Polygon"/>
	<x path="Null"><c path="echo.data.CollisionData"/></x>
</f></collide_polygon>
		<toString set="method" line="215"><f a=""><c path="String"/></f></toString>
		<get_x get="inline" set="null" line="225"><f a=""><x path="Float"/></f></get_x>
		<get_y get="inline" set="null" line="227"><f a=""><x path="Float"/></f></get_y>
		<get_rotation get="inline" set="null" line="229"><f a=""><x path="Float"/></f></get_rotation>
		<get_scale_x get="inline" set="null" line="231"><f a=""><x path="Float"/></f></get_scale_x>
		<get_scale_y get="inline" set="null" line="233"><f a=""><x path="Float"/></f></get_scale_y>
		<get_local_x get="inline" set="null" line="235"><f a=""><x path="Float"/></f></get_local_x>
		<get_local_y get="inline" set="null" line="237"><f a=""><x path="Float"/></f></get_local_y>
		<get_local_rotation get="inline" set="null" line="239"><f a=""><x path="Float"/></f></get_local_rotation>
		<get_local_scale_x get="inline" set="null" line="241"><f a=""><x path="Float"/></f></get_local_scale_x>
		<get_local_scale_y get="inline" set="null" line="243"><f a=""><x path="Float"/></f></get_local_scale_y>
		<get_top set="method" line="245"><f a=""><x path="Float"/></f></get_top>
		<get_bottom set="method" line="247"><f a=""><x path="Float"/></f></get_bottom>
		<get_left set="method" line="249"><f a=""><x path="Float"/></f></get_left>
		<get_right set="method" line="251"><f a=""><x path="Float"/></f></get_right>
		<set_x get="inline" set="null" line="254"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_x>
		<set_y get="inline" set="null" line="258"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_y>
		<set_rotation get="inline" set="null" line="262"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_rotation>
		<set_scale_x get="inline" set="null" line="266"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_scale_x>
		<set_scale_y get="inline" set="null" line="270"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_scale_y>
		<set_local_x get="inline" set="null" line="274"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_local_x>
		<set_local_y get="inline" set="null" line="278"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_local_y>
		<set_local_rotation get="inline" set="null" line="282"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_local_rotation>
		<set_local_scale_x get="inline" set="null" line="286"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_local_scale_x>
		<set_local_scale_y get="inline" set="null" line="290"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_local_scale_y>
		<new get="inline" set="null" line="144">
			<f a="?x:?y:?rotation" v="0:0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ rotation : 0, y : 0, x : 0 }</e></m></meta>
			<haxe_doc>* Creates a new Shape
   * @param x
   * @param y</haxe_doc>
		</new>
		<haxe_doc>* Base Shape Class. Acts as a Body's collider. Check out `echo.shapes` for all available shapes.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="echo.World" params="" file="/home/runner/work/echo/echo/echo/World.hx">
		<implements path="echo.util.Disposable"/>
		<width public="1" set="accessor">
			<x path="Float"/>
			<haxe_doc>* Width of the World, extending right from the World's X position.</haxe_doc>
		</width>
		<height public="1" set="accessor">
			<x path="Float"/>
			<haxe_doc>* Height of the World, extending down from the World's Y position.</haxe_doc>
		</height>
		<x public="1" set="accessor">
			<x path="Float"/>
			<haxe_doc>* The World's position on the X axis.</haxe_doc>
		</x>
		<y public="1" set="accessor">
			<x path="Float"/>
			<haxe_doc>* The World's position on the Y axis.</haxe_doc>
		</y>
		<gravity public="1" set="null">
			<x path="echo.math.Vector2"/>
			<haxe_doc>* The amount of acceleration applied to each `Body` member every Step.</haxe_doc>
		</gravity>
		<quadtree public="1">
			<c path="echo.util.QuadTree"/>
			<haxe_doc>* The World's QuadTree for dynamic Bodies. Generally doesn't need to be touched.</haxe_doc>
		</quadtree>
		<static_quadtree public="1">
			<c path="echo.util.QuadTree"/>
			<haxe_doc>* The World's QuadTree for static Bodies. Generally doesn't need to be touched.</haxe_doc>
		</static_quadtree>
		<listeners public="1"><c path="echo.Listeners"/></listeners>
		<members public="1"><c path="Array"><c path="echo.Body"/></c></members>
		<count public="1" get="accessor" set="null"><x path="Int"/></count>
		<iterations public="1">
			<x path="Int"/>
			<haxe_doc>* The amount of iterations that occur each time the World is stepped. The higher the number, the more stable the Physics Simulation will be, at the cost of performance.</haxe_doc>
		</iterations>
		<history public="1"><x path="Null"><c path="echo.util.History_Array_echo_data_BodyState"/></x></history>
		<accumulatedTime public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</accumulatedTime>
		<init><x path="Bool"/></init>
		<set public="1" get="inline" set="null" line="80">
			<f a="x:y:width:height">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets the size of the World. Only Bodies within the world bound will be collided
   * @param x The x position of the world bounds
   * @param y The y position of the world bounds
   * @param width The width of the world bounds
   * @param height The height of the world bounds</haxe_doc>
		</set>
		<set_from_shape public="1" get="inline" set="null" line="93">
			<f a="s">
				<c path="echo.Shape"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets the size of the World based on a given shape.
   * @param s The shape to use as the boundaries of the World</haxe_doc>
		</set_from_shape>
		<set_from_members public="1" set="method" line="102">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Sets the size of the World based just large enough to encompass all the members.</haxe_doc>
		</set_from_members>
		<center public="1" get="inline" set="null" line="120"><f a="?rect">
	<c path="echo.shape.Rect"/>
	<c path="echo.shape.Rect"/>
</f></center>
		<add public="1" set="method" line="124"><f a="body">
	<c path="echo.Body"/>
	<c path="echo.Body"/>
</f></add>
		<remove public="1" set="method" line="135"><f a="body">
	<c path="echo.Body"/>
	<c path="echo.Body"/>
</f></remove>
		<iterator public="1" get="inline" set="null" line="143"><f a=""><t path="Iterator"><c path="echo.Body"/></t></f></iterator>
		<dynamics public="1" get="inline" set="null" line="147">
			<f a=""><c path="Array"><c path="echo.Body"/></c></f>
			<haxe_doc>* Returns a new Array containing every dynamic `Body` in the World.</haxe_doc>
		</dynamics>
		<statics public="1" get="inline" set="null" line="151">
			<f a=""><c path="Array"><c path="echo.Body"/></c></f>
			<haxe_doc>* Returns a new Array containing every static `Body` in the World.</haxe_doc>
		</statics>
		<for_each public="1" get="inline" set="null" line="157">
			<f a="f:?recursive" v=":true">
				<f a="">
					<c path="echo.Body"/>
					<x path="Void"/>
				</f>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ recursive : true }</e></m></meta>
			<haxe_doc>* Runs a function on every `Body` in the World
   * @param f Function to perform on each `Body`.
   * @param recursive Currently not supported.</haxe_doc>
		</for_each>
		<for_each_dynamic public="1" get="inline" set="null" line="163">
			<f a="f:?recursive" v=":true">
				<f a="">
					<c path="echo.Body"/>
					<x path="Void"/>
				</f>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ recursive : true }</e></m></meta>
			<haxe_doc>* Runs a function on every dynamic `Body` in the World
   * @param f Function to perform on each dynamic `Body`.
   * @param recursive Currently not supported.</haxe_doc>
		</for_each_dynamic>
		<for_each_static public="1" get="inline" set="null" line="169">
			<f a="f:?recursive" v=":true">
				<f a="">
					<c path="echo.Body"/>
					<x path="Void"/>
				</f>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ recursive : true }</e></m></meta>
			<haxe_doc>* Runs a function on every static `Body` in the World
   * @param f Function to perform on each static `Body`.
   * @param recursive Currently not supported.</haxe_doc>
		</for_each_static>
		<clear public="1" set="method" line="173">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clears the World's members and listeners.</haxe_doc>
		</clear>
		<dispose public="1" set="method" line="184">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Disposes the World. DO NOT use the World after disposing it, as it could lead to null reference errors.</haxe_doc>
		</dispose>
		<reset_quadtrees public="1" set="method" line="196">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Resets the World's dynamic and static Quadtrees.</haxe_doc>
		</reset_quadtrees>
		<get_count get="inline" set="null" line="216"><f a=""><x path="Int"/></f></get_count>
		<set_x get="inline" set="null" line="218"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_x>
		<set_y get="inline" set="null" line="224"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_y>
		<set_width get="inline" set="null" line="230"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_width>
		<set_height get="inline" set="null" line="236"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_height>
		<new public="1" set="method" line="59"><f a="options">
	<t path="echo.data.WorldOptions"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* A `World` is an Object representing the state of a Physics simulation and it configurations.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":using"><e>echo.Echo</e></m>
		</meta>
	</class>
	<class path="echo.data.BodyState" params="" file="/home/runner/work/echo/echo/echo/data/Data.hx" module="echo.data.Data">
		<id final="1" public="1"><x path="Int"/></id>
		<x final="1" public="1"><x path="Float"/></x>
		<y final="1" public="1"><x path="Float"/></y>
		<rotation final="1" public="1"><x path="Float"/></rotation>
		<velocity_x final="1" public="1"><x path="Float"/></velocity_x>
		<velocity_y final="1" public="1"><x path="Float"/></velocity_y>
		<acceleration_x final="1" public="1"><x path="Float"/></acceleration_x>
		<acceleration_y final="1" public="1"><x path="Float"/></acceleration_y>
		<rotational_velocity final="1" public="1"><x path="Float"/></rotational_velocity>
		<new public="1" set="method" line="21"><f a="id:x:y:rotation:velocity_x:velocity_y:acceleration_x:acceleration_y:rotational_velocity">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="echo.data.Collision" params="" file="/home/runner/work/echo/echo/echo/data/Data.hx" module="echo.data.Data">
		<implements path="echo.util.Poolable"/>
		<get public="1" get="inline" set="null" line="50" static="1"><f a="a:b">
	<c path="echo.Body"/>
	<c path="echo.Body"/>
	<c path="echo.data.Collision"/>
</f></get>
		<pool expr="new echo.util.Poolable.GenericPool&lt;echo.data.Data.Collision&gt;(echo.data.Collision)" line="89" static="1">
			<c path="echo.util.GenericPool_echo_data_Collision"/>
			<meta><m n=":value"><e><![CDATA[new echo.util.Poolable.GenericPool<echo.data.Data.Collision>(echo.data.Collision)]]></e></m></meta>
		</pool>
		<get_pool public="1" set="method" line="97" static="1"><f a=""><c path="echo.util.Pool"><c path="echo.data.Collision"/></c></f></get_pool>
		<a public="1">
			<c path="echo.Body"/>
			<haxe_doc>* Body A.</haxe_doc>
		</a>
		<b public="1">
			<c path="echo.Body"/>
			<haxe_doc>* Body B.</haxe_doc>
		</b>
		<data final="1" public="1" expr="[]">
			<c path="Array"><c path="echo.data.CollisionData"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
			<haxe_doc>* Array containing Data from Each Collision found between the two Bodies' Shapes.</haxe_doc>
		</data>
		<put public="1" set="method" line="59"><f a=""><x path="Void"/></f></put>
		<pooled public="1" set="null" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</pooled>
		<new get="inline" set="null" line="67"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* Class containing data describing any Collisions between two Bodies.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>echo.util.PoolableMacros.build()</e></m>
			<m n=":autoBuild"><e>echo.util.PoolableMacros.build()</e></m>
		</meta>
	</class>
	<class path="echo.data.CollisionData" params="" file="/home/runner/work/echo/echo/echo/data/Data.hx" module="echo.data.Data">
		<implements path="echo.util.Poolable"/>
		<get public="1" get="inline" set="null" line="94" static="1"><f a="overlap:x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="echo.data.CollisionData"/>
</f></get>
		<pool expr="new echo.util.Poolable.GenericPool&lt;echo.data.Data.CollisionData&gt;(echo.data.CollisionData)" line="89" static="1">
			<c path="echo.util.GenericPool_echo_data_CollisionData"/>
			<meta><m n=":value"><e><![CDATA[new echo.util.Poolable.GenericPool<echo.data.Data.CollisionData>(echo.data.CollisionData)]]></e></m></meta>
		</pool>
		<get_pool public="1" set="method" line="97" static="1"><f a=""><c path="echo.util.Pool"><c path="echo.data.CollisionData"/></c></f></get_pool>
		<sa public="1">
			<x path="Null"><c path="echo.Shape"/></x>
			<haxe_doc>* Shape A.</haxe_doc>
		</sa>
		<sb public="1">
			<x path="Null"><c path="echo.Shape"/></x>
			<haxe_doc>* Shape B.</haxe_doc>
		</sb>
		<overlap public="1" expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
			<haxe_doc>* The length of Shape A's penetration into Shape B.</haxe_doc>
		</overlap>
		<contact_count public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</contact_count>
		<contacts final="1" public="1" expr="Vector.fromArrayCopy([Vector2.zero, Vector2.zero])">
			<x path="haxe.ds.Vector"><x path="echo.math.Vector2"/></x>
			<meta><m n=":value"><e>Vector.fromArrayCopy([Vector2.zero, Vector2.zero])</e></m></meta>
		</contacts>
		<normal final="1" public="1" expr="Vector2.zero">
			<x path="echo.math.Vector2"/>
			<meta><m n=":value"><e>Vector2.zero</e></m></meta>
			<haxe_doc>* The normal vector (direction) of Shape A's penetration into Shape B.</haxe_doc>
		</normal>
		<set public="1" get="inline" set="null" line="107"><f a="overlap:x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></set>
		<put public="1" set="method" line="112"><f a=""><x path="Void"/></f></put>
		<pooled public="1" set="null" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</pooled>
		<new get="inline" set="null" line="105"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* Class containing data describing a Collision between two Shapes.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>echo.util.PoolableMacros.build()</e></m>
			<m n=":autoBuild"><e>echo.util.PoolableMacros.build()</e></m>
		</meta>
	</class>
	<class path="echo.data.Intersection" params="" file="/home/runner/work/echo/echo/echo/data/Data.hx" module="echo.data.Data">
		<implements path="echo.util.Poolable"/>
		<get public="1" get="inline" set="null" line="140" static="1"><f a="line:body">
	<c path="echo.Line"/>
	<c path="echo.Body"/>
	<c path="echo.data.Intersection"/>
</f></get>
		<pool expr="new echo.util.Poolable.GenericPool&lt;echo.data.Data.Intersection&gt;(echo.data.Intersection)" line="89" static="1">
			<c path="echo.util.GenericPool_echo_data_Intersection"/>
			<meta><m n=":value"><e><![CDATA[new echo.util.Poolable.GenericPool<echo.data.Data.Intersection>(echo.data.Intersection)]]></e></m></meta>
		</pool>
		<get_pool public="1" set="method" line="97" static="1"><f a=""><c path="echo.util.Pool"><c path="echo.data.Intersection"/></c></f></get_pool>
		<line public="1">
			<x path="Null"><c path="echo.Line"/></x>
			<haxe_doc>* Line.</haxe_doc>
		</line>
		<body public="1">
			<x path="Null"><c path="echo.Body"/></x>
			<haxe_doc>* Body.</haxe_doc>
		</body>
		<data final="1" public="1" expr="[]">
			<c path="Array"><c path="echo.data.IntersectionData"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
			<haxe_doc>* Array containing Data from Each Intersection found between the Line and each Shape in the Body.</haxe_doc>
		</data>
		<closest public="1" get="accessor" set="null">
			<x path="Null"><c path="echo.data.IntersectionData"/></x>
			<haxe_doc>* Gets the IntersectionData that has the closest hit distance from the beginning of the Line.</haxe_doc>
		</closest>
		<put public="1" set="method" line="149"><f a=""><x path="Void"/></f></put>
		<get_closest get="inline" set="null" line="159"><f a=""><x path="Null"><c path="echo.data.IntersectionData"/></x></f></get_closest>
		<pooled public="1" set="null" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</pooled>
		<new get="inline" set="null" line="157"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* Class containing data describing any Intersections between a Line and a Body.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>echo.util.PoolableMacros.build()</e></m>
			<m n=":autoBuild"><e>echo.util.PoolableMacros.build()</e></m>
		</meta>
	</class>
	<class path="echo.data.IntersectionData" params="" file="/home/runner/work/echo/echo/echo/data/Data.hx" module="echo.data.Data">
		<implements path="echo.util.Poolable"/>
		<get public="1" get="inline" set="null" line="200" static="1">
			<f a="distance:overlap:x:y:normal_x:normal_y:?inverse_normal" v="::::::false">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<c path="echo.data.IntersectionData"/>
			</f>
			<meta><m n=":value"><e>{ inverse_normal : false }</e></m></meta>
		</get>
		<pool expr="new echo.util.Poolable.GenericPool&lt;echo.data.Data.IntersectionData&gt;(echo.data.IntersectionData)" line="89" static="1">
			<c path="echo.util.GenericPool_echo_data_IntersectionData"/>
			<meta><m n=":value"><e><![CDATA[new echo.util.Poolable.GenericPool<echo.data.Data.IntersectionData>(echo.data.IntersectionData)]]></e></m></meta>
		</pool>
		<get_pool public="1" set="method" line="97" static="1"><f a=""><c path="echo.util.Pool"><c path="echo.data.IntersectionData"/></c></f></get_pool>
		<line public="1"><x path="Null"><c path="echo.Line"/></x></line>
		<shape public="1"><x path="Null"><c path="echo.Shape"/></x></shape>
		<line2 public="1">
			<x path="Null"><c path="echo.Line"/></x>
			<haxe_doc>* The second Line in the Intersection. This is only set when intersecting two Lines.</haxe_doc>
		</line2>
		<hit final="1" public="1" expr="Vector2.zero">
			<x path="echo.math.Vector2"/>
			<meta><m n=":value"><e>Vector2.zero</e></m></meta>
			<haxe_doc>* The position along the line where the line hit the shape.</haxe_doc>
		</hit>
		<distance public="1" expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
			<haxe_doc>* The distance between the start of the line and the hit position.</haxe_doc>
		</distance>
		<overlap public="1" expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
			<haxe_doc>* The length of the line that has overlapped the shape.</haxe_doc>
		</overlap>
		<normal final="1" public="1" expr="Vector2.zero">
			<x path="echo.math.Vector2"/>
			<meta><m n=":value"><e>Vector2.zero</e></m></meta>
			<haxe_doc>* The normal vector (direction) of the Line's penetration into the Shape.</haxe_doc>
		</normal>
		<inverse_normal public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>Indicates if normal was inversed and usually occurs when Line penetrates into the Shape from the inside.</haxe_doc>
		</inverse_normal>
		<set public="1" get="inline" set="null" line="215">
			<f a="distance:overlap:x:y:normal_x:normal_y:?inverse_normal" v="::::::false">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ inverse_normal : false }</e></m></meta>
		</set>
		<put public="1" set="method" line="223"><f a=""><x path="Void"/></f></put>
		<pooled public="1" set="null" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</pooled>
		<new get="inline" set="null" line="210"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* Class containing data describing an Intersection between a Line and a Shape.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>echo.util.PoolableMacros.build()</e></m>
			<m n=":autoBuild"><e>echo.util.PoolableMacros.build()</e></m>
		</meta>
	</class>
	<class path="echo.data.QuadTreeData" params="" file="/home/runner/work/echo/echo/echo/data/Data.hx" module="echo.data.Data">
		<id public="1">
			<x path="Int"/>
			<haxe_doc>* Id of the Data.</haxe_doc>
		</id>
		<bounds public="1" expr="null">
			<x path="Null"><c path="echo.util.AABB"/></x>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* Bounds of the Data.</haxe_doc>
		</bounds>
		<flag public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Helper flag to check if this Data has been counted during queries.</haxe_doc>
		</flag>
		<new public="1" set="method" line="232">
			<f a="id:?bounds:?flag">
				<x path="Int"/>
				<x path="Null"><x path="Null"><c path="echo.util.AABB"/></x></x>
				<x path="Null"><x path="Bool"/></x>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":compilerGenerated"/>
				<m n=":inheritDoc"/>
			</meta>
			<haxe_doc>@param flag * Helper flag to check if this Data has been counted during queries.
@param bounds * Bounds of the Data.
@param id * Id of the Data.</haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":structInit"/>
		</meta>
	</class>
	<abstract path="echo.data.Direction" params="" file="/home/runner/work/echo/echo/echo/data/Data.hx" module="echo.data.Data">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to><icast><x path="Int"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="echo.data._Data.Direction_Impl_" params="" file="/home/runner/work/echo/echo/echo/data/Data.hx" private="1" module="echo.data.Data" extern="1" final="1">
	<TOP public="1" get="inline" set="null" expr="cast 0" line="249" static="1">
		<x path="echo.data.Direction"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</TOP>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="echo.data._Data.Direction_Impl_" params="" file="/home/runner/work/echo/echo/echo/data/Data.hx" private="1" module="echo.data.Data" extern="1" final="1">
		<TOP public="1" get="inline" set="null" expr="cast 0" line="249" static="1">
			<x path="echo.data.Direction"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</TOP>
		<meta><m n=":enum"/></meta>
	</class>
	<typedef path="echo.data.BodyOptions" params="" file="/home/runner/work/echo/echo/echo/data/Options.hx" module="echo.data.Options"><a>
	<y>
		<x path="Null"><x path="Float"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>* The Body's position on the Y axis.</haxe_doc>
	</y>
	<x>
		<x path="Null"><x path="Float"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>* The Body's position on the X axis.</haxe_doc>
	</x>
	<velocity_y>
		<x path="Null"><x path="Float"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>* The units/second that a `Body` moves on the Y axis.</haxe_doc>
	</velocity_y>
	<velocity_x>
		<x path="Null"><x path="Float"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>* The units/second that a `Body` moves on the X axis.</haxe_doc>
	</velocity_x>
	<shapes>
		<x path="Null"><c path="Array"><t path="echo.data.ShapeOptions"/></c></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>* Defines an array of Shapes that the Body will use as colliders</haxe_doc>
	</shapes>
	<shape_instances>
		<x path="Null"><c path="Array"><c path="echo.Shape"/></c></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>* An array of Shape instances that the Body will use as colliders</haxe_doc>
	</shape_instances>
	<shape_instance>
		<x path="Null"><c path="echo.Shape"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>* A Shape instance that the Body will use as a collider</haxe_doc>
	</shape_instance>
	<shape>
		<x path="Null"><t path="echo.data.ShapeOptions"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>* Defines a Shape that the Body will use as a collider</haxe_doc>
	</shape>
	<scale_y>
		<x path="Null"><x path="Float"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>* The Body's scale on the Y axis.</haxe_doc>
	</scale_y>
	<scale_x>
		<x path="Null"><x path="Float"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>* The Body's scale on the X axis.</haxe_doc>
	</scale_x>
	<rotational_velocity>
		<x path="Null"><x path="Float"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>* The units/second that a `Body` will rotate. Currently is not Implemented.</haxe_doc>
	</rotational_velocity>
	<rotational_drag>
		<x path="Null"><x path="Float"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>* A measure of how fast a Body will move its `rotational_velocity` towards 0.</haxe_doc>
	</rotational_drag>
	<rotation>
		<x path="Null"><x path="Float"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>* The Body's rotation.</haxe_doc>
	</rotation>
	<max_velocity_y>
		<x path="Null"><x path="Float"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>* The maximum velocity range that a `Body` can have on the Y axis. If set to 0, the Body has no restrictions on how fast it can move.
   *
   * Note: this is calculated separately from a Body's `max_velocity_length`, so be careful when applying both.</haxe_doc>
	</max_velocity_y>
	<max_velocity_x>
		<x path="Null"><x path="Float"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>* The maximum velocity range that a `Body` can have on the X axis. If set to 0, the Body has no restrictions on how fast it can move.
   *
   * Note: this is calculated separately from a Body's `max_velocity_length`, so be careful when applying both.</haxe_doc>
	</max_velocity_x>
	<max_velocity_length>
		<x path="Null"><x path="Float"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>* The maximum velocity that a `Body` can have along the velocity's length. If set to 0, the Body has no restrictions on how fast it can move.
   *
   * Note: this is calculated separately from a Body's `max_velocity_x` or 'max_velocity_y', so be careful when applying both.</haxe_doc>
	</max_velocity_length>
	<max_rotational_velocity>
		<x path="Null"><x path="Float"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>* The maximum rotational velocity range that a `Body` can have.
   *
   * If set to 0, the Body has no restrictions on how fast it can rotate.</haxe_doc>
	</max_rotational_velocity>
	<material>
		<x path="Null"><c path="echo.Material"/></x>
		<meta><m n=":optional"/></meta>
	</material>
	<mass>
		<x path="Null"><x path="echo.data.MassType"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>* The Body's mass. Affects how the Body reacts to Collisions and Acceleration Forces. The higher a Body's mass, the more resistant it is to those forces.
   * 
   * Can be set to a `Float` value, `AUTO`, or `STATIC` (`mass = 5`, `mass = AUTO`, and `mass = STATIC` are all valid).
   * 
   * If set to `AUTO`, the Body will automatically calculate it's mass based on it's volume and material's `density`.
   * If a Body's mass is set to `STATIC` or `0`, it becomes static - unmovable by forces and collisions.
   * 
   * If this value is left `null`, it will automatically be set to the same value as `Body.default_mass`.</haxe_doc>
	</mass>
	<kinematic>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>* Flag to set how a Body is affected by Collisions.
   *
   * If set to true, the Body will still Collide and move through the world, but it will not be moved by external collision forces.
   * This is useful for things like moving platforms.</haxe_doc>
	</kinematic>
	<gravity_scale>
		<x path="Null"><x path="Float"/></x>
		<meta>
			<m n=":optional"/>
			<m n=":deprecated"><e>"Gravity Value has been moved into the Material object. Set `material.gravity_scale instead."</e></m>
		</meta>
		<haxe_doc>* Percentage value that represents how much a World's gravity affects the Body.</haxe_doc>
	</gravity_scale>
	<elasticity>
		<x path="Null"><x path="Float"/></x>
		<meta>
			<m n=":optional"/>
			<m n=":deprecated"><e>"Elasticity Value has been moved into the Material object. Set `material.elasticity instead."</e></m>
		</meta>
		<haxe_doc>* Value to determine how much of a Body's `velocity` should be retained during collisions (or how much should the `Body` "bounce" in other words).</haxe_doc>
	</elasticity>
	<drag_y>
		<x path="Null"><x path="Float"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>* A measure of how fast a Body will move its velocity towards 0 on the Y axis when there is no acceleration.
   *
   * Note: this is calculated separately from a Body's `drag_length`, so be careful when applying both.</haxe_doc>
	</drag_y>
	<drag_x>
		<x path="Null"><x path="Float"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>* A measure of how fast a Body will move its velocity towards 0 on the X axis when there is no acceleration.
   *
   * Note: this is calculated separately from a Body's `drag_length`, so be careful when applying both.</haxe_doc>
	</drag_x>
	<drag_length>
		<x path="Null"><x path="Float"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>* A measure of how fast a Body will move its velocity towards 0 along the velocity's length, when there is no acceleration.
   *
   * Note: this is calculated separately from a Body's `drag`, so be careful when applying both.</haxe_doc>
	</drag_length>
</a></typedef>
	<typedef path="echo.data.WorldOptions" params="" file="/home/runner/work/echo/echo/echo/data/Options.hx" module="echo.data.Options"><a>
	<y>
		<x path="Null"><x path="Float"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>* The World's position on the Y axis.</haxe_doc>
	</y>
	<x>
		<x path="Null"><x path="Float"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>* The World's position on the X axis.</haxe_doc>
	</x>
	<width>
		<x path="Float"/>
		<haxe_doc>* Width of the World, extending right from the World's X position.</haxe_doc>
	</width>
	<members>
		<x path="Null"><c path="Array"><c path="echo.Body"/></c></x>
		<meta><m n=":optional"/></meta>
	</members>
	<listeners>
		<x path="Null"><c path="Array"><c path="echo.Listener"/></c></x>
		<meta><m n=":optional"/></meta>
	</listeners>
	<iterations>
		<x path="Null"><x path="Int"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>* The amount of iterations that occur each time the World is stepped. The higher the number, the more stable the Physics Simulation will be, at the cost of performance.</haxe_doc>
	</iterations>
	<history>
		<x path="Null"><x path="Int"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>* The number of states to preserve in the World's history.</haxe_doc>
	</history>
	<height>
		<x path="Float"/>
		<haxe_doc>* Height of the World, extending down from the World's Y position.</haxe_doc>
	</height>
	<gravity_y>
		<x path="Null"><x path="Float"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>* The amount of acceleration on the Y axis applied to each `Body` member every Step.</haxe_doc>
	</gravity_y>
	<gravity_x>
		<x path="Null"><x path="Float"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>* The amount of acceleration on the X axis applied to each `Body` member every Step.</haxe_doc>
	</gravity_x>
</a></typedef>
	<typedef path="echo.data.ListenerOptions" params="" file="/home/runner/work/echo/echo/echo/data/Options.hx" module="echo.data.Options"><a>
	<stay>
		<x path="Null"><f a="::">
	<c path="echo.Body"/>
	<c path="echo.Body"/>
	<c path="Array"><c path="echo.data.CollisionData"/></c>
	<x path="Void"/>
</f></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>* A callback function that is called on frames when two Bodies are continuing to collide.</haxe_doc>
	</stay>
	<separate>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>* Flag that determines if Collisions found by this listener should separate the Bodies. Defaults to `true`.</haxe_doc>
	</separate>
	<percent_correction>
		<x path="Null"><x path="Float"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>* Percentage of correction along the collision normal to be applied to seperating bodies. Helps prevent objects sinking into each other.</haxe_doc>
	</percent_correction>
	<exit>
		<x path="Null"><f a=":">
	<c path="echo.Body"/>
	<c path="echo.Body"/>
	<x path="Void"/>
</f></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>* A callback function that is called when a collision between two Bodies ends.</haxe_doc>
	</exit>
	<enter>
		<x path="Null"><f a="::">
	<c path="echo.Body"/>
	<c path="echo.Body"/>
	<c path="Array"><c path="echo.data.CollisionData"/></c>
	<x path="Void"/>
</f></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>* A callback function that is called on the first frame that a collision starts.</haxe_doc>
	</enter>
	<correction_threshold>
		<x path="Null"><x path="Float"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>* Threshold determining how close two separating bodies must be before position correction occurs. Helps reduce jitter.</haxe_doc>
	</correction_threshold>
	<condition>
		<x path="Null"><f a="::">
	<c path="echo.Body"/>
	<c path="echo.Body"/>
	<c path="Array"><c path="echo.data.CollisionData"/></c>
	<x path="Bool"/>
</f></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>* A callback function that allows extra logic to be run on a potential collision.
   *
   * If it returns true, the collision is valid. Otherwise the collision is discarded and no physics resolution/collision callbacks occur.</haxe_doc>
	</condition>
</a></typedef>
	<typedef path="echo.data.LinecastOptions" params="" file="/home/runner/work/echo/echo/echo/data/Options.hx" module="echo.data.Options"><a><filter>
	<x path="Null"><f a=":">
	<c path="echo.Line"/>
	<c path="echo.Body"/>
	<x path="Bool"/>
</f></x>
	<meta><m n=":optional"/></meta>
	<haxe_doc>* A callback function that allows extra logic to be run before a potential linecast.
   *
   * If it returns false, the linecast will not occur.</haxe_doc>
</filter></a></typedef>
	<typedef path="echo.data.ShapeOptions" params="" file="/home/runner/work/echo/echo/echo/data/Options.hx" module="echo.data.Options"><a>
	<width>
		<x path="Null"><x path="Float"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>* If the Shape is a Rect, it's width will be taken from this value. Otherwise this is ignored.
   *
   * If this value is set and height isnt, the Rect will use this value for it's height.</haxe_doc>
	</width>
	<vertices>
		<x path="Null"><c path="Array"><x path="echo.math.Vector2"/></c></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>* If the Shape is a Polygon, this will create one in the shape of the vectors passed in. Otherwise this is ignored.</haxe_doc>
	</vertices>
	<type>
		<x path="Null"><x path="echo.data.ShapeType"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>* Enum describing the Shape to create. Currently supports RECT and CIRCLE.</haxe_doc>
	</type>
	<solid>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
	</solid>
	<sides>
		<x path="Null"><x path="Int"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>* If the Shape is a Polygon, this will determine how many faces the Polygon will generate. Otherwise this is ignored.
   *
   * If `vertices` is set, this will be overriden.</haxe_doc>
	</sides>
	<scale_y>
		<x path="Null"><x path="Float"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>* The Shape's scale on the Y axis.</haxe_doc>
	</scale_y>
	<scale_x>
		<x path="Null"><x path="Float"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>* The Shape's scale on the X axis.</haxe_doc>
	</scale_x>
	<rotation>
		<x path="Null"><x path="Float"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>* The Shape's rotation.</haxe_doc>
	</rotation>
	<radius>
		<x path="Null"><x path="Float"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>* If the Shape is a Circle or Polygon, it's radius will be taken from this value. Otherwise this is ignored.
   *
   * For Polygon's, this value is ignored if `vertices` is set.</haxe_doc>
	</radius>
	<offset_y>
		<x path="Null"><x path="Float"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>* The Shape's offset from it's parent Body on the Y-Axis.</haxe_doc>
	</offset_y>
	<offset_x>
		<x path="Null"><x path="Float"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>* The Shape's offset from it's parent Body on the X-Axis.</haxe_doc>
	</offset_x>
	<height>
		<x path="Null"><x path="Float"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>* If the Shape is a Rect, it's height will be taken from this value. Otherwise this is ignored.
   *
   * If this value isnt set and width isnt, the Rect will use its width value for it's height.</haxe_doc>
	</height>
</a></typedef>
	<typedef path="echo.data.VerletOptions" params="" file="/home/runner/work/echo/echo/echo/data/Options.hx" module="echo.data.Options"><a>
	<y>
		<x path="Null"><x path="Float"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>* The Verlet World's position on the Y axis.</haxe_doc>
	</y>
	<x>
		<x path="Null"><x path="Float"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>* The Verlet World's position on the X axis.</haxe_doc>
	</x>
	<width>
		<x path="Float"/>
		<haxe_doc>* Width of the Verlet World, extending right from the World's X position.</haxe_doc>
	</width>
	<iterations>
		<x path="Null"><x path="Int"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>* The amount of iterations that occur each time the World is stepped. The higher the number, the more stable the Physics Simulation will be, at the cost of performance. 
   * 
   * Default value is `5`.</haxe_doc>
	</iterations>
	<height>
		<x path="Float"/>
		<haxe_doc>* Height of the Verlet World, extending down from the World's Y position.</haxe_doc>
	</height>
	<gravity_y>
		<x path="Null"><x path="Float"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>* The amount of acceleration on the Y axis applied to each `Dot` every Step.</haxe_doc>
	</gravity_y>
	<gravity_x>
		<x path="Null"><x path="Float"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>* The amount of acceleration on the X axis applied to each `Dot` every Step.</haxe_doc>
	</gravity_x>
	<fixed_framerate>
		<x path="Null"><x path="Float"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>* The fixed Step rate of the Verlet World. The Verlet simulation must be stepped forward at a consistent rate, or it's stability will quickly deteriorate.
   * 
   * Default value is `60`.</haxe_doc>
	</fixed_framerate>
	<drag>
		<x path="Null"><x path="Float"/></x>
		<meta><m n=":optional"/></meta>
		<haxe_doc>*  Default value is `0.98`.</haxe_doc>
	</drag>
</a></typedef>
	<typedef path="echo.data.RectOptions" params="" file="/home/runner/work/echo/echo/echo/data/Options.hx" module="echo.data.Options"><a>
	<y><x path="Float"/></y>
	<x><x path="Float"/></x>
	<width><x path="Float"/></width>
	<height><x path="Float"/></height>
</a></typedef>
	<typedef path="echo.data.CircleOptions" params="" file="/home/runner/work/echo/echo/echo/data/Options.hx" module="echo.data.Options"><a>
	<y><x path="Float"/></y>
	<x><x path="Float"/></x>
	<radius><x path="Float"/></radius>
</a></typedef>
	<typedef path="echo.data.PolygonOptions" params="" file="/home/runner/work/echo/echo/echo/data/Options.hx" module="echo.data.Options"><a>
	<y><x path="Float"/></y>
	<x><x path="Float"/></x>
	<vertices><c path="Array"><x path="echo.math.Vector2"/></c></vertices>
	<rotation><x path="Float"/></rotation>
</a></typedef>
	<typedef path="echo.data.RayOptions" params="" file="/home/runner/work/echo/echo/echo/data/Options.hx" module="echo.data.Options"><a>
	<y><x path="Float"/></y>
	<x><x path="Float"/></x>
	<dy><x path="Float"/></dy>
	<dx><x path="Float"/></dx>
</a></typedef>
	<abstract path="echo.data.MassType" params="" file="/home/runner/work/echo/echo/echo/data/Types.hx" module="echo.data.Types">
		<from><icast><x path="Float"/></icast></from>
		<this><x path="Float"/></this>
		<to><icast><x path="Float"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="echo.data._Types.MassType_Impl_" params="" file="/home/runner/work/echo/echo/echo/data/Types.hx" private="1" module="echo.data.Types" extern="1" final="1">
	<AUTO public="1" get="inline" set="null" expr="cast -1" line="4" static="1">
		<x path="echo.data.MassType"/>
		<meta>
			<m n=":value"><e>cast -1</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</AUTO>
	<STATIC public="1" get="inline" set="null" expr="cast 0" line="5" static="1">
		<x path="echo.data.MassType"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</STATIC>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="echo.data._Types.MassType_Impl_" params="" file="/home/runner/work/echo/echo/echo/data/Types.hx" private="1" module="echo.data.Types" extern="1" final="1">
		<AUTO public="1" get="inline" set="null" expr="cast -1" line="4" static="1">
			<x path="echo.data.MassType"/>
			<meta>
				<m n=":value"><e>cast -1</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</AUTO>
		<STATIC public="1" get="inline" set="null" expr="cast 0" line="5" static="1">
			<x path="echo.data.MassType"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</STATIC>
		<meta><m n=":enum"/></meta>
	</class>
	<abstract path="echo.data.ShapeType" params="" file="/home/runner/work/echo/echo/echo/data/Types.hx" module="echo.data.Types">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to><icast><x path="Int"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="echo.data._Types.ShapeType_Impl_" params="" file="/home/runner/work/echo/echo/echo/data/Types.hx" private="1" module="echo.data.Types" extern="1" final="1">
	<RECT public="1" get="inline" set="null" expr="cast 0" line="1" static="1">
		<x path="echo.data.ShapeType"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</RECT>
	<CIRCLE public="1" get="inline" set="null" expr="cast 1" line="1" static="1">
		<x path="echo.data.ShapeType"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</CIRCLE>
	<POLYGON public="1" get="inline" set="null" expr="cast 2" line="1" static="1">
		<x path="echo.data.ShapeType"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</POLYGON>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="echo.data._Types.ShapeType_Impl_" params="" file="/home/runner/work/echo/echo/echo/data/Types.hx" private="1" module="echo.data.Types" extern="1" final="1">
		<RECT public="1" get="inline" set="null" expr="cast 0" line="1" static="1">
			<x path="echo.data.ShapeType"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</RECT>
		<CIRCLE public="1" get="inline" set="null" expr="cast 1" line="1" static="1">
			<x path="echo.data.ShapeType"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</CIRCLE>
		<POLYGON public="1" get="inline" set="null" expr="cast 2" line="1" static="1">
			<x path="echo.data.ShapeType"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</POLYGON>
		<meta><m n=":enum"/></meta>
	</class>
	<abstract path="echo.data.ForceType" params="" file="/home/runner/work/echo/echo/echo/data/Types.hx" module="echo.data.Types">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to><icast><x path="Int"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="echo.data._Types.ForceType_Impl_" params="" file="/home/runner/work/echo/echo/echo/data/Types.hx" private="1" module="echo.data.Types" extern="1" final="1">
	<ACCELERATION public="1" get="inline" set="null" expr="cast 0" line="1" static="1">
		<x path="echo.data.ForceType"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</ACCELERATION>
	<VELOCITY public="1" get="inline" set="null" expr="cast 1" line="1" static="1">
		<x path="echo.data.ForceType"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</VELOCITY>
	<POSITION public="1" get="inline" set="null" expr="cast 2" line="1" static="1">
		<x path="echo.data.ForceType"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</POSITION>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="echo.data._Types.ForceType_Impl_" params="" file="/home/runner/work/echo/echo/echo/data/Types.hx" private="1" module="echo.data.Types" extern="1" final="1">
		<ACCELERATION public="1" get="inline" set="null" expr="cast 0" line="1" static="1">
			<x path="echo.data.ForceType"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</ACCELERATION>
		<VELOCITY public="1" get="inline" set="null" expr="cast 1" line="1" static="1">
			<x path="echo.data.ForceType"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</VELOCITY>
		<POSITION public="1" get="inline" set="null" expr="cast 2" line="1" static="1">
			<x path="echo.data.ForceType"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</POSITION>
		<meta><m n=":enum"/></meta>
	</class>
	<class path="echo.math.Matrix2Default" params="" file="/home/runner/work/echo/echo/echo/math/Matrix2.hx" module="echo.math.Matrix2">
		<m00 public="1"><x path="Float"/></m00>
		<m01 public="1"><x path="Float"/></m01>
		<m10 public="1"><x path="Float"/></m10>
		<m11 public="1"><x path="Float"/></m11>
		<toString public="1" set="method" line="25"><f a=""><c path="String"/></f></toString>
		<new public="1" get="inline" set="null" line="18">
			<f a="m00:m10:m01:m11">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Column-Major Orientation.
   * /m00, m10/
   * /m01, m11/</haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":noCompletion"/>
		</meta>
	</class>
	<abstract path="echo.math.Matrix2" params="" file="/home/runner/work/echo/echo/echo/math/Matrix2.hx">
		<from>
			<icast><t path="echo.math.Matrix2Type"/></icast>
			<icast field="from_arr"><c path="Array"><x path="Float"/></c></icast>
		</from>
		<this><t path="echo.math.Matrix2Type"/></this>
		<to>
			<icast><t path="echo.math.Matrix2Type"/></icast>
			<icast field="to_arr"><c path="Array"><x path="Float"/></c></icast>
		</to>
		<haxe_doc>* Column-Major Orientation.
 * /m00, m10/
 * /m01, m11/</haxe_doc>
		<meta>
			<m n=":using"><e>echo.math.Matrix2</e></m>
			<m n=":forward">
				<e>m00</e>
				<e>m10</e>
				<e>m01</e>
				<e>m11</e>
			</m>
		</meta>
		<impl><class path="echo.math._Matrix2.Matrix2_Impl_" params="" file="/home/runner/work/echo/echo/echo/math/Matrix2.hx" private="1" module="echo.math.Matrix2" final="1">
	<element_count final="1" public="1" get="inline" set="null" expr="4" line="37" static="1">
		<x path="Int"/>
		<meta><m n=":value"><e>4</e></m></meta>
	</element_count>
	<zero public="1" get="accessor" set="null" static="1"><x path="echo.math.Matrix2"/></zero>
	<identity public="1" get="accessor" set="null" static="1"><x path="echo.math.Matrix2"/></identity>
	<col_x public="1" get="accessor" set="accessor" static="1"><x path="echo.math.Vector2"/></col_x>
	<col_y public="1" get="accessor" set="accessor" static="1"><x path="echo.math.Vector2"/></col_y>
	<from_radians public="1" get="inline" set="null" line="49" static="1">
		<f a="radians">
			<x path="Float"/>
			<x path="echo.math.Matrix2"/>
		</f>
		<haxe_doc>* Gets a rotation matrix from the given radians.</haxe_doc>
	</from_radians>
	<from_vectors public="1" get="inline" set="null" line="55" static="1"><f a="x:y">
	<x path="echo.math.Vector2"/>
	<x path="echo.math.Vector2"/>
	<x path="echo.math.Matrix2"/>
</f></from_vectors>
	<from_arr public="1" get="inline" set="null" line="58" static="1">
		<f a="a">
			<c path="Array"><x path="Float"/></c>
			<x path="echo.math.Matrix2"/>
		</f>
		<meta><m n=":from"/></meta>
	</from_arr>
	<to_arr public="1" get="inline" set="null" line="61" static="1">
		<f a="this">
			<t path="echo.math.Matrix2Type"/>
			<c path="Array"><x path="Float"/></c>
		</f>
		<meta><m n=":to"/></meta>
	</to_arr>
	<_new public="1" get="inline" set="null" line="66" static="1">
		<f a="m00:m10:m01:m11">
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="echo.math.Matrix2"/>
		</f>
		<meta><m n=":noCompletion"/></meta>
	</_new>
	<arr_read public="1" get="inline" set="null" line="73" static="1">
		<f a="this:i">
			<t path="echo.math.Matrix2Type"/>
			<x path="Int"/>
			<x path="Float"/>
		</f>
		<meta><m n=":op"><e>[]</e></m></meta>
	</arr_read>
	<arr_write public="1" get="inline" set="null" line="91" static="1">
		<f a="this:i:value">
			<t path="echo.math.Matrix2Type"/>
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":op"><e>[]</e></m></meta>
	</arr_write>
	<mul get="inline" set="null" line="110" static="1">
		<f a="a:b">
			<x path="echo.math.Matrix2"/>
			<x path="echo.math.Matrix2"/>
			<x path="echo.math.Matrix2"/>
		</f>
		<meta><m n=":op"><e>a * b</e></m></meta>
	</mul>
	<mul_vec2 get="inline" set="null" line="118" static="1">
		<f a="a:v">
			<x path="echo.math.Matrix2"/>
			<x path="echo.math.Vector2"/>
			<x path="echo.math.Vector2"/>
		</f>
		<meta><m n=":op"><e>a * b</e></m></meta>
	</mul_vec2>
	<get_zero get="inline" set="null" line="122" static="1"><f a=""><x path="echo.math.Matrix2"/></f></get_zero>
	<get_identity get="inline" set="null" line="126" static="1"><f a=""><x path="echo.math.Matrix2"/></f></get_identity>
	<get_col_x get="inline" set="null" line="130" static="1"><f a="this">
	<t path="echo.math.Matrix2Type"/>
	<x path="echo.math.Vector2"/>
</f></get_col_x>
	<get_col_y get="inline" set="null" line="135" static="1"><f a="this">
	<t path="echo.math.Matrix2Type"/>
	<x path="echo.math.Vector2"/>
</f></get_col_y>
	<set_col_x get="inline" set="null" line="140" static="1"><f a="this:vector2">
	<t path="echo.math.Matrix2Type"/>
	<x path="echo.math.Vector2"/>
	<x path="echo.math.Vector2"/>
</f></set_col_x>
	<set_col_y get="inline" set="null" line="145" static="1"><f a="this:vector2">
	<t path="echo.math.Matrix2Type"/>
	<x path="echo.math.Vector2"/>
	<x path="echo.math.Vector2"/>
</f></set_col_y>
	<meta><m n=":using"><e>echo.math.Matrix2</e></m></meta>
</class></impl>
	</abstract>
	<class path="echo.math._Matrix2.Matrix2_Impl_" params="" file="/home/runner/work/echo/echo/echo/math/Matrix2.hx" private="1" module="echo.math.Matrix2" final="1">
		<element_count final="1" public="1" get="inline" set="null" expr="4" line="37" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</element_count>
		<zero public="1" get="accessor" set="null" static="1"><x path="echo.math.Matrix2"/></zero>
		<identity public="1" get="accessor" set="null" static="1"><x path="echo.math.Matrix2"/></identity>
		<col_x public="1" get="accessor" set="accessor" static="1"><x path="echo.math.Vector2"/></col_x>
		<col_y public="1" get="accessor" set="accessor" static="1"><x path="echo.math.Vector2"/></col_y>
		<from_radians public="1" get="inline" set="null" line="49" static="1">
			<f a="radians">
				<x path="Float"/>
				<x path="echo.math.Matrix2"/>
			</f>
			<haxe_doc>* Gets a rotation matrix from the given radians.</haxe_doc>
		</from_radians>
		<from_vectors public="1" get="inline" set="null" line="55" static="1"><f a="x:y">
	<x path="echo.math.Vector2"/>
	<x path="echo.math.Vector2"/>
	<x path="echo.math.Matrix2"/>
</f></from_vectors>
		<from_arr public="1" get="inline" set="null" line="58" static="1">
			<f a="a">
				<c path="Array"><x path="Float"/></c>
				<x path="echo.math.Matrix2"/>
			</f>
			<meta><m n=":from"/></meta>
		</from_arr>
		<to_arr public="1" get="inline" set="null" line="61" static="1">
			<f a="this">
				<t path="echo.math.Matrix2Type"/>
				<c path="Array"><x path="Float"/></c>
			</f>
			<meta><m n=":to"/></meta>
		</to_arr>
		<_new public="1" get="inline" set="null" line="66" static="1">
			<f a="m00:m10:m01:m11">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="echo.math.Matrix2"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</_new>
		<arr_read public="1" get="inline" set="null" line="73" static="1">
			<f a="this:i">
				<t path="echo.math.Matrix2Type"/>
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":op"><e>[]</e></m></meta>
		</arr_read>
		<arr_write public="1" get="inline" set="null" line="91" static="1">
			<f a="this:i:value">
				<t path="echo.math.Matrix2Type"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":op"><e>[]</e></m></meta>
		</arr_write>
		<mul get="inline" set="null" line="110" static="1">
			<f a="a:b">
				<x path="echo.math.Matrix2"/>
				<x path="echo.math.Matrix2"/>
				<x path="echo.math.Matrix2"/>
			</f>
			<meta><m n=":op"><e>a * b</e></m></meta>
		</mul>
		<mul_vec2 get="inline" set="null" line="118" static="1">
			<f a="a:v">
				<x path="echo.math.Matrix2"/>
				<x path="echo.math.Vector2"/>
				<x path="echo.math.Vector2"/>
			</f>
			<meta><m n=":op"><e>a * b</e></m></meta>
		</mul_vec2>
		<get_zero get="inline" set="null" line="122" static="1"><f a=""><x path="echo.math.Matrix2"/></f></get_zero>
		<get_identity get="inline" set="null" line="126" static="1"><f a=""><x path="echo.math.Matrix2"/></f></get_identity>
		<get_col_x get="inline" set="null" line="130" static="1"><f a="this">
	<t path="echo.math.Matrix2Type"/>
	<x path="echo.math.Vector2"/>
</f></get_col_x>
		<get_col_y get="inline" set="null" line="135" static="1"><f a="this">
	<t path="echo.math.Matrix2Type"/>
	<x path="echo.math.Vector2"/>
</f></get_col_y>
		<set_col_x get="inline" set="null" line="140" static="1"><f a="this:vector2">
	<t path="echo.math.Matrix2Type"/>
	<x path="echo.math.Vector2"/>
	<x path="echo.math.Vector2"/>
</f></set_col_x>
		<set_col_y get="inline" set="null" line="145" static="1"><f a="this:vector2">
	<t path="echo.math.Matrix2Type"/>
	<x path="echo.math.Vector2"/>
	<x path="echo.math.Vector2"/>
</f></set_col_y>
		<meta><m n=":using"><e>echo.math.Matrix2</e></m></meta>
	</class>
	<class path="echo.math._Matrix2.Matrix2_Fields_" params="" file="/home/runner/work/echo/echo/echo/math/Matrix2.hx" private="1" module="echo.math.Matrix2" final="1">
		<copy_to public="1" get="inline" set="null" line="151" static="1"><f a="a:b">
	<x path="echo.math.Matrix2"/>
	<x path="echo.math.Matrix2"/>
	<x path="echo.math.Matrix2"/>
</f></copy_to>
		<copy_from public="1" get="inline" set="null" line="156" static="1"><f a="a:b">
	<x path="echo.math.Matrix2"/>
	<x path="echo.math.Matrix2"/>
	<x path="echo.math.Matrix2"/>
</f></copy_from>
		<transposed public="1" get="inline" set="null" line="164" static="1"><f a="m">
	<x path="echo.math.Matrix2"/>
	<x path="echo.math.Matrix2"/>
</f></transposed>
	</class>
	<class path="echo.math.Matrix3Default" params="" file="/home/runner/work/echo/echo/echo/math/Matrix3.hx" module="echo.math.Matrix3">
		<m00 public="1"><x path="Float"/></m00>
		<m01 public="1"><x path="Float"/></m01>
		<m02 public="1"><x path="Float"/></m02>
		<m10 public="1"><x path="Float"/></m10>
		<m11 public="1"><x path="Float"/></m11>
		<m12 public="1"><x path="Float"/></m12>
		<m20 public="1"><x path="Float"/></m20>
		<m21 public="1"><x path="Float"/></m21>
		<m22 public="1"><x path="Float"/></m22>
		<toString public="1" set="method" line="39"><f a=""><c path="String"/></f></toString>
		<new public="1" get="inline" set="null" line="25">
			<f a="m00:m10:m20:m01:m11:m21:m02:m12:m22">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Column-Major Orientation.
   * /m00, m10, m20/
   * /m01, m11, m21/
   * /m02, m12, m22/</haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":noCompletion"/>
		</meta>
	</class>
	<abstract path="echo.math.Matrix3" params="" file="/home/runner/work/echo/echo/echo/math/Matrix3.hx">
		<from>
			<icast><t path="echo.math.Matrix3Type"/></icast>
			<icast field="from_arr"><c path="Array"><x path="Float"/></c></icast>
		</from>
		<this><t path="echo.math.Matrix3Type"/></this>
		<to>
			<icast><t path="echo.math.Matrix3Type"/></icast>
			<icast field="to_arr"><c path="Array"><x path="Float"/></c></icast>
		</to>
		<haxe_doc>* Column-Major Orientation.
 * /m00, m10, m20/
 * /m01, m11, m21/
 * /m02, m12, m22/</haxe_doc>
		<meta>
			<m n=":using"><e>echo.math.Matrix3</e></m>
			<m n=":forward">
				<e>m00</e>
				<e>m10</e>
				<e>m20</e>
				<e>m01</e>
				<e>m11</e>
				<e>m21</e>
				<e>m02</e>
				<e>m12</e>
				<e>m22</e>
			</m>
		</meta>
		<impl><class path="echo.math._Matrix3.Matrix3_Impl_" params="" file="/home/runner/work/echo/echo/echo/math/Matrix3.hx" private="1" module="echo.math.Matrix3" final="1">
	<element_count final="1" public="1" get="inline" set="null" expr="9" line="52" static="1">
		<x path="Int"/>
		<meta><m n=":value"><e>9</e></m></meta>
	</element_count>
	<zero public="1" get="accessor" set="null" static="1"><x path="echo.math.Matrix3"/></zero>
	<identity public="1" get="accessor" set="null" static="1"><x path="echo.math.Matrix3"/></identity>
	<from_arr public="1" get="inline" set="null" line="59" static="1">
		<f a="a">
			<c path="Array"><x path="Float"/></c>
			<x path="echo.math.Matrix3"/>
		</f>
		<meta><m n=":from"/></meta>
	</from_arr>
	<to_arr public="1" get="inline" set="null" line="62" static="1">
		<f a="this">
			<t path="echo.math.Matrix3Type"/>
			<c path="Array"><x path="Float"/></c>
		</f>
		<meta><m n=":to"/></meta>
	</to_arr>
	<_new public="1" get="inline" set="null" line="77" static="1">
		<f a="m00:m10:m20:m01:m11:m21:m02:m12:m22">
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="echo.math.Matrix3"/>
		</f>
		<meta><m n=":noCompletion"/></meta>
	</_new>
	<arr_read public="1" get="inline" set="null" line="84" static="1">
		<f a="this:i">
			<t path="echo.math.Matrix3Type"/>
			<x path="Int"/>
			<x path="Float"/>
		</f>
		<meta><m n=":op"><e>[]</e></m></meta>
	</arr_read>
	<arr_write public="1" get="inline" set="null" line="112" static="1">
		<f a="this:i:value">
			<t path="echo.math.Matrix3Type"/>
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":op"><e>[]</e></m></meta>
	</arr_write>
	<mul get="inline" set="null" line="140" static="1">
		<f a="a:b">
			<x path="echo.math.Matrix3"/>
			<x path="echo.math.Matrix3"/>
			<x path="echo.math.Matrix3"/>
		</f>
		<meta><m n=":op"><e>a * b</e></m></meta>
	</mul>
	<mul_vec3 get="inline" set="null" line="168" static="1">
		<f a="a:v">
			<x path="echo.math.Matrix3"/>
			<x path="echo.math.Vector3"/>
			<x path="echo.math.Vector3"/>
		</f>
		<meta><m n=":op"><e>a * b</e></m></meta>
	</mul_vec3>
	<get_zero get="inline" set="null" line="180" static="1"><f a=""><x path="echo.math.Matrix3"/></f></get_zero>
	<get_identity get="inline" set="null" line="184" static="1"><f a=""><x path="echo.math.Matrix3"/></f></get_identity>
	<meta><m n=":using"><e>echo.math.Matrix3</e></m></meta>
</class></impl>
	</abstract>
	<class path="echo.math._Matrix3.Matrix3_Impl_" params="" file="/home/runner/work/echo/echo/echo/math/Matrix3.hx" private="1" module="echo.math.Matrix3" final="1">
		<element_count final="1" public="1" get="inline" set="null" expr="9" line="52" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>9</e></m></meta>
		</element_count>
		<zero public="1" get="accessor" set="null" static="1"><x path="echo.math.Matrix3"/></zero>
		<identity public="1" get="accessor" set="null" static="1"><x path="echo.math.Matrix3"/></identity>
		<from_arr public="1" get="inline" set="null" line="59" static="1">
			<f a="a">
				<c path="Array"><x path="Float"/></c>
				<x path="echo.math.Matrix3"/>
			</f>
			<meta><m n=":from"/></meta>
		</from_arr>
		<to_arr public="1" get="inline" set="null" line="62" static="1">
			<f a="this">
				<t path="echo.math.Matrix3Type"/>
				<c path="Array"><x path="Float"/></c>
			</f>
			<meta><m n=":to"/></meta>
		</to_arr>
		<_new public="1" get="inline" set="null" line="77" static="1">
			<f a="m00:m10:m20:m01:m11:m21:m02:m12:m22">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="echo.math.Matrix3"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</_new>
		<arr_read public="1" get="inline" set="null" line="84" static="1">
			<f a="this:i">
				<t path="echo.math.Matrix3Type"/>
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":op"><e>[]</e></m></meta>
		</arr_read>
		<arr_write public="1" get="inline" set="null" line="112" static="1">
			<f a="this:i:value">
				<t path="echo.math.Matrix3Type"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":op"><e>[]</e></m></meta>
		</arr_write>
		<mul get="inline" set="null" line="140" static="1">
			<f a="a:b">
				<x path="echo.math.Matrix3"/>
				<x path="echo.math.Matrix3"/>
				<x path="echo.math.Matrix3"/>
			</f>
			<meta><m n=":op"><e>a * b</e></m></meta>
		</mul>
		<mul_vec3 get="inline" set="null" line="168" static="1">
			<f a="a:v">
				<x path="echo.math.Matrix3"/>
				<x path="echo.math.Vector3"/>
				<x path="echo.math.Vector3"/>
			</f>
			<meta><m n=":op"><e>a * b</e></m></meta>
		</mul_vec3>
		<get_zero get="inline" set="null" line="180" static="1"><f a=""><x path="echo.math.Matrix3"/></f></get_zero>
		<get_identity get="inline" set="null" line="184" static="1"><f a=""><x path="echo.math.Matrix3"/></f></get_identity>
		<meta><m n=":using"><e>echo.math.Matrix3</e></m></meta>
	</class>
	<class path="echo.math._Matrix3.Matrix3_Fields_" params="" file="/home/runner/work/echo/echo/echo/math/Matrix3.hx" private="1" module="echo.math.Matrix3" final="1">
		<copy_to public="1" get="inline" set="null" line="189" static="1"><f a="a:b">
	<x path="echo.math.Matrix3"/>
	<x path="echo.math.Matrix3"/>
	<x path="echo.math.Matrix3"/>
</f></copy_to>
		<copy_from public="1" get="inline" set="null" line="194" static="1"><f a="a:b">
	<x path="echo.math.Matrix3"/>
	<x path="echo.math.Matrix3"/>
	<x path="echo.math.Matrix3"/>
</f></copy_from>
	</class>
	<typedef path="echo.math.Vector2Type" params="" file="/home/runner/work/echo/echo/echo/math/Types.hx" module="echo.math.Types"><c path="echo.math.Vector2Default"/></typedef>
	<typedef path="echo.math.Vector3Type" params="" file="/home/runner/work/echo/echo/echo/math/Types.hx" module="echo.math.Types"><c path="echo.math.Vector3Default"/></typedef>
	<typedef path="echo.math.Matrix2Type" params="" file="/home/runner/work/echo/echo/echo/math/Types.hx" module="echo.math.Types"><c path="echo.math.Matrix2Default"/></typedef>
	<typedef path="echo.math.Matrix3Type" params="" file="/home/runner/work/echo/echo/echo/math/Types.hx" module="echo.math.Types"><c path="echo.math.Matrix3Default"/></typedef>
	<class path="echo.math.Vector2Default" params="" file="/home/runner/work/echo/echo/echo/math/Vector2.hx" module="echo.math.Vector2">
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<toString public="1" set="method" line="20"><f a=""><c path="String"/></f></toString>
		<new public="1" get="inline" set="null" line="13"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":noCompletion"/>
		</meta>
	</class>
	<abstract path="echo.math.Vector2" params="" file="/home/runner/work/echo/echo/echo/math/Vector2.hx">
		<from>
			<icast><t path="echo.math.Vector2Type"/></icast>
			<icast field="from_arr"><c path="Array"><x path="Float"/></c></icast>
		</from>
		<this><t path="echo.math.Vector2Type"/></this>
		<to>
			<icast><t path="echo.math.Vector2Type"/></icast>
			<icast field="to_arr"><c path="Array"><x path="Float"/></c></icast>
		</to>
		<meta>
			<m n=":using"><e>echo.math.Vector2</e></m>
			<m n=":forward">
				<e>x</e>
				<e>y</e>
			</m>
		</meta>
		<impl><class path="echo.math._Vector2.Vector2_Impl_" params="" file="/home/runner/work/echo/echo/echo/math/Vector2.hx" private="1" module="echo.math.Vector2" final="1">
	<zero public="1" get="accessor" set="null" static="1"><x path="echo.math.Vector2"/></zero>
	<up public="1" get="accessor" set="null" static="1">
		<x path="echo.math.Vector2"/>
		<haxe_doc>* Returns { x: 0.0, y: 1.0 };</haxe_doc>
	</up>
	<down public="1" get="accessor" set="null" static="1">
		<x path="echo.math.Vector2"/>
		<haxe_doc>* Returns { x: 0.0, y: -1.0 };</haxe_doc>
	</down>
	<right public="1" get="accessor" set="null" static="1">
		<x path="echo.math.Vector2"/>
		<haxe_doc>* Returns { x: 1.0, y: 0.0 };</haxe_doc>
	</right>
	<left public="1" get="accessor" set="null" static="1">
		<x path="echo.math.Vector2"/>
		<haxe_doc>* Returns { x: -1.0, y: 0.0 };</haxe_doc>
	</left>
	<length public="1" get="accessor" set="accessor" static="1"><x path="Float"/></length>
	<length_sq public="1" get="accessor" set="null" static="1"><x path="Float"/></length_sq>
	<radians public="1" get="accessor" set="accessor" static="1"><x path="Float"/></radians>
	<normal public="1" get="accessor" set="null" static="1"><x path="echo.math.Vector2"/></normal>
	<from_radians public="1" get="inline" set="null" line="53" static="1"><f a="radians:radius">
	<x path="Float"/>
	<x path="Float"/>
	<x path="echo.math.Vector2"/>
</f></from_radians>
	<from_arr public="1" get="inline" set="null" line="57" static="1">
		<f a="a">
			<c path="Array"><x path="Float"/></c>
			<x path="echo.math.Vector2"/>
		</f>
		<meta><m n=":from"/></meta>
	</from_arr>
	<to_arr public="1" get="inline" set="null" line="60" static="1">
		<f a="this">
			<t path="echo.math.Vector2Type"/>
			<c path="Array"><x path="Float"/></c>
		</f>
		<meta><m n=":to"/></meta>
	</to_arr>
	<_new public="1" get="inline" set="null" line="65" static="1">
		<f a="x:y">
			<x path="Float"/>
			<x path="Float"/>
			<x path="echo.math.Vector2"/>
		</f>
		<meta><m n=":noCompletion"/></meta>
	</_new>
	<arr_read get="inline" set="null" line="70" static="1">
		<f a="this:i">
			<t path="echo.math.Vector2Type"/>
			<x path="Int"/>
			<x path="Float"/>
		</f>
		<meta><m n=":op"><e>[]</e></m></meta>
	</arr_read>
	<arr_write get="inline" set="null" line="80" static="1">
		<f a="this:i:v">
			<t path="echo.math.Vector2Type"/>
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":op"><e>[]</e></m></meta>
	</arr_write>
	<neg get="inline" set="null" line="91" static="1">
		<f a="a">
			<x path="echo.math.Vector2"/>
			<x path="echo.math.Vector2"/>
		</f>
		<meta><m n=":op"><e>-a</e></m></meta>
	</neg>
	<prefix_increment get="inline" set="null" line="94" static="1">
		<f a="a">
			<x path="echo.math.Vector2"/>
			<x path="echo.math.Vector2"/>
		</f>
		<meta><m n=":op"><e>++a</e></m></meta>
	</prefix_increment>
	<prefix_decrement get="inline" set="null" line="101" static="1">
		<f a="a">
			<x path="echo.math.Vector2"/>
			<x path="echo.math.Vector2"/>
		</f>
		<meta><m n=":op"><e>--a</e></m></meta>
	</prefix_decrement>
	<postfix_increment get="inline" set="null" line="108" static="1">
		<f a="a">
			<x path="echo.math.Vector2"/>
			<x path="echo.math.Vector2"/>
		</f>
		<meta><m n=":op"><e>a++</e></m></meta>
	</postfix_increment>
	<postfix_decrement get="inline" set="null" line="116" static="1">
		<f a="a">
			<x path="echo.math.Vector2"/>
			<x path="echo.math.Vector2"/>
		</f>
		<meta><m n=":op"><e>a--</e></m></meta>
	</postfix_decrement>
	<mul get="inline" set="null" line="125" static="1">
		<f a="a:b">
			<x path="echo.math.Vector2"/>
			<x path="echo.math.Vector2"/>
			<x path="echo.math.Vector2"/>
		</f>
		<meta><m n=":op"><e>a * b</e></m></meta>
	</mul>
	<mul_scalar get="inline" set="null" line="129" static="1">
		<f a="a:b">
			<x path="echo.math.Vector2"/>
			<x path="Float"/>
			<x path="echo.math.Vector2"/>
		</f>
		<meta>
			<m n=":op"><e>a * b</e></m>
			<m n=":commutative"/>
		</meta>
	</mul_scalar>
	<div get="inline" set="null" line="133" static="1">
		<f a="a:b">
			<x path="echo.math.Vector2"/>
			<x path="echo.math.Vector2"/>
			<x path="echo.math.Vector2"/>
		</f>
		<meta><m n=":op"><e>a / b</e></m></meta>
	</div>
	<div_scalar get="inline" set="null" line="137" static="1">
		<f a="a:b">
			<x path="echo.math.Vector2"/>
			<x path="Float"/>
			<x path="echo.math.Vector2"/>
		</f>
		<meta><m n=":op"><e>a / b</e></m></meta>
	</div_scalar>
	<div_scalar_inv get="inline" set="null" line="141" static="1">
		<f a="a:b">
			<x path="Float"/>
			<x path="echo.math.Vector2"/>
			<x path="echo.math.Vector2"/>
		</f>
		<meta><m n=":op"><e>a / b</e></m></meta>
	</div_scalar_inv>
	<add get="inline" set="null" line="145" static="1">
		<f a="a:b">
			<x path="echo.math.Vector2"/>
			<x path="echo.math.Vector2"/>
			<x path="echo.math.Vector2"/>
		</f>
		<meta><m n=":op"><e>a + b</e></m></meta>
	</add>
	<add_scalar get="inline" set="null" line="149" static="1">
		<f a="a:b">
			<x path="echo.math.Vector2"/>
			<x path="Float"/>
			<x path="echo.math.Vector2"/>
		</f>
		<meta>
			<m n=":op"><e>a + b</e></m>
			<m n=":commutative"/>
		</meta>
	</add_scalar>
	<sub get="inline" set="null" line="153" static="1">
		<f a="a:b">
			<x path="echo.math.Vector2"/>
			<x path="echo.math.Vector2"/>
			<x path="echo.math.Vector2"/>
		</f>
		<meta><m n=":op"><e>a - b</e></m></meta>
	</sub>
	<sub_scalar get="inline" set="null" line="157" static="1">
		<f a="a:b">
			<x path="echo.math.Vector2"/>
			<x path="Float"/>
			<x path="echo.math.Vector2"/>
		</f>
		<meta><m n=":op"><e>a - b</e></m></meta>
	</sub_scalar>
	<sub_scalar_inv get="inline" set="null" line="161" static="1">
		<f a="a:b">
			<x path="Float"/>
			<x path="echo.math.Vector2"/>
			<x path="echo.math.Vector2"/>
		</f>
		<meta><m n=":op"><e>b - a</e></m></meta>
	</sub_scalar_inv>
	<equal get="inline" set="null" line="165" static="1">
		<f a="a:b">
			<x path="echo.math.Vector2"/>
			<x path="echo.math.Vector2"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e>a == b</e></m></meta>
	</equal>
	<not_equal get="inline" set="null" line="169" static="1">
		<f a="a:b">
			<x path="echo.math.Vector2"/>
			<x path="echo.math.Vector2"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e>a != b</e></m></meta>
	</not_equal>
	<mul_eq get="inline" set="null" line="173" static="1">
		<f a="a:b">
			<x path="echo.math.Vector2"/>
			<x path="echo.math.Vector2"/>
			<x path="echo.math.Vector2"/>
		</f>
		<meta><m n=":op"><e>a *= b</e></m></meta>
	</mul_eq>
	<mul_eq_scalar get="inline" set="null" line="177" static="1">
		<f a="a:f">
			<x path="echo.math.Vector2"/>
			<x path="Float"/>
			<x path="echo.math.Vector2"/>
		</f>
		<meta><m n=":op"><e>a *= b</e></m></meta>
	</mul_eq_scalar>
	<div_eq get="inline" set="null" line="181" static="1">
		<f a="a:b">
			<x path="echo.math.Vector2"/>
			<x path="echo.math.Vector2"/>
			<x path="echo.math.Vector2"/>
		</f>
		<meta><m n=":op"><e>a /= b</e></m></meta>
	</div_eq>
	<div_eq_scalar get="inline" set="null" line="185" static="1">
		<f a="a:f">
			<x path="echo.math.Vector2"/>
			<x path="Float"/>
			<x path="echo.math.Vector2"/>
		</f>
		<meta><m n=":op"><e>a /= b</e></m></meta>
	</div_eq_scalar>
	<add_eq get="inline" set="null" line="189" static="1">
		<f a="a:b">
			<x path="echo.math.Vector2"/>
			<x path="echo.math.Vector2"/>
			<x path="echo.math.Vector2"/>
		</f>
		<meta><m n=":op"><e>a += b</e></m></meta>
	</add_eq>
	<add_eq_scalar get="inline" set="null" line="193" static="1">
		<f a="a:f">
			<x path="echo.math.Vector2"/>
			<x path="Float"/>
			<x path="echo.math.Vector2"/>
		</f>
		<meta><m n=":op"><e>a += b</e></m></meta>
	</add_eq_scalar>
	<sub_eq get="inline" set="null" line="197" static="1">
		<f a="a:b">
			<x path="echo.math.Vector2"/>
			<x path="echo.math.Vector2"/>
			<x path="echo.math.Vector2"/>
		</f>
		<meta><m n=":op"><e>a -= b</e></m></meta>
	</sub_eq>
	<sub_eq_scalar get="inline" set="null" line="201" static="1">
		<f a="a:f">
			<x path="echo.math.Vector2"/>
			<x path="Float"/>
			<x path="echo.math.Vector2"/>
		</f>
		<meta><m n=":op"><e>a -= b</e></m></meta>
	</sub_eq_scalar>
	<get_zero get="inline" set="null" line="207" static="1"><f a=""><x path="echo.math.Vector2"/></f></get_zero>
	<get_up get="inline" set="null" line="210" static="1"><f a=""><x path="echo.math.Vector2"/></f></get_up>
	<get_down get="inline" set="null" line="213" static="1"><f a=""><x path="echo.math.Vector2"/></f></get_down>
	<get_left get="inline" set="null" line="216" static="1"><f a=""><x path="echo.math.Vector2"/></f></get_left>
	<get_right get="inline" set="null" line="219" static="1"><f a=""><x path="echo.math.Vector2"/></f></get_right>
	<get_length get="inline" set="null" line="221" static="1"><f a="this">
	<t path="echo.math.Vector2Type"/>
	<x path="Float"/>
</f></get_length>
	<get_length_sq get="inline" set="null" line="226" static="1"><f a="this">
	<t path="echo.math.Vector2Type"/>
	<x path="Float"/>
</f></get_length_sq>
	<get_radians get="inline" set="null" line="231" static="1"><f a="this">
	<t path="echo.math.Vector2Type"/>
	<x path="Float"/>
</f></get_radians>
	<get_normal get="inline" set="null" line="236" static="1"><f a="this">
	<t path="echo.math.Vector2Type"/>
	<x path="echo.math.Vector2"/>
</f></get_normal>
	<set_length get="inline" set="null" line="246" static="1"><f a="this:f">
	<t path="echo.math.Vector2Type"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_length>
	<set_radians get="inline" set="null" line="252" static="1"><f a="this:radians">
	<t path="echo.math.Vector2Type"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_radians>
	<meta><m n=":using"><e>echo.math.Vector2</e></m></meta>
</class></impl>
	</abstract>
	<class path="echo.math._Vector2.Vector2_Impl_" params="" file="/home/runner/work/echo/echo/echo/math/Vector2.hx" private="1" module="echo.math.Vector2" final="1">
		<zero public="1" get="accessor" set="null" static="1"><x path="echo.math.Vector2"/></zero>
		<up public="1" get="accessor" set="null" static="1">
			<x path="echo.math.Vector2"/>
			<haxe_doc>* Returns { x: 0.0, y: 1.0 };</haxe_doc>
		</up>
		<down public="1" get="accessor" set="null" static="1">
			<x path="echo.math.Vector2"/>
			<haxe_doc>* Returns { x: 0.0, y: -1.0 };</haxe_doc>
		</down>
		<right public="1" get="accessor" set="null" static="1">
			<x path="echo.math.Vector2"/>
			<haxe_doc>* Returns { x: 1.0, y: 0.0 };</haxe_doc>
		</right>
		<left public="1" get="accessor" set="null" static="1">
			<x path="echo.math.Vector2"/>
			<haxe_doc>* Returns { x: -1.0, y: 0.0 };</haxe_doc>
		</left>
		<length public="1" get="accessor" set="accessor" static="1"><x path="Float"/></length>
		<length_sq public="1" get="accessor" set="null" static="1"><x path="Float"/></length_sq>
		<radians public="1" get="accessor" set="accessor" static="1"><x path="Float"/></radians>
		<normal public="1" get="accessor" set="null" static="1"><x path="echo.math.Vector2"/></normal>
		<from_radians public="1" get="inline" set="null" line="53" static="1"><f a="radians:radius">
	<x path="Float"/>
	<x path="Float"/>
	<x path="echo.math.Vector2"/>
</f></from_radians>
		<from_arr public="1" get="inline" set="null" line="57" static="1">
			<f a="a">
				<c path="Array"><x path="Float"/></c>
				<x path="echo.math.Vector2"/>
			</f>
			<meta><m n=":from"/></meta>
		</from_arr>
		<to_arr public="1" get="inline" set="null" line="60" static="1">
			<f a="this">
				<t path="echo.math.Vector2Type"/>
				<c path="Array"><x path="Float"/></c>
			</f>
			<meta><m n=":to"/></meta>
		</to_arr>
		<_new public="1" get="inline" set="null" line="65" static="1">
			<f a="x:y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="echo.math.Vector2"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</_new>
		<arr_read get="inline" set="null" line="70" static="1">
			<f a="this:i">
				<t path="echo.math.Vector2Type"/>
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":op"><e>[]</e></m></meta>
		</arr_read>
		<arr_write get="inline" set="null" line="80" static="1">
			<f a="this:i:v">
				<t path="echo.math.Vector2Type"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":op"><e>[]</e></m></meta>
		</arr_write>
		<neg get="inline" set="null" line="91" static="1">
			<f a="a">
				<x path="echo.math.Vector2"/>
				<x path="echo.math.Vector2"/>
			</f>
			<meta><m n=":op"><e>-a</e></m></meta>
		</neg>
		<prefix_increment get="inline" set="null" line="94" static="1">
			<f a="a">
				<x path="echo.math.Vector2"/>
				<x path="echo.math.Vector2"/>
			</f>
			<meta><m n=":op"><e>++a</e></m></meta>
		</prefix_increment>
		<prefix_decrement get="inline" set="null" line="101" static="1">
			<f a="a">
				<x path="echo.math.Vector2"/>
				<x path="echo.math.Vector2"/>
			</f>
			<meta><m n=":op"><e>--a</e></m></meta>
		</prefix_decrement>
		<postfix_increment get="inline" set="null" line="108" static="1">
			<f a="a">
				<x path="echo.math.Vector2"/>
				<x path="echo.math.Vector2"/>
			</f>
			<meta><m n=":op"><e>a++</e></m></meta>
		</postfix_increment>
		<postfix_decrement get="inline" set="null" line="116" static="1">
			<f a="a">
				<x path="echo.math.Vector2"/>
				<x path="echo.math.Vector2"/>
			</f>
			<meta><m n=":op"><e>a--</e></m></meta>
		</postfix_decrement>
		<mul get="inline" set="null" line="125" static="1">
			<f a="a:b">
				<x path="echo.math.Vector2"/>
				<x path="echo.math.Vector2"/>
				<x path="echo.math.Vector2"/>
			</f>
			<meta><m n=":op"><e>a * b</e></m></meta>
		</mul>
		<mul_scalar get="inline" set="null" line="129" static="1">
			<f a="a:b">
				<x path="echo.math.Vector2"/>
				<x path="Float"/>
				<x path="echo.math.Vector2"/>
			</f>
			<meta>
				<m n=":op"><e>a * b</e></m>
				<m n=":commutative"/>
			</meta>
		</mul_scalar>
		<div get="inline" set="null" line="133" static="1">
			<f a="a:b">
				<x path="echo.math.Vector2"/>
				<x path="echo.math.Vector2"/>
				<x path="echo.math.Vector2"/>
			</f>
			<meta><m n=":op"><e>a / b</e></m></meta>
		</div>
		<div_scalar get="inline" set="null" line="137" static="1">
			<f a="a:b">
				<x path="echo.math.Vector2"/>
				<x path="Float"/>
				<x path="echo.math.Vector2"/>
			</f>
			<meta><m n=":op"><e>a / b</e></m></meta>
		</div_scalar>
		<div_scalar_inv get="inline" set="null" line="141" static="1">
			<f a="a:b">
				<x path="Float"/>
				<x path="echo.math.Vector2"/>
				<x path="echo.math.Vector2"/>
			</f>
			<meta><m n=":op"><e>a / b</e></m></meta>
		</div_scalar_inv>
		<add get="inline" set="null" line="145" static="1">
			<f a="a:b">
				<x path="echo.math.Vector2"/>
				<x path="echo.math.Vector2"/>
				<x path="echo.math.Vector2"/>
			</f>
			<meta><m n=":op"><e>a + b</e></m></meta>
		</add>
		<add_scalar get="inline" set="null" line="149" static="1">
			<f a="a:b">
				<x path="echo.math.Vector2"/>
				<x path="Float"/>
				<x path="echo.math.Vector2"/>
			</f>
			<meta>
				<m n=":op"><e>a + b</e></m>
				<m n=":commutative"/>
			</meta>
		</add_scalar>
		<sub get="inline" set="null" line="153" static="1">
			<f a="a:b">
				<x path="echo.math.Vector2"/>
				<x path="echo.math.Vector2"/>
				<x path="echo.math.Vector2"/>
			</f>
			<meta><m n=":op"><e>a - b</e></m></meta>
		</sub>
		<sub_scalar get="inline" set="null" line="157" static="1">
			<f a="a:b">
				<x path="echo.math.Vector2"/>
				<x path="Float"/>
				<x path="echo.math.Vector2"/>
			</f>
			<meta><m n=":op"><e>a - b</e></m></meta>
		</sub_scalar>
		<sub_scalar_inv get="inline" set="null" line="161" static="1">
			<f a="a:b">
				<x path="Float"/>
				<x path="echo.math.Vector2"/>
				<x path="echo.math.Vector2"/>
			</f>
			<meta><m n=":op"><e>b - a</e></m></meta>
		</sub_scalar_inv>
		<equal get="inline" set="null" line="165" static="1">
			<f a="a:b">
				<x path="echo.math.Vector2"/>
				<x path="echo.math.Vector2"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e>a == b</e></m></meta>
		</equal>
		<not_equal get="inline" set="null" line="169" static="1">
			<f a="a:b">
				<x path="echo.math.Vector2"/>
				<x path="echo.math.Vector2"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e>a != b</e></m></meta>
		</not_equal>
		<mul_eq get="inline" set="null" line="173" static="1">
			<f a="a:b">
				<x path="echo.math.Vector2"/>
				<x path="echo.math.Vector2"/>
				<x path="echo.math.Vector2"/>
			</f>
			<meta><m n=":op"><e>a *= b</e></m></meta>
		</mul_eq>
		<mul_eq_scalar get="inline" set="null" line="177" static="1">
			<f a="a:f">
				<x path="echo.math.Vector2"/>
				<x path="Float"/>
				<x path="echo.math.Vector2"/>
			</f>
			<meta><m n=":op"><e>a *= b</e></m></meta>
		</mul_eq_scalar>
		<div_eq get="inline" set="null" line="181" static="1">
			<f a="a:b">
				<x path="echo.math.Vector2"/>
				<x path="echo.math.Vector2"/>
				<x path="echo.math.Vector2"/>
			</f>
			<meta><m n=":op"><e>a /= b</e></m></meta>
		</div_eq>
		<div_eq_scalar get="inline" set="null" line="185" static="1">
			<f a="a:f">
				<x path="echo.math.Vector2"/>
				<x path="Float"/>
				<x path="echo.math.Vector2"/>
			</f>
			<meta><m n=":op"><e>a /= b</e></m></meta>
		</div_eq_scalar>
		<add_eq get="inline" set="null" line="189" static="1">
			<f a="a:b">
				<x path="echo.math.Vector2"/>
				<x path="echo.math.Vector2"/>
				<x path="echo.math.Vector2"/>
			</f>
			<meta><m n=":op"><e>a += b</e></m></meta>
		</add_eq>
		<add_eq_scalar get="inline" set="null" line="193" static="1">
			<f a="a:f">
				<x path="echo.math.Vector2"/>
				<x path="Float"/>
				<x path="echo.math.Vector2"/>
			</f>
			<meta><m n=":op"><e>a += b</e></m></meta>
		</add_eq_scalar>
		<sub_eq get="inline" set="null" line="197" static="1">
			<f a="a:b">
				<x path="echo.math.Vector2"/>
				<x path="echo.math.Vector2"/>
				<x path="echo.math.Vector2"/>
			</f>
			<meta><m n=":op"><e>a -= b</e></m></meta>
		</sub_eq>
		<sub_eq_scalar get="inline" set="null" line="201" static="1">
			<f a="a:f">
				<x path="echo.math.Vector2"/>
				<x path="Float"/>
				<x path="echo.math.Vector2"/>
			</f>
			<meta><m n=":op"><e>a -= b</e></m></meta>
		</sub_eq_scalar>
		<get_zero get="inline" set="null" line="207" static="1"><f a=""><x path="echo.math.Vector2"/></f></get_zero>
		<get_up get="inline" set="null" line="210" static="1"><f a=""><x path="echo.math.Vector2"/></f></get_up>
		<get_down get="inline" set="null" line="213" static="1"><f a=""><x path="echo.math.Vector2"/></f></get_down>
		<get_left get="inline" set="null" line="216" static="1"><f a=""><x path="echo.math.Vector2"/></f></get_left>
		<get_right get="inline" set="null" line="219" static="1"><f a=""><x path="echo.math.Vector2"/></f></get_right>
		<get_length get="inline" set="null" line="221" static="1"><f a="this">
	<t path="echo.math.Vector2Type"/>
	<x path="Float"/>
</f></get_length>
		<get_length_sq get="inline" set="null" line="226" static="1"><f a="this">
	<t path="echo.math.Vector2Type"/>
	<x path="Float"/>
</f></get_length_sq>
		<get_radians get="inline" set="null" line="231" static="1"><f a="this">
	<t path="echo.math.Vector2Type"/>
	<x path="Float"/>
</f></get_radians>
		<get_normal get="inline" set="null" line="236" static="1"><f a="this">
	<t path="echo.math.Vector2Type"/>
	<x path="echo.math.Vector2"/>
</f></get_normal>
		<set_length get="inline" set="null" line="246" static="1"><f a="this:f">
	<t path="echo.math.Vector2Type"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_length>
		<set_radians get="inline" set="null" line="252" static="1"><f a="this:radians">
	<t path="echo.math.Vector2Type"/>
	<x path="Float"/>
	<x path="Float"/>
</f></set_radians>
		<meta><m n=":using"><e>echo.math.Vector2</e></m></meta>
	</class>
	<class path="echo.math._Vector2.Vector2_Fields_" params="" file="/home/runner/work/echo/echo/echo/math/Vector2.hx" private="1" module="echo.math.Vector2" final="1">
		<set public="1" get="inline" set="null" line="262" static="1"><f a="v:x:y">
	<x path="echo.math.Vector2"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="echo.math.Vector2"/>
</f></set>
		<clone public="1" get="inline" set="null" line="268" static="1"><f a="v">
	<x path="echo.math.Vector2"/>
	<x path="echo.math.Vector2"/>
</f></clone>
		<copy_from public="1" get="inline" set="null" line="272" static="1"><f a="a:b">
	<x path="echo.math.Vector2"/>
	<x path="echo.math.Vector2"/>
	<x path="echo.math.Vector2"/>
</f></copy_from>
		<copy_to public="1" get="inline" set="null" line="278" static="1"><f a="a:b">
	<x path="echo.math.Vector2"/>
	<x path="echo.math.Vector2"/>
	<x path="echo.math.Vector2"/>
</f></copy_to>
		<is_zero public="1" get="inline" set="null" line="283" static="1"><f a="v">
	<x path="echo.math.Vector2"/>
	<x path="Bool"/>
</f></is_zero>
		<negate public="1" get="inline" set="null" line="288" static="1"><f a="v">
	<x path="echo.math.Vector2"/>
	<x path="echo.math.Vector2"/>
</f></negate>
		<distance public="1" get="inline" set="null" line="291" static="1"><f a="a:b">
	<x path="echo.math.Vector2"/>
	<x path="echo.math.Vector2"/>
	<x path="Float"/>
</f></distance>
		<dot public="1" get="inline" set="null" line="294" static="1"><f a="a:b">
	<x path="echo.math.Vector2"/>
	<x path="echo.math.Vector2"/>
	<x path="Float"/>
</f></dot>
		<normalize public="1" get="inline" set="null" line="300" static="1">
			<f a="v">
				<x path="echo.math.Vector2"/>
				<x path="echo.math.Vector2"/>
			</f>
			<haxe_doc>* Normalizes a `Vector2` (in place).
 * @param v 
 * @return Vector2</haxe_doc>
		</normalize>
		<rotate public="1" get="inline" set="null" line="309" static="1">
			<f a="v:radians">
				<x path="echo.math.Vector2"/>
				<x path="Float"/>
				<x path="echo.math.Vector2"/>
			</f>
			<haxe_doc>* Rotates a `Vector2` (in place) by the specified amount of radians.
 * @param v The `Vector2` to modify.
 * @param radians The amount of radians to rotate.</haxe_doc>
			<overloads><rotate public="1" get="inline" set="null" line="326">
	<f a="v:radians:pivot">
		<x path="echo.math.Vector2"/>
		<x path="Float"/>
		<x path="echo.math.Vector2"/>
		<x path="echo.math.Vector2"/>
	</f>
	<haxe_doc>* Rotates a `Vector2` (in place) around a pivot by the specified amount of radians.
 * @param v The `Vector2` to modify.
 * @param radians The amount of radians to rotate.
 * @param pivot Pivot position to rotate the `Vector2` around.</haxe_doc>
</rotate></overloads>
		</rotate>
		<rotate_left public="1" get="inline" set="null" line="341" static="1">
			<f a="v">
				<x path="echo.math.Vector2"/>
				<x path="echo.math.Vector2"/>
			</f>
			<haxe_doc>* Rotates a `Vector2` (in place) by 90 degrees to the left/counterclockwise (-y, x).
 * @param v The `Vector2` to modify.</haxe_doc>
		</rotate_left>
		<rotate_right public="1" get="inline" set="null" line="352" static="1">
			<f a="v">
				<x path="echo.math.Vector2"/>
				<x path="echo.math.Vector2"/>
			</f>
			<haxe_doc>* Rotates a `Vector2` (in place) by 90 degrees to the right/clockwise (y, -x). 
 * @param v The `Vector2` to modify.</haxe_doc>
		</rotate_right>
		<lerp public="1" get="inline" set="null" line="361" static="1"><f a="a:b:t">
	<x path="echo.math.Vector2"/>
	<x path="echo.math.Vector2"/>
	<x path="Float"/>
	<x path="echo.math.Vector2"/>
</f></lerp>
		<square_normal public="1" get="inline" set="null" line="367" static="1">
			<f a="v">
				<x path="echo.math.Vector2"/>
				<x path="echo.math.Vector2"/>
			</f>
			<haxe_doc>* Normalizes a `Vector2` (in place) to represent the closest cardinal direction (Up, Down, Left, or Right).
 * @param v The `Vector2` to modify.
 * @return the modified `Vector2`</haxe_doc>
		</square_normal>
		<reflect public="1" get="inline" set="null" line="382" static="1">
			<f a="v:n">
				<x path="echo.math.Vector2"/>
				<x path="echo.math.Vector2"/>
				<x path="echo.math.Vector2"/>
			</f>
			<haxe_doc>* Reflects a `Vector2` (in place) against the given normal.
 * @param v The `Vector2` to modify.
 * @param n The normal to reflect this `Vector2` against.
 * @return the modified `Vector2`</haxe_doc>
		</reflect>
		<radians_between public="1" get="inline" set="null" line="395" static="1">
			<f a="v:o">
				<x path="echo.math.Vector2"/>
				<x path="echo.math.Vector2"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Gets the arc tangent angle between two `Vector2`, in radians.
 * @param v 
 * @param o 
 * @return Float</haxe_doc>
			<overloads><radians_between public="1" get="inline" set="null" line="404">
	<f a="v:left:right">
		<x path="echo.math.Vector2"/>
		<x path="echo.math.Vector2"/>
		<x path="echo.math.Vector2"/>
		<x path="Float"/>
	</f>
	<haxe_doc>* Gets the arc tangent angle between three `Vector2`, in radians.
 * @param v 
 * @param left
 * @param right
 * @return Float</haxe_doc>
</radians_between></overloads>
		</radians_between>
	</class>
	<class path="echo.math.Vector3Default" params="" file="/home/runner/work/echo/echo/echo/math/Vector3.hx" module="echo.math.Vector3">
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<z public="1"><x path="Float"/></z>
		<toString public="1" set="method" line="20"><f a=""><c path="String"/></f></toString>
		<new public="1" get="inline" set="null" line="12"><f a="x:y:z">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":noCompletion"/>
		</meta>
	</class>
	<abstract path="echo.math.Vector3" params="" file="/home/runner/work/echo/echo/echo/math/Vector3.hx">
		<from>
			<icast><t path="echo.math.Vector3Type"/></icast>
			<icast field="from_arr"><c path="Array"><x path="Float"/></c></icast>
		</from>
		<this><t path="echo.math.Vector3Type"/></this>
		<to>
			<icast><t path="echo.math.Vector3Type"/></icast>
			<icast field="to_arr"><c path="Array"><x path="Float"/></c></icast>
		</to>
		<meta>
			<m n=":using"><e>echo.math.Vector3</e></m>
			<m n=":forward">
				<e>x</e>
				<e>y</e>
				<e>z</e>
			</m>
		</meta>
		<impl><class path="echo.math._Vector3.Vector3_Impl_" params="" file="/home/runner/work/echo/echo/echo/math/Vector3.hx" private="1" module="echo.math.Vector3" final="1">
	<from_arr public="1" get="inline" set="null" line="28" static="1">
		<f a="a">
			<c path="Array"><x path="Float"/></c>
			<x path="echo.math.Vector3"/>
		</f>
		<meta><m n=":from"/></meta>
	</from_arr>
	<to_arr public="1" get="inline" set="null" line="31" static="1">
		<f a="this">
			<t path="echo.math.Vector3Type"/>
			<c path="Array"><x path="Float"/></c>
		</f>
		<meta><m n=":to"/></meta>
	</to_arr>
	<_new public="1" get="inline" set="null" line="36" static="1">
		<f a="x:y:z">
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="echo.math.Vector3"/>
		</f>
		<meta><m n=":noCompletion"/></meta>
	</_new>
	<meta><m n=":using"><e>echo.math.Vector3</e></m></meta>
</class></impl>
	</abstract>
	<class path="echo.math._Vector3.Vector3_Impl_" params="" file="/home/runner/work/echo/echo/echo/math/Vector3.hx" private="1" module="echo.math.Vector3" final="1">
		<from_arr public="1" get="inline" set="null" line="28" static="1">
			<f a="a">
				<c path="Array"><x path="Float"/></c>
				<x path="echo.math.Vector3"/>
			</f>
			<meta><m n=":from"/></meta>
		</from_arr>
		<to_arr public="1" get="inline" set="null" line="31" static="1">
			<f a="this">
				<t path="echo.math.Vector3Type"/>
				<c path="Array"><x path="Float"/></c>
			</f>
			<meta><m n=":to"/></meta>
		</to_arr>
		<_new public="1" get="inline" set="null" line="36" static="1">
			<f a="x:y:z">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="echo.math.Vector3"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</_new>
		<meta><m n=":using"><e>echo.math.Vector3</e></m></meta>
	</class>
	<class path="echo.shape.Circle" params="" file="/home/runner/work/echo/echo/echo/shape/Circle.hx">
		<extends path="echo.Shape"/>
		<implements path="echo.util.Poolable"/>
		<get public="1" get="inline" set="null" line="32" static="1">
			<f a="?x:?y:?radius:?rotation:?scale_x:?scale_y" v="0:0:1:0:1:1">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="echo.shape.Circle"/>
			</f>
			<meta><m n=":value"><e>{ scale_y : 1, scale_x : 1, rotation : 0, radius : 1, y : 0, x : 0 }</e></m></meta>
			<haxe_doc>* Gets a Cirlce from the pool, or creates a new one if none are available. Call `put()` on the Cirlce to place it back in the pool.
   * @param x
   * @param y
   * @param radius
   * @param rotation
   * @return Circle</haxe_doc>
		</get>
		<pool expr="new echo.util.Poolable.GenericPool&lt;echo.shape.Circle&gt;(echo.shape.Circle)" line="89" static="1">
			<c path="echo.util.GenericPool_echo_shape_Circle"/>
			<meta><m n=":value"><e><![CDATA[new echo.util.Poolable.GenericPool<echo.shape.Circle>(echo.shape.Circle)]]></e></m></meta>
		</pool>
		<get_pool public="1" set="method" line="97" static="1"><f a=""><c path="echo.util.Pool"><c path="echo.shape.Circle"/></c></f></get_pool>
		<radius public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc>* The radius of the Circle, transformed with `scale_x`. Use `local_radius` to get the untransformed radius.</haxe_doc>
		</radius>
		<diameter public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc>* The diameter of the Circle.</haxe_doc>
		</diameter>
		<local_radius public="1">
			<x path="Float"/>
			<haxe_doc>* The local radius of the Circle, which represents the Circle's radius with no transformations.</haxe_doc>
		</local_radius>
		<put public="1" set="method" line="45" override="1"><f a=""><x path="Void"/></f></put>
		<set public="1" get="inline" set="null" line="53">
			<f a="?x:?y:?radius:?rotation:?scale_x:?scale_y" v="0:0:1:0:1:1">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="echo.shape.Circle"/>
			</f>
			<meta><m n=":value"><e>{ scale_y : 1, scale_x : 1, rotation : 0, radius : 1, y : 0, x : 0 }</e></m></meta>
		</set>
		<load public="1" get="inline" set="null" line="63"><f a="circle">
	<c path="echo.shape.Circle"/>
	<c path="echo.shape.Circle"/>
</f></load>
		<bounds public="1" get="inline" set="null" line="65" override="1"><f a="?aabb">
	<c path="echo.util.AABB"/>
	<c path="echo.util.AABB"/>
</f></bounds>
		<volume public="1" get="inline" set="null" line="70" override="1"><f a=""><x path="Float"/></f></volume>
		<clone public="1" set="method" line="75" override="1"><f a=""><c path="echo.shape.Circle"/></f></clone>
		<contains public="1" set="method" line="77" override="1"><f a="v">
	<x path="echo.math.Vector2"/>
	<x path="Bool"/>
</f></contains>
		<intersect public="1" set="method" line="79" override="1"><f a="l">
	<c path="echo.Line"/>
	<x path="Null"><c path="echo.data.IntersectionData"/></x>
</f></intersect>
		<overlaps public="1" get="inline" set="null" line="81" override="1"><f a="s">
	<c path="echo.Shape"/>
	<x path="Bool"/>
</f></overlaps>
		<collides public="1" get="inline" set="null" line="90" override="1"><f a="s">
	<c path="echo.Shape"/>
	<x path="Null"><c path="echo.data.CollisionData"/></x>
</f></collides>
		<collide_rect get="inline" set="null" line="92" override="1"><f a="r">
	<c path="echo.shape.Rect"/>
	<x path="Null"><c path="echo.data.CollisionData"/></x>
</f></collide_rect>
		<collide_circle get="inline" set="null" line="94" override="1"><f a="c">
	<c path="echo.shape.Circle"/>
	<x path="Null"><c path="echo.data.CollisionData"/></x>
</f></collide_circle>
		<collide_polygon get="inline" set="null" line="96" override="1"><f a="p">
	<c path="echo.shape.Polygon"/>
	<x path="Null"><c path="echo.data.CollisionData"/></x>
</f></collide_polygon>
		<get_radius get="inline" set="null" line="99"><f a=""><x path="Float"/></f></get_radius>
		<get_diameter get="inline" set="null" line="101"><f a=""><x path="Float"/></f></get_diameter>
		<get_top get="inline" set="null" line="103" override="1"><f a=""><x path="Float"/></f></get_top>
		<get_bottom get="inline" set="null" line="105" override="1"><f a=""><x path="Float"/></f></get_bottom>
		<get_left get="inline" set="null" line="107" override="1"><f a=""><x path="Float"/></f></get_left>
		<get_right get="inline" set="null" line="109" override="1"><f a=""><x path="Float"/></f></get_right>
		<set_radius get="inline" set="null" line="112"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_radius>
		<set_diameter get="inline" set="null" line="117"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_diameter>
		<pooled public="1" set="null" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</pooled>
		<new get="inline" set="null" line="39"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>echo.util.PoolableMacros.build()</e></m>
			<m n=":autoBuild"><e>echo.util.PoolableMacros.build()</e></m>
		</meta>
	</class>
	<class path="echo.shape.Polygon" params="" file="/home/runner/work/echo/echo/echo/shape/Polygon.hx">
		<extends path="echo.Shape"/>
		<implements path="echo.util.Poolable"/>
		<get public="1" get="inline" set="null" line="52" static="1">
			<f a="?x:?y:?sides:?radius:?rotation:?scale_x:?scale_y" v="0:0:3:1:0:1:1">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="echo.shape.Polygon"/>
			</f>
			<meta><m n=":value"><e>{ scale_y : 1, scale_x : 1, rotation : 0, radius : 1, sides : 3, y : 0, x : 0 }</e></m></meta>
			<haxe_doc>* Gets a Polygon from the pool, or creates a new one if none are available. Call `put()` on the Polygon to place it back in the pool.
   * @param x
   * @param y
   * @param sides
   * @param radius
   * @param rotation
   * @return Polygon</haxe_doc>
		</get>
		<get_from_vertices public="1" get="inline" set="null" line="80" static="1">
			<f a="?x:?y:?rotation:?vertices:?scale_x:?scale_y" v="0:0:0::1:1">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="Array"><x path="echo.math.Vector2"/></c>
				<x path="Float"/>
				<x path="Float"/>
				<c path="echo.shape.Polygon"/>
			</f>
			<meta><m n=":value"><e>{ scale_y : 1, scale_x : 1, rotation : 0, y : 0, x : 0 }</e></m></meta>
			<haxe_doc>* Gets a Polygon from the pool, or creates a new one if none are available. Call `put()` on the Polygon to place it back in the pool.
   * @param x
   * @param y
   * @param rotation
   * @param vertices
   * @return Polygon</haxe_doc>
		</get_from_vertices>
		<get_from_rect public="1" get="inline" set="null" line="91" static="1">
			<f a="rect">
				<c path="echo.shape.Rect"/>
				<c path="echo.shape.Polygon"/>
			</f>
			<haxe_doc>* Gets a Polygon from the pool, or creates a new one if none are available. Call `put()` on the Polygon to place it back in the pool.
   * @param rect
   * @return Polygon return _pool.get().set_from_rect(rect)</haxe_doc>
		</get_from_rect>
		<pool expr="new echo.util.Poolable.GenericPool&lt;echo.shape.Polygon&gt;(echo.shape.Polygon)" line="89" static="1">
			<c path="echo.util.GenericPool_echo_shape_Polygon"/>
			<meta><m n=":value"><e><![CDATA[new echo.util.Poolable.GenericPool<echo.shape.Polygon>(echo.shape.Polygon)]]></e></m></meta>
		</pool>
		<get_pool public="1" set="method" line="97" static="1"><f a=""><c path="echo.util.Pool"><c path="echo.shape.Polygon"/></c></f></get_pool>
		<count public="1" set="null">
			<x path="Int"/>
			<haxe_doc>* The amount of vertices in the Polygon.</haxe_doc>
		</count>
		<vertices public="1" get="accessor" set="null">
			<c path="Array"><x path="echo.math.Vector2"/></c>
			<haxe_doc>* The Polygon's vertices adjusted for it's rotation.
   *
   * This Array represents a cache'd value, so changes to this Array will be overwritten.
   * Use `set_vertice()` or `set_vertices()` to edit this Polygon's vertices.</haxe_doc>
		</vertices>
		<normals public="1" get="accessor" set="null">
			<c path="Array"><x path="echo.math.Vector2"/></c>
			<haxe_doc>* The Polygon's computed normals.
   *
   * This Array represents a cache'd value, so changes to this Array will be overwritten.
   * Use `set_vertice()` or `set_vertices()` to edit this Polygon's normals.</haxe_doc>
		</normals>
		<local_vertices><c path="Array"><x path="echo.math.Vector2"/></c></local_vertices>
		<_vertices><c path="Array"><x path="echo.math.Vector2"/></c></_vertices>
		<_normals><c path="Array"><x path="echo.math.Vector2"/></c></_normals>
		<_bounds><c path="echo.util.AABB"/></_bounds>
		<dirty_vertices><x path="Bool"/></dirty_vertices>
		<dirty_bounds><x path="Bool"/></dirty_bounds>
		<put public="1" set="method" line="101" override="1"><f a=""><x path="Void"/></f></put>
		<set public="1" get="inline" set="null" line="109">
			<f a="?x:?y:?rotation:?vertices:?scale_x:?scale_y" v="0:0:0::1:1">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="Array"><x path="echo.math.Vector2"/></c>
				<x path="Float"/>
				<x path="Float"/>
				<c path="echo.shape.Polygon"/>
			</f>
			<meta><m n=":value"><e>{ scale_y : 1, scale_x : 1, rotation : 0, y : 0, x : 0 }</e></m></meta>
		</set>
		<set_from_rect public="1" get="inline" set="null" line="119"><f a="rect">
	<c path="echo.shape.Rect"/>
	<c path="echo.shape.Polygon"/>
</f></set_from_rect>
		<load public="1" get="inline" set="null" line="146"><f a="polygon">
	<c path="echo.shape.Polygon"/>
	<c path="echo.shape.Polygon"/>
</f></load>
		<bounds public="1" set="method" line="149" override="1"><f a="?aabb">
	<c path="echo.util.AABB"/>
	<c path="echo.util.AABB"/>
</f></bounds>
		<volume public="1" get="inline" set="null" line="173" override="1"><f a=""><x path="Float"/></f></volume>
		<clone public="1" set="method" line="185" override="1"><f a=""><c path="echo.shape.Polygon"/></f></clone>
		<contains public="1" set="method" line="187" override="1"><f a="v">
	<x path="echo.math.Vector2"/>
	<x path="Bool"/>
</f></contains>
		<intersect public="1" set="method" line="189" override="1"><f a="l">
	<c path="echo.Line"/>
	<x path="Null"><c path="echo.data.IntersectionData"/></x>
</f></intersect>
		<overlaps public="1" get="inline" set="null" line="191" override="1"><f a="s">
	<c path="echo.Shape"/>
	<x path="Bool"/>
</f></overlaps>
		<collides public="1" get="inline" set="null" line="200" override="1"><f a="s">
	<c path="echo.Shape"/>
	<x path="Null"><c path="echo.data.CollisionData"/></x>
</f></collides>
		<collide_rect get="inline" set="null" line="202" override="1"><f a="r">
	<c path="echo.shape.Rect"/>
	<x path="Null"><c path="echo.data.CollisionData"/></x>
</f></collide_rect>
		<collide_circle get="inline" set="null" line="204" override="1"><f a="c">
	<c path="echo.shape.Circle"/>
	<x path="Null"><c path="echo.data.CollisionData"/></x>
</f></collide_circle>
		<collide_polygon get="inline" set="null" line="206" override="1"><f a="p">
	<c path="echo.shape.Polygon"/>
	<x path="Null"><c path="echo.data.CollisionData"/></x>
</f></collide_polygon>
		<get_top get="inline" set="null" line="208" override="1"><f a=""><x path="Float"/></f></get_top>
		<get_bottom get="inline" set="null" line="217" override="1"><f a=""><x path="Float"/></f></get_bottom>
		<get_left get="inline" set="null" line="226" override="1"><f a=""><x path="Float"/></f></get_left>
		<get_right get="inline" set="null" line="235" override="1"><f a=""><x path="Float"/></f></get_right>
		<to_rect public="1" get="inline" set="null" line="245"><f a=""><c path="echo.shape.Rect"/></f></to_rect>
		<set_vertice public="1" get="inline" set="null" line="252">
			<f a="index:?x:?y" v=":0:0">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ y : 0, x : 0 }</e></m></meta>
			<haxe_doc>* Sets the vertice at the desired index.
   * @param index
   * @param x
   * @param y</haxe_doc>
		</set_vertice>
		<set_vertices public="1" get="inline" set="null" line="259"><f a="?vertices:?count">
	<c path="Array"><x path="echo.math.Vector2"/></c>
	<x path="Int"/>
	<x path="Void"/>
</f></set_vertices>
		<centroid public="1" get="inline" set="null" line="267"><f a=""><x path="echo.math.Vector2"/></f></centroid>
		<on_dirty set="method" line="291"><f a="t">
	<c path="echo.util.Transform"/>
	<x path="Void"/>
</f></on_dirty>
		<set_dirty get="inline" set="null" line="295"><f a=""><x path="Void"/></f></set_dirty>
		<transform_vertices get="inline" set="null" line="300"><f a=""><x path="Void"/></f></transform_vertices>
		<compute_normals get="inline" set="null" line="314">
			<f a=""><x path="Void"/></f>
			<haxe_doc>*  Compute face normals</haxe_doc>
		</compute_normals>
		<get_vertices get="inline" set="null" line="329"><f a=""><c path="Array"><x path="echo.math.Vector2"/></c></f></get_vertices>
		<get_normals get="inline" set="null" line="339"><f a=""><c path="Array"><x path="echo.math.Vector2"/></c></f></get_normals>
		<pooled public="1" set="null" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</pooled>
		<new get="inline" set="null" line="136"><f a="?vertices">
	<c path="Array"><x path="echo.math.Vector2"/></c>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>echo.util.PoolableMacros.build()</e></m>
			<m n=":autoBuild"><e>echo.util.PoolableMacros.build()</e></m>
		</meta>
	</class>
	<class path="echo.shape.Rect" params="" file="/home/runner/work/echo/echo/echo/shape/Rect.hx">
		<extends path="echo.Shape"/>
		<implements path="echo.util.Poolable"/>
		<get public="1" get="inline" set="null" line="68" static="1">
			<f a="?x:?y:?width:?height:?rotation:?scale_x:?scale_y" v="0:0:1:0:0:1:1">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="echo.shape.Rect"/>
			</f>
			<meta><m n=":value"><e>{ scale_y : 1, scale_x : 1, rotation : 0, height : 0, width : 1, y : 0, x : 0 }</e></m></meta>
			<haxe_doc>* Gets a Rect from the pool, or creates a new one if none are available. Call `put()` on the Rect to place it back in the pool.
   *
   * Note - The X and Y positions represent the center of the Rect. To set the Rect from its Top-Left origin, `Rect.get_from_min_max()` is available.
   * @param x The centered X position of the Rect.
   * @param y The centered Y position of the Rect.
   * @param width The width of the Rect.
   * @param height The height of the Rect.
   * @param rotation The rotation of the Rect.
   * @return Rect</haxe_doc>
		</get>
		<get_from_min_max public="1" get="inline" set="null" line="82" static="1">
			<f a="min_x:min_y:max_x:max_y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="echo.shape.Rect"/>
			</f>
			<haxe_doc>* Gets a Rect from the pool, or creates a new one if none are available. Call `put()` on the Rect to place it back in the pool.
   * @param min_x
   * @param min_y
   * @param max_x
   * @param max_y
   * @return Rect</haxe_doc>
		</get_from_min_max>
		<pool expr="new echo.util.Poolable.GenericPool&lt;echo.shape.Rect&gt;(echo.shape.Rect)" line="89" static="1">
			<c path="echo.util.GenericPool_echo_shape_Rect"/>
			<meta><m n=":value"><e><![CDATA[new echo.util.Poolable.GenericPool<echo.shape.Rect>(echo.shape.Rect)]]></e></m></meta>
		</pool>
		<get_pool public="1" set="method" line="97" static="1"><f a=""><c path="echo.util.Pool"><c path="echo.shape.Rect"/></c></f></get_pool>
		<ex public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc>* The half-width of the Rectangle, transformed with `scale_x`. Use `local_ex` to get the untransformed extent.</haxe_doc>
		</ex>
		<ey public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc>* The half-height of the Rectangle, transformed with `scale_y`. Use `local_ey` to get the untransformed extent.</haxe_doc>
		</ey>
		<width public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc>* The width of the Rectangle, transformed with `scale_x`. Use `local_width` to get the untransformed width.</haxe_doc>
		</width>
		<height public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc>* The height of the Rectangle, transformed with `scale_y`. Use `local_height` to get the untransformed height.</haxe_doc>
		</height>
		<local_width public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc>* The width of the Rectangle.</haxe_doc>
		</local_width>
		<local_height public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc>* The height of the Rectangle.</haxe_doc>
		</local_height>
		<local_ex public="1" set="accessor">
			<x path="Float"/>
			<haxe_doc>* The half-width of the Rectangle.</haxe_doc>
		</local_ex>
		<local_ey public="1" set="accessor">
			<x path="Float"/>
			<haxe_doc>* The half-height of the Rectangle.</haxe_doc>
		</local_ey>
		<min public="1" get="accessor" set="null">
			<x path="echo.math.Vector2"/>
			<haxe_doc>* The top-left position of the Rectangle.</haxe_doc>
		</min>
		<max public="1" get="accessor" set="null">
			<x path="echo.math.Vector2"/>
			<haxe_doc>* The bottom-right position of the Rectangle.</haxe_doc>
		</max>
		<transformed_rect public="1" set="null">
			<x path="Null"><c path="echo.shape.Polygon"/></x>
			<haxe_doc>* If the Rectangle has a rotation, this Polygon is constructed to represent the transformed vertices of the Rectangle.</haxe_doc>
		</transformed_rect>
		<put public="1" set="method" line="97" override="1"><f a=""><x path="Void"/></f></put>
		<set public="1" get="inline" set="null" line="109">
			<f a="?x:?y:?width:?height:?rotation:?scale_x:?scale_y" v="0:0:1:0:0:1:1">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="echo.shape.Rect"/>
			</f>
			<meta><m n=":value"><e>{ scale_y : 1, scale_x : 1, rotation : 0, height : 0, width : 1, y : 0, x : 0 }</e></m></meta>
		</set>
		<set_from_min_max public="1" get="inline" set="null" line="121"><f a="min_x:min_y:max_x:max_y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="echo.shape.Rect"/>
</f></set_from_min_max>
		<load public="1" get="inline" set="null" line="125"><f a="rect">
	<c path="echo.shape.Rect"/>
	<c path="echo.shape.Rect"/>
</f></load>
		<to_aabb public="1" set="method" line="137">
			<f a="?put_self" v="false">
				<x path="Bool"/>
				<c path="echo.util.AABB"/>
			</f>
			<meta><m n=":value"><e>{ put_self : false }</e></m></meta>
		</to_aabb>
		<to_polygon public="1" set="method" line="146">
			<f a="?put_self" v="false">
				<x path="Bool"/>
				<c path="echo.shape.Polygon"/>
			</f>
			<meta><m n=":value"><e>{ put_self : false }</e></m></meta>
		</to_polygon>
		<bounds public="1" get="inline" set="null" line="155" override="1"><f a="?aabb">
	<c path="echo.util.AABB"/>
	<c path="echo.util.AABB"/>
</f></bounds>
		<volume public="1" get="inline" set="null" line="160" override="1"><f a=""><x path="Float"/></f></volume>
		<clone public="1" get="inline" set="null" line="162" override="1"><f a=""><c path="echo.shape.Rect"/></f></clone>
		<contains public="1" get="inline" set="null" line="164" override="1"><f a="p">
	<x path="echo.math.Vector2"/>
	<x path="Bool"/>
</f></contains>
		<intersect public="1" get="inline" set="null" line="166" override="1"><f a="l">
	<c path="echo.Line"/>
	<x path="Null"><c path="echo.data.IntersectionData"/></x>
</f></intersect>
		<overlaps public="1" get="inline" set="null" line="168" override="1"><f a="s">
	<c path="echo.Shape"/>
	<x path="Bool"/>
</f></overlaps>
		<collides public="1" get="inline" set="null" line="177" override="1"><f a="s">
	<c path="echo.Shape"/>
	<x path="Null"><c path="echo.data.CollisionData"/></x>
</f></collides>
		<collide_rect get="inline" set="null" line="179" override="1"><f a="r">
	<c path="echo.shape.Rect"/>
	<x path="Null"><c path="echo.data.CollisionData"/></x>
</f></collide_rect>
		<collide_circle get="inline" set="null" line="181" override="1"><f a="c">
	<c path="echo.shape.Circle"/>
	<x path="Null"><c path="echo.data.CollisionData"/></x>
</f></collide_circle>
		<collide_polygon get="inline" set="null" line="183" override="1"><f a="p">
	<c path="echo.shape.Polygon"/>
	<x path="Null"><c path="echo.data.CollisionData"/></x>
</f></collide_polygon>
		<set_parent public="1" set="method" line="185" override="1"><f a="?body">
	<c path="echo.Body"/>
	<x path="Void"/>
</f></set_parent>
		<on_dirty set="method" line="191"><f a="t">
	<c path="echo.util.Transform"/>
	<x path="Void"/>
</f></on_dirty>
		<set_dirty get="inline" set="null" line="195"><f a=""><x path="Void"/></f></set_dirty>
		<get_width get="inline" set="null" line="211"><f a=""><x path="Float"/></f></get_width>
		<get_height get="inline" set="null" line="213"><f a=""><x path="Float"/></f></get_height>
		<get_ex get="inline" set="null" line="215"><f a=""><x path="Float"/></f></get_ex>
		<get_ey get="inline" set="null" line="217"><f a=""><x path="Float"/></f></get_ey>
		<get_local_width get="inline" set="null" line="219"><f a=""><x path="Float"/></f></get_local_width>
		<get_local_height get="inline" set="null" line="221"><f a=""><x path="Float"/></f></get_local_height>
		<get_min set="method" line="223"><f a=""><x path="echo.math.Vector2"/></f></get_min>
		<get_max set="method" line="225"><f a=""><x path="echo.math.Vector2"/></f></get_max>
		<get_top get="inline" set="null" line="227" override="1"><f a=""><x path="Float"/></f></get_top>
		<get_bottom get="inline" set="null" line="232" override="1"><f a=""><x path="Float"/></f></get_bottom>
		<get_left get="inline" set="null" line="237" override="1"><f a=""><x path="Float"/></f></get_left>
		<get_right get="inline" set="null" line="242" override="1"><f a=""><x path="Float"/></f></get_right>
		<set_ex get="inline" set="null" line="248"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_ex>
		<set_ey get="inline" set="null" line="253"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_ey>
		<set_width get="inline" set="null" line="258"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_width>
		<set_height get="inline" set="null" line="263"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_height>
		<set_local_width get="inline" set="null" line="268"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_local_width>
		<set_local_height get="inline" set="null" line="270"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_local_height>
		<set_local_ex get="inline" set="null" line="272"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_local_ex>
		<set_local_ey get="inline" set="null" line="278"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_local_ey>
		<pooled public="1" set="null" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</pooled>
		<new get="inline" set="null" line="89"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>echo.util.PoolableMacros.build()</e></m>
			<m n=":autoBuild"><e>echo.util.PoolableMacros.build()</e></m>
		</meta>
	</class>
	<class path="echo.util.AABB" params="" file="/home/runner/work/echo/echo/echo/util/AABB.hx">
		<implements path="echo.util.Poolable"/>
		<get public="1" get="inline" set="null" line="25" static="1">
			<f a="?x:?y:?width:?height" v="0:0:1:1">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="echo.util.AABB"/>
			</f>
			<meta><m n=":value"><e>{ height : 1, width : 1, y : 0, x : 0 }</e></m></meta>
			<haxe_doc>* Gets an AABB from the pool, or creates a new one if none are available. Call `put()` on the AABB to place it back in the pool.
   *
   * Note - The X and Y positions represent the center of the AABB. To set the AABB from its Top-Left origin, `AABB.get_from_min_max()` is available.
   * @param x The centered X position of the AABB.
   * @param y The centered Y position of the AABB.
   * @param width The width of the AABB.
   * @param height The height of the AABB.
   * @return AABB</haxe_doc>
		</get>
		<get_from_min_max public="1" get="inline" set="null" line="39" static="1">
			<f a="min_x:min_y:max_x:max_y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="echo.util.AABB"/>
			</f>
			<haxe_doc>* Gets an AABB from the pool, or creates a new one if none are available. Call `put()` on the AABB to place it back in the pool.
   * @param min_x
   * @param min_y
   * @param max_x
   * @param max_y
   * @return AABB</haxe_doc>
		</get_from_min_max>
		<pool expr="new echo.util.Poolable.GenericPool&lt;echo.util.AABB&gt;(echo.util.AABB)" line="89" static="1">
			<c path="echo.util.GenericPool_echo_util_AABB"/>
			<meta><m n=":value"><e><![CDATA[new echo.util.Poolable.GenericPool<echo.util.AABB>(echo.util.AABB)]]></e></m></meta>
		</pool>
		<get_pool public="1" set="method" line="97" static="1"><f a=""><c path="echo.util.Pool"><c path="echo.util.AABB"/></c></f></get_pool>
		<min_x public="1"><x path="Float"/></min_x>
		<max_x public="1"><x path="Float"/></max_x>
		<min_y public="1"><x path="Float"/></min_y>
		<max_y public="1"><x path="Float"/></max_y>
		<width public="1" get="accessor" set="null"><x path="Float"/></width>
		<height public="1" get="accessor" set="null"><x path="Float"/></height>
		<set public="1" get="inline" set="null" line="62">
			<f a="?x:?y:?width:?height" v="0:0:1:1">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="echo.util.AABB"/>
			</f>
			<meta><m n=":value"><e>{ height : 1, width : 1, y : 0, x : 0 }</e></m></meta>
			<haxe_doc>* Sets the values on this AABB.
   *
   * Note - The X and Y positions represent the center of the AABB. To set the AABB from its Top-Left origin, `AABB.set_from_min_max()` is available.
   * @param x The centered X position of the AABB.
   * @param y The centered Y position of the AABB.
   * @param width The width of the AABB.
   * @param height The height of the AABB.
   * @return AABB</haxe_doc>
		</set>
		<set_from_min_max public="1" get="inline" set="null" line="72"><f a="min_x:min_y:max_x:max_y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="echo.util.AABB"/>
</f></set_from_min_max>
		<to_rect public="1" get="inline" set="null" line="80">
			<f a="?put_self" v="false">
				<x path="Bool"/>
				<c path="echo.shape.Rect"/>
			</f>
			<meta><m n=":value"><e>{ put_self : false }</e></m></meta>
		</to_rect>
		<overlaps public="1" get="inline" set="null" line="85"><f a="other">
	<c path="echo.util.AABB"/>
	<x path="Bool"/>
</f></overlaps>
		<contains public="1" get="inline" set="null" line="89"><f a="point">
	<x path="echo.math.Vector2"/>
	<x path="Bool"/>
</f></contains>
		<load public="1" get="inline" set="null" line="93"><f a="aabb">
	<c path="echo.util.AABB"/>
	<c path="echo.util.AABB"/>
</f></load>
		<add public="1" get="inline" set="null" line="104">
			<f a="aabb">
				<c path="echo.util.AABB"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Adds the bounds of an AABB into this AABB.
   * @param aabb</haxe_doc>
		</add>
		<clone public="1" get="inline" set="null" line="111"><f a=""><c path="echo.util.AABB"/></f></clone>
		<put public="1" set="method" line="115"><f a=""><x path="Void"/></f></put>
		<toString set="method" line="122"><f a=""><c path="String"/></f></toString>
		<get_width get="inline" set="null" line="126"><f a=""><x path="Float"/></f></get_width>
		<get_height get="inline" set="null" line="128"><f a=""><x path="Float"/></f></get_height>
		<pooled public="1" set="null" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</pooled>
		<new get="inline" set="null" line="46"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>echo.util.PoolableMacros.build()</e></m>
			<m n=":autoBuild"><e>echo.util.PoolableMacros.build()</e></m>
		</meta>
	</class>
	<class path="echo.util.Bezier" params="" file="/home/runner/work/echo/echo/echo/util/Bezier.hx">
		<implements path="echo.util.Disposable"/>
		<point_on_quadratic_curve public="1" set="method" line="14" static="1">
			<f a="t:ax:ay:bx:by:cx:cy">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="echo.math.Vector2"/>
			</f>
			<haxe_doc>* Gets the point at the defined `t` (a value between 0.0 to 1.0) from a Quadratic Bezier Curve constructed out of points (ax, ay), (bx, by), and (cx, cy).</haxe_doc>
		</point_on_quadratic_curve>
		<point_on_cubic_curve public="1" set="method" line="35" static="1">
			<f a="t:ax:ay:bx:by:cx:cy:dx:dy">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="echo.math.Vector2"/>
			</f>
			<haxe_doc>* Gets the point at the defined `t` (a value between 0.0 to 1.0) from a Cubic Bezier Curve constructed out of points (ax, ay), (bx, by), (cx, cy), and (dx, dy).</haxe_doc>
		</point_on_cubic_curve>
		<subdivide_quadratic_bezier_curve public="1" set="method" line="58" static="1">
			<f a="ax:ay:bx:by:cx:cy:?points:options">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="Array"><x path="echo.math.Vector2"/></c>
				<t path="echo.util.BezierSubdivisionOptions"/>
				<x path="Null"><c path="Array"><x path="echo.math.Vector2"/></c></x>
			</f>
			<haxe_doc>* Ported from https://github.com/mattdesl/adaptive-quadratic-curve</haxe_doc>
		</subdivide_quadratic_bezier_curve>
		<subdivide_cubic_bezier_curve public="1" set="method" line="138" static="1">
			<f a="ax:ay:bx:by:cx:cy:dx:dy:?points:options">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="Array"><x path="echo.math.Vector2"/></c>
				<t path="echo.util.BezierSubdivisionOptions"/>
				<x path="Null"><c path="Array"><x path="echo.math.Vector2"/></c></x>
			</f>
			<haxe_doc>* Ported from https://github.com/mattdesl/adaptive-bezier-curve</haxe_doc>
		</subdivide_cubic_bezier_curve>
		<lines public="1" get="accessor" set="null" expr="[]">
			<c path="Array"><c path="echo.Line"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
			<haxe_doc>* Cached Array of Lines that represents the current state of the Curve.</haxe_doc>
		</lines>
		<points public="1" get="accessor" set="null" expr="[]">
			<c path="Array"><x path="echo.math.Vector2"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
			<haxe_doc>* Cached Array of Points that represents the current state of the Curve.</haxe_doc>
		</points>
		<length public="1" get="accessor" set="null"><x path="Float"/></length>
		<line_mode public="1" set="accessor" expr="Subdivisions()">
			<e path="echo.util.BezierLineMode"/>
			<meta><m n=":value"><e>Subdivisions()</e></m></meta>
			<haxe_doc>* The method used to construct `lines` from the Curve.</haxe_doc>
		</line_mode>
		<control_count public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* The amount of control points in this Curve.</haxe_doc>
		</control_count>
		<curve_mode public="1" set="accessor"><x path="echo.util.BezierCurve"/></curve_mode>
		<curve_count public="1" set="null" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</curve_count>
		<closed public="1" set="accessor"><x path="Bool"/></closed>
		<on_dirty public="1"><f a="">
	<c path="echo.util.Bezier"/>
	<x path="Void"/>
</f></on_dirty>
		<control_points><c path="Array"><x path="echo.math.Vector2"/></c></control_points>
		<dirty expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</dirty>
		<dispose public="1" set="method" line="341"><f a=""><x path="Void"/></f></dispose>
		<add_curve public="1" set="method" line="347"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></add_curve>
		<add_control_point public="1" set="method" line="364"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></add_control_point>
		<get_control_point public="1" get="inline" set="null" line="370"><f a="index">
	<x path="Int"/>
	<x path="Null"><x path="echo.math.Vector2"/></x>
</f></get_control_point>
		<get_control_points public="1" get="inline" set="null" line="375"><f a=""><c path="Array"><x path="echo.math.Vector2"/></c></f></get_control_points>
		<get_control_points_in_curve public="1" get="inline" set="null" line="380"><f a="index">
	<x path="Int"/>
	<c path="Array"><x path="echo.math.Vector2"/></c>
</f></get_control_points_in_curve>
		<set_control_point public="1" set="method" line="386">
			<f a="index:x:y:?move_neighbors" v=":::true">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ move_neighbors : true }</e></m></meta>
		</set_control_point>
		<set_control_points public="1" set="method" line="418"><f a="?control_points">
	<c path="Array"><x path="echo.math.Vector2"/></c>
	<x path="Void"/>
</f></set_control_points>
		<remove_control_point public="1" get="inline" set="null" line="424"><f a="index">
	<x path="Int"/>
	<x path="Void"/>
</f></remove_control_point>
		<remove_all_control_points public="1" get="inline" set="null" line="430"><f a=""><x path="Void"/></f></remove_all_control_points>
		<get_point public="1" get="inline" set="null" line="440">
			<f a="t:?start_index" v=":-1">
				<x path="Float"/>
				<x path="Int"/>
				<x path="Null"><x path="echo.math.Vector2"/></x>
			</f>
			<meta><m n=":value"><e>{ start_index : -1 }</e></m></meta>
			<haxe_doc>* Gets the point on the Curve at the defined `t`.
   * @param t A value between 0.0 to 1.0.
   * @param start_index Determines the starting control point that will be used to construct the Curve. If set to -1, this will be determined automatically based on `t`.</haxe_doc>
		</get_point>
		<get_point_at_length public="1" set="method" line="469"><f a="length">
	<x path="Float"/>
	<x path="Null"><x path="echo.math.Vector2"/></x>
</f></get_point_at_length>
		<set_dirty public="1" set="method" line="473"><f a=""><x path="Void"/></f></set_dirty>
		<generate set="method" line="478"><f a=""><x path="Void"/></f></generate>
		<get_lines set="method" line="544"><f a=""><c path="Array"><c path="echo.Line"/></c></f></get_lines>
		<get_points set="method" line="549"><f a=""><c path="Array"><x path="echo.math.Vector2"/></c></f></get_points>
		<get_length set="method" line="554"><f a=""><x path="Float"/></f></get_length>
		<get_control_count get="inline" set="null" line="559"><f a=""><x path="Int"/></f></get_control_count>
		<get_looped_index get="inline" set="null" line="561"><f a="index">
	<x path="Int"/>
	<x path="Int"/>
</f></get_looped_index>
		<update_curve_count get="inline" set="null" line="563"><f a=""><x path="Void"/></f></update_curve_count>
		<set_line_mode get="inline" set="null" line="568"><f a="v">
	<e path="echo.util.BezierLineMode"/>
	<e path="echo.util.BezierLineMode"/>
</f></set_line_mode>
		<set_curve_mode set="method" line="573"><f a="v">
	<x path="echo.util.BezierCurve"/>
	<x path="echo.util.BezierCurve"/>
</f></set_curve_mode>
		<set_closed set="method" line="582"><f a="v">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_closed>
		<new public="1" set="method" line="334">
			<f a="?control_points:?curve_mode" v=":Cubic">
				<c path="Array"><x path="echo.math.Vector2"/></c>
				<x path="echo.util.BezierCurve"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ curve_mode : Cubic }</e></m></meta>
		</new>
	</class>
	<abstract path="echo.util.BezierCurve" params="" file="/home/runner/work/echo/echo/echo/util/Bezier.hx" module="echo.util.Bezier">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to><icast><x path="Int"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="echo.util._Bezier.BezierCurve_Impl_" params="" file="/home/runner/work/echo/echo/echo/util/Bezier.hx" private="1" module="echo.util.Bezier" extern="1" final="1">
	<Linear public="1" get="inline" set="null" expr="cast 1" line="604" static="1">
		<x path="echo.util.BezierCurve"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</Linear>
	<Quadratic public="1" get="inline" set="null" expr="cast 2" line="605" static="1">
		<x path="echo.util.BezierCurve"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</Quadratic>
	<Cubic public="1" get="inline" set="null" expr="cast 3" line="606" static="1">
		<x path="echo.util.BezierCurve"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
	</Cubic>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="echo.util._Bezier.BezierCurve_Impl_" params="" file="/home/runner/work/echo/echo/echo/util/Bezier.hx" private="1" module="echo.util.Bezier" extern="1" final="1">
		<Linear public="1" get="inline" set="null" expr="cast 1" line="604" static="1">
			<x path="echo.util.BezierCurve"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</Linear>
		<Quadratic public="1" get="inline" set="null" expr="cast 2" line="605" static="1">
			<x path="echo.util.BezierCurve"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</Quadratic>
		<Cubic public="1" get="inline" set="null" expr="cast 3" line="606" static="1">
			<x path="echo.util.BezierCurve"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
		</Cubic>
		<meta><m n=":enum"/></meta>
	</class>
	<enum path="echo.util.BezierLineMode" params="" file="/home/runner/work/echo/echo/echo/util/Bezier.hx" module="echo.util.Bezier">
		<Segments a="amount">
			<x path="Int"/>
			<haxe_doc>* Splits each Bezier Curve in the path into the defined `amount` of Line Segements.</haxe_doc>
		</Segments>
		<Subdivisions a="?options"><t path="echo.util.BezierSubdivisionOptions"/></Subdivisions>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<typedef path="echo.util.BezierSubdivisionOptions" params="" file="/home/runner/work/echo/echo/echo/util/Bezier.hx" module="echo.util.Bezier"><a>
	<scale>
		<x path="Null"><x path="Float"/></x>
		<meta><m n=":optional"/></meta>
	</scale>
	<recursion_limit>
		<x path="Null"><x path="Int"/></x>
		<meta><m n=":optional"/></meta>
	</recursion_limit>
	<path_epsilon>
		<x path="Null"><x path="Float"/></x>
		<meta><m n=":optional"/></meta>
	</path_epsilon>
	<epsilon>
		<x path="Null"><x path="Float"/></x>
		<meta><m n=":optional"/></meta>
	</epsilon>
	<cusp_limit>
		<x path="Null"><x path="Float"/></x>
		<meta><m n=":optional"/></meta>
	</cusp_limit>
	<angle_tolerance>
		<x path="Null"><x path="Float"/></x>
		<meta><m n=":optional"/></meta>
	</angle_tolerance>
	<angle_epsilon>
		<x path="Null"><x path="Float"/></x>
		<meta><m n=":optional"/></meta>
	</angle_epsilon>
</a></typedef>
	<abstract path="echo.util.BitMask" params="" file="/home/runner/work/echo/echo/echo/util/BitMask.hx">
		<from><icast field="from_int"><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to><icast><x path="Int"/></icast></to>
		<impl><class path="echo.util._BitMask.BitMask_Impl_" params="" file="/home/runner/work/echo/echo/echo/util/BitMask.hx" private="1" module="echo.util.BitMask" final="1">
	<from_int public="1" set="method" line="6" static="1">
		<f a="i">
			<x path="Int"/>
			<x path="echo.util.BitMask"/>
		</f>
		<meta><m n=":from"/></meta>
	</from_int>
	<_new public="1" set="method" line="10" static="1">
		<f a="?value" v="0">
			<x path="Int"/>
			<x path="echo.util.BitMask"/>
		</f>
		<meta>
			<m n=":value"><e>{ value : 0 }</e></m>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<remove public="1" get="inline" set="null" line="12" static="1"><f a="this:mask">
	<x path="Int"/>
	<x path="echo.util.BitMask"/>
	<x path="Int"/>
</f></remove>
	<add public="1" get="inline" set="null" line="16" static="1"><f a="this:mask">
	<x path="Int"/>
	<x path="echo.util.BitMask"/>
	<x path="Int"/>
</f></add>
	<contains public="1" get="inline" set="null" line="20" static="1"><f a="this:mask">
	<x path="Int"/>
	<x path="echo.util.BitMask"/>
	<x path="Bool"/>
</f></contains>
	<clear public="1" get="inline" set="null" line="24" static="1"><f a="this">
	<x path="Int"/>
	<x path="Void"/>
</f></clear>
	<is_empty public="1" get="inline" set="null" line="28" static="1"><f a="this">
	<x path="Int"/>
	<x path="Bool"/>
</f></is_empty>
	<meta><m n=":directlyUsed"/></meta>
</class></impl>
	</abstract>
	<class path="echo.util._BitMask.BitMask_Impl_" params="" file="/home/runner/work/echo/echo/echo/util/BitMask.hx" private="1" module="echo.util.BitMask" final="1">
		<from_int public="1" set="method" line="6" static="1">
			<f a="i">
				<x path="Int"/>
				<x path="echo.util.BitMask"/>
			</f>
			<meta><m n=":from"/></meta>
		</from_int>
		<_new public="1" set="method" line="10" static="1">
			<f a="?value" v="0">
				<x path="Int"/>
				<x path="echo.util.BitMask"/>
			</f>
			<meta>
				<m n=":value"><e>{ value : 0 }</e></m>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<remove public="1" get="inline" set="null" line="12" static="1"><f a="this:mask">
	<x path="Int"/>
	<x path="echo.util.BitMask"/>
	<x path="Int"/>
</f></remove>
		<add public="1" get="inline" set="null" line="16" static="1"><f a="this:mask">
	<x path="Int"/>
	<x path="echo.util.BitMask"/>
	<x path="Int"/>
</f></add>
		<contains public="1" get="inline" set="null" line="20" static="1"><f a="this:mask">
	<x path="Int"/>
	<x path="echo.util.BitMask"/>
	<x path="Bool"/>
</f></contains>
		<clear public="1" get="inline" set="null" line="24" static="1"><f a="this">
	<x path="Int"/>
	<x path="Void"/>
</f></clear>
		<is_empty public="1" get="inline" set="null" line="28" static="1"><f a="this">
	<x path="Int"/>
	<x path="Bool"/>
</f></is_empty>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="echo.util.BodyOrBodies" params="" file="/home/runner/work/echo/echo/echo/util/BodyOrBodies.hx">
		<from>
			<icast><e path="haxe.ds.Either">
	<c path="echo.Body"/>
	<c path="Array"><c path="echo.Body"/></c>
</e></icast>
			<icast field="from_body"><c path="echo.Body"/></icast>
			<icast field="from_bodies"><c path="Array"><c path="echo.Body"/></c></icast>
		</from>
		<this><e path="haxe.ds.Either">
	<c path="echo.Body"/>
	<c path="Array"><c path="echo.Body"/></c>
</e></this>
		<to>
			<icast><e path="haxe.ds.Either">
	<c path="echo.Body"/>
	<c path="Array"><c path="echo.Body"/></c>
</e></icast>
			<icast field="to_body"><c path="echo.Body"/></icast>
			<icast field="to_bodies"><c path="Array"><c path="echo.Body"/></c></icast>
		</to>
		<haxe_doc>* Abstract representing a `Body` or and Array of Bodies.</haxe_doc>
		<impl><class path="echo.util._BodyOrBodies.BodyOrBodies_Impl_" params="" file="/home/runner/work/echo/echo/echo/util/BodyOrBodies.hx" private="1" module="echo.util.BodyOrBodies" final="1">
	<from_body get="inline" set="null" line="8" static="1">
		<f a="a">
			<c path="echo.Body"/>
			<x path="echo.util.BodyOrBodies"/>
		</f>
		<meta><m n=":from"/></meta>
	</from_body>
	<from_bodies get="inline" set="null" line="12" static="1">
		<f a="b">
			<c path="Array"><c path="echo.Body"/></c>
			<x path="echo.util.BodyOrBodies"/>
		</f>
		<meta><m n=":from"/></meta>
	</from_bodies>
	<to_body get="inline" set="null" line="16" static="1">
		<f a="this">
			<e path="haxe.ds.Either">
				<c path="echo.Body"/>
				<c path="Array"><c path="echo.Body"/></c>
			</e>
			<x path="Null"><c path="echo.Body"/></x>
		</f>
		<meta><m n=":to"/></meta>
	</to_body>
	<to_bodies get="inline" set="null" line="21" static="1">
		<f a="this">
			<e path="haxe.ds.Either">
				<c path="echo.Body"/>
				<c path="Array"><c path="echo.Body"/></c>
			</e>
			<x path="Null"><c path="Array"><c path="echo.Body"/></c></x>
		</f>
		<meta><m n=":to"/></meta>
	</to_bodies>
</class></impl>
	</abstract>
	<class path="echo.util._BodyOrBodies.BodyOrBodies_Impl_" params="" file="/home/runner/work/echo/echo/echo/util/BodyOrBodies.hx" private="1" module="echo.util.BodyOrBodies" final="1">
		<from_body get="inline" set="null" line="8" static="1">
			<f a="a">
				<c path="echo.Body"/>
				<x path="echo.util.BodyOrBodies"/>
			</f>
			<meta><m n=":from"/></meta>
		</from_body>
		<from_bodies get="inline" set="null" line="12" static="1">
			<f a="b">
				<c path="Array"><c path="echo.Body"/></c>
				<x path="echo.util.BodyOrBodies"/>
			</f>
			<meta><m n=":from"/></meta>
		</from_bodies>
		<to_body get="inline" set="null" line="16" static="1">
			<f a="this">
				<e path="haxe.ds.Either">
					<c path="echo.Body"/>
					<c path="Array"><c path="echo.Body"/></c>
				</e>
				<x path="Null"><c path="echo.Body"/></x>
			</f>
			<meta><m n=":to"/></meta>
		</to_body>
		<to_bodies get="inline" set="null" line="21" static="1">
			<f a="this">
				<e path="haxe.ds.Either">
					<c path="echo.Body"/>
					<c path="Array"><c path="echo.Body"/></c>
				</e>
				<x path="Null"><c path="Array"><c path="echo.Body"/></c></x>
			</f>
			<meta><m n=":to"/></meta>
		</to_bodies>
	</class>
	<class path="echo.util.Debug" params="" file="/home/runner/work/echo/echo/echo/util/Debug.hx">
		<log public="1" set="method" line="36" static="1"><f a="world">
	<c path="echo.World"/>
	<x path="Void"/>
</f></log>
		<draw_bodies public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</draw_bodies>
		<draw_body_centers public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</draw_body_centers>
		<draw_bounds public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</draw_bounds>
		<draw_shape_bounds public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</draw_shape_bounds>
		<draw_world_bounds public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</draw_world_bounds>
		<draw_quadtree public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</draw_quadtree>
		<shape_outline_width public="1" expr="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</shape_outline_width>
		<shape_fill_alpha public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</shape_fill_alpha>
		<shape_color public="1"><x path="Int"/></shape_color>
		<shape_fill_color public="1"><x path="Int"/></shape_fill_color>
		<shape_collided_color public="1"><x path="Int"/></shape_collided_color>
		<intersection_color public="1"><x path="Int"/></intersection_color>
		<intersection_overlap_color public="1"><x path="Int"/></intersection_overlap_color>
		<quadtree_color public="1"><x path="Int"/></quadtree_color>
		<quadtree_fill_color public="1"><x path="Int"/></quadtree_fill_color>
		<world_bounds_color public="1"><x path="Int"/></world_bounds_color>
		<camera public="1"><x path="Null"><c path="echo.util.AABB"/></x></camera>
		<draw_line public="1" set="method" line="42">
			<f a="from_x:from_y:to_x:to_y:color:?alpha" v=":::::1">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ alpha : 1 }</e></m></meta>
		</draw_line>
		<draw_rect public="1" set="method" line="45">
			<f a="min_x:min_y:width:height:color:?stroke:?alpha" v="::::::1">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ alpha : 1 }</e></m></meta>
		</draw_rect>
		<draw_circle public="1" set="method" line="48">
			<f a="x:y:radius:color:?stroke:?alpha" v=":::::1">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ alpha : 1 }</e></m></meta>
		</draw_circle>
		<clear public="1" set="method" line="51"><f a=""><x path="Void"/></f></clear>
		<draw public="1" set="method" line="53">
			<f a="world:?clear_canvas" v=":true">
				<c path="echo.World"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ clear_canvas : true }</e></m></meta>
		</draw>
		<draw_shape public="1" set="method" line="79"><f a="shape">
	<c path="echo.Shape"/>
	<x path="Void"/>
</f></draw_shape>
		<draw_intersection public="1" set="method" line="116">
			<f a="intersection:?draw_overlap:?draw_normal" v=":true:true">
				<c path="echo.data.Intersection"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ draw_normal : true, draw_overlap : true }</e></m></meta>
		</draw_intersection>
		<draw_intersection_data public="1" set="method" line="124">
			<f a="data:?draw_overlap:?draw_normal" v=":true:true">
				<c path="echo.data.IntersectionData"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ draw_normal : true, draw_overlap : true }</e></m></meta>
		</draw_intersection_data>
		<draw_polygon public="1" set="method" line="134">
			<f a="count:vertices:color:?stroke:?alpha" v="::::1">
				<x path="Int"/>
				<c path="Array"><x path="echo.math.Vector2"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ alpha : 1 }</e></m></meta>
		</draw_polygon>
		<draw_bezier public="1" set="method" line="141">
			<f a="bezier:?draw_control_points:?draw_segment_markers:?draw_lines" v=":false:false:true">
				<c path="echo.util.Bezier"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ draw_lines : true, draw_segment_markers : false, draw_control_points : false }</e></m></meta>
		</draw_bezier>
		<draw_verlet public="1" set="method" line="184">
			<f a="verlet:?draw_dots:?draw_constraints" v=":true:true">
				<c path="echo.util.verlet.Verlet"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ draw_constraints : true, draw_dots : true }</e></m></meta>
		</draw_verlet>
		<draw_qd public="1" set="method" line="199"><f a="tree">
	<c path="echo.util.QuadTree"/>
	<x path="Void"/>
</f></draw_qd>
		<new public="1" set="method" line="14">
			<f a=""><x path="Void"/></f>
			<meta><m n=":compilerGenerated"/></meta>
		</new>
	</class>
	<class path="echo.util._Disposable.Disposable_Fields_" params="" file="/home/runner/work/echo/echo/echo/util/Disposable.hx" private="1" module="echo.util.Disposable" final="1">
		<dispose public="1" params="T" get="inline" set="null" line="13" static="1">
			<f a="object">
				<x path="Null"><c path="echo.util.Disposable"/></x>
				<c path="dispose.T"/>
			</f>
			<haxe_doc>* Checks if an object is not null before calling dispose(), always returns null.
 *
 * @param	object	An IDisposable object that will be disposed if it's not null.
 * @return	null</haxe_doc>
		</dispose>
		<dispose_array public="1" params="T" get="inline" set="null" line="25" static="1">
			<f a="array">
				<c path="Array"><c path="dispose_array.T"/></c>
				<c path="Array"><c path="dispose_array.T"/></c>
			</f>
			<haxe_doc>* dispose every element of an array of IDisposables
 *
 * @param	array	An Array of IDisposable objects
 * @return	null</haxe_doc>
		</dispose_array>
	</class>
	<class path="echo.util.History" params="T" file="/home/runner/work/echo/echo/echo/util/History.hx">
		<re><c path="echo.util.Ring"><c path="echo.util.History.T"/></c></re>
		<un><c path="echo.util.Ring"><c path="echo.util.History.T"/></c></un>
		<redo public="1" set="method" line="15"><f a=""><x path="Null"><c path="echo.util.History.T"/></x></f></redo>
		<undo public="1" set="method" line="21"><f a=""><x path="Null"><c path="echo.util.History.T"/></x></f></undo>
		<add public="1" set="method" line="27"><f a="v">
	<c path="echo.util.History.T"/>
	<x path="Void"/>
</f></add>
		<new public="1" set="method" line="10"><f a="len">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* History implementation from: https://code.haxe.org/category/data-structures/ring-array.html</haxe_doc>
		<meta><m n=":generic"/></meta>
	</class>
	<class path="echo.util.Ring" params="T" file="/home/runner/work/echo/echo/echo/util/History.hx" module="echo.util.History">
		<cap public="1" get="accessor" set="null"><x path="Int"/></cap>
		<get_cap get="inline" set="null" line="38"><f a=""><x path="Int"/></f></get_cap>
		<len public="1" get="accessor" set="null"><x path="Int"/></len>
		<get_len get="inline" set="null" line="42"><f a=""><x path="Int"/></f></get_len>
		<i><x path="Int"/></i>
		<start><x path="Int"/></start>
		<left><x path="Int"/></left>
		<a><x path="haxe.ds.Vector"><c path="echo.util.Ring.T"/></x></a>
		<pop public="1" set="method" line="54"><f a=""><x path="Null"><c path="echo.util.Ring.T"/></x></f></pop>
		<shift public="1" set="method" line="63"><f a=""><x path="Null"><c path="echo.util.Ring.T"/></x></f></shift>
		<push public="1" set="method" line="72"><f a="v">
	<c path="echo.util.Ring.T"/>
	<x path="Void"/>
</f></push>
		<reset public="1" set="method" line="82"><f a=""><x path="Void"/></f></reset>
		<remove public="1" set="method" line="88"><f a="v">
	<c path="echo.util.Ring.T"/>
	<x path="Void"/>
</f></remove>
		<toString public="1" get="inline" set="null" line="116"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="49"><f a="len">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* Fixed Ring Array Data Structure from: https://code.haxe.org/category/data-structures/ring-array.html</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":generic"/>
		</meta>
	</class>
	<class path="echo.util.JSON" params="" file="/home/runner/work/echo/echo/echo/util/JSON.hx">
		<copy_fields public="1" params="T" set="method" line="17" static="1">
			<f a="from:into">
				<c path="copy_fields.T"/>
				<c path="copy_fields.T"/>
				<c path="copy_fields.T"/>
			</f>
			<haxe_doc>* Copy an object's fields into target object. Overwrites the target object's fields.
   * Can work with Static Classes as well (as destination)
   *
   * Adapted from the DJFlixel Library: https://github.com/johndimi/djFlixel
   *
   * @param	from The Master object to copy fields from
   * @param	into The Target object to copy fields to
   * @return	The resulting object</haxe_doc>
		</copy_fields>
		<haxe_doc>* Class to provide different Utilities for dealing with Object Data</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="echo.util.IPooled" params="" file="/home/runner/work/echo/echo/echo/util/Poolable.hx" module="echo.util.Poolable">
		<c path="echo.util.Poolable"/>
		<meta><m n=":deprecated"><e>"`IPooled` renamed to `IPoolable."</e></m></meta>
	</typedef>
	<class path="echo.util.GenericPool" params="T" file="/home/runner/work/echo/echo/echo/util/Poolable.hx" module="echo.util.Poolable">
		<implements path="echo.util.Pool"><c path="echo.util.GenericPool.T"/></implements>
		<length public="1" get="accessor" set="null"><x path="Int"/></length>
		<members><c path="Array"><c path="echo.util.GenericPool.T"/></c></members>
		<type><x path="Class"><c path="echo.util.GenericPool.T"/></x></type>
		<count><x path="Int"/></count>
		<get public="1" set="method" line="43"><f a=""><c path="echo.util.GenericPool.T"/></f></get>
		<put public="1" set="method" line="48"><f a="obj">
	<c path="echo.util.GenericPool.T"/>
	<x path="Void"/>
</f></put>
		<put_unsafe public="1" set="method" line="58"><f a="obj">
	<c path="echo.util.GenericPool.T"/>
	<x path="Void"/>
</f></put_unsafe>
		<pre_allocate public="1" set="method" line="64"><f a="amount">
	<x path="Int"/>
	<x path="Void"/>
</f></pre_allocate>
		<clear public="1" set="method" line="68"><f a=""><c path="Array"><c path="echo.util.GenericPool.T"/></c></f></clear>
		<get_length public="1" set="method" line="75"><f a=""><x path="Int"/></f></get_length>
		<new public="1" set="method" line="37"><f a="type">
	<x path="Class"><c path="echo.util.GenericPool.T"/></x>
	<x path="Void"/>
</f></new>
		<haxe_doc>* Generic Pooling container</haxe_doc>
		<meta><m n=":generic"/></meta>
	</class>
	<class path="echo.util.PoolableMacros" params="" file="/home/runner/work/echo/echo/echo/util/Poolable.hx" module="echo.util.Poolable"/>
	<typedef path="echo.util.IProxy" params="" file="/home/runner/work/echo/echo/echo/util/Proxy.hx" module="echo.util.Proxy">
		<c path="echo.util.Proxy"/>
		<meta><m n=":deprecated"><e>"`IProxy` renamed to `Proxy`"</e></m></meta>
	</typedef>
	<class path="echo.util.ProxyMacros" params="" file="/home/runner/work/echo/echo/echo/util/Proxy.hx" module="echo.util.Proxy"/>
	<class path="echo.util.QuadTree" params="" file="/home/runner/work/echo/echo/echo/util/QuadTree.hx">
		<extends path="echo.util.AABB"/>
		<get public="1" get="inline" set="null" line="63" static="1">
			<f a="?x:?y:?width:?height" v="0:0:1:1">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="echo.util.QuadTree"/>
			</f>
			<meta><m n=":value"><e>{ height : 1, width : 1, y : 0, x : 0 }</e></m></meta>
			<haxe_doc>* Gets an Quadtree from the pool, or creates a new one if none are available. Call `put()` on the Quadtree to place it back in the pool.
   *
   * Note - The X and Y positions represent the center of the Quadtree. To set the Quadtree from its Top-Left origin, `Quadtree.get_from_min_max()` is available.
   * @param x The centered X position of the Quadtree.
   * @param y The centered Y position of the Quadtree.
   * @param width The width of the Quadtree.
   * @param height The height of the Quadtree.
   * @return Quadtree</haxe_doc>
		</get>
		<get_from_min_max public="1" get="inline" set="null" line="78" static="1">
			<f a="min_x:min_y:max_x:max_y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="echo.util.QuadTree"/>
			</f>
			<haxe_doc>* Gets an Quadtree from the pool, or creates a new one if none are available. Call `put()` on the Quadtree to place it back in the pool.
   * @param min_x
   * @param min_y
   * @param max_x
   * @param max_y
   * @return Quadtree</haxe_doc>
		</get_from_min_max>
		<pool expr="new echo.util.Poolable.GenericPool&lt;echo.util.QuadTree&gt;(echo.util.QuadTree)" line="89" static="1">
			<c path="echo.util.GenericPool_echo_util_QuadTree"/>
			<meta><m n=":value"><e><![CDATA[new echo.util.Poolable.GenericPool<echo.util.QuadTree>(echo.util.QuadTree)]]></e></m></meta>
		</pool>
		<get_pool public="1" set="method" line="97" static="1"><f a=""><c path="echo.util.Pool"><c path="echo.util.QuadTree"/></c></f></get_pool>
		<max_depth public="1" set="accessor" expr="5">
			<x path="Int"/>
			<meta><m n=":value"><e>5</e></m></meta>
			<haxe_doc>* The maximum branch depth for this QuadTree collection. Once the max depth is reached, the QuadTrees at the end of the collection will not spilt.</haxe_doc>
		</max_depth>
		<max_contents public="1" set="accessor" expr="10">
			<x path="Int"/>
			<meta><m n=":value"><e>10</e></m></meta>
			<haxe_doc>* The maximum amount of `QuadTreeData` contents that a QuadTree `leaf` can hold before becoming a branch and splitting it's contents between children Quadtrees.</haxe_doc>
		</max_contents>
		<children public="1">
			<x path="haxe.ds.Vector"><c path="echo.util.QuadTree"/></x>
			<haxe_doc>* The child QuadTrees contained in the Quadtree. If this Vector is empty, the Quadtree is regarded as a `leaf`.</haxe_doc>
		</children>
		<contents public="1">
			<c path="Array"><c path="echo.data.QuadTreeData"/></c>
			<haxe_doc>* The QuadTreeData contained in the Quadtree. If the Quadtree is not a `leaf`, all of it's contents will be dispersed to it's children QuadTrees (leaving this aryar emyty).</haxe_doc>
		</contents>
		<count public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* Gets the total amount of `QuadTreeData` contents in the Quadtree, recursively. To get the non-recursive amount, check `quadtree.contents_count`.</haxe_doc>
		</count>
		<contents_count public="1"><x path="Int"/></contents_count>
		<leaf public="1" get="accessor" set="null">
			<x path="Bool"/>
			<haxe_doc>* A QuadTree is regarded as a `leaf` if it has **no** QuadTree children (ie `quadtree.children.length == 0`).</haxe_doc>
		</leaf>
		<depth public="1">
			<x path="Int"/>
			<haxe_doc>* The QuadTree's branch position in it's collection.</haxe_doc>
		</depth>
		<nodes_list expr="[]">
			<c path="Array"><c path="echo.util.QuadTree"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
			<haxe_doc>* Cache'd list of QuadTrees used to help with memory management.</haxe_doc>
		</nodes_list>
		<put public="1" get="inline" set="null" line="88" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Puts the QuadTree back in the pool of available QuadTrees.</haxe_doc>
		</put>
		<insert public="1" set="method" line="99">
			<f a="data">
				<c path="echo.data.QuadTreeData"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Attempts to insert the `QuadTreeData` into the QuadTree. If the `QuadTreeData` already exists in the QuadTree, use `quadtree.update(data)` instead.</haxe_doc>
		</insert>
		<remove public="1" set="method" line="118">
			<f a="data:?allow_shake" v=":true">
				<c path="echo.data.QuadTreeData"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ allow_shake : true }</e></m></meta>
			<haxe_doc>* Attempts to remove the `QuadTreeData` from the QuadTree.</haxe_doc>
		</remove>
		<update public="1" set="method" line="143">
			<f a="data:?allow_shake" v=":true">
				<c path="echo.data.QuadTreeData"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ allow_shake : true }</e></m></meta>
			<haxe_doc>* Updates the `QuadTreeData` in the QuadTree by first removing the `QuadTreeData` from the QuadTree, then inserting it.
   * @param data</haxe_doc>
		</update>
		<query public="1" set="method" line="152">
			<f a="aabb:result">
				<c path="echo.util.AABB"/>
				<c path="Array"><c path="echo.data.QuadTreeData"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>* Queries the QuadTree for any `QuadTreeData` that overlaps the `AABB`.
   * @param aabb The `AABB` to query.
   * @param result An Array containing all `QuadTreeData` that collides with the shape.</haxe_doc>
		</query>
		<shake public="1" set="method" line="169">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* If the QuadTree is a branch (_not_ a `leaf`), this will check if the amount of data from all the child Quadtrees can fit in the Quadtree without exceeding it's `max_contents`.
   * If all the data can fit, the Quadtree branch will "shake" its child Quadtrees, absorbing all the data and clearing the children (putting all the child Quadtrees back in the pool).
   *
   * Note - This works recursively.</haxe_doc>
		</shake>
		<split set="method" line="200">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Splits the Quadtree into 4 Quadtree children, and disperses it's `QuadTreeData` contents into them.</haxe_doc>
		</split>
		<clear public="1" get="inline" set="null" line="230">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clears the Quadtree's `QuadTreeData` contents and all children Quadtrees.</haxe_doc>
		</clear>
		<clear_children get="inline" set="null" line="237">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Puts all of the Quadtree's children back in the pool and clears the `children` Array.</haxe_doc>
		</clear_children>
		<clear_contents get="inline" set="null" line="247"><f a=""><x path="Void"/></f></clear_contents>
		<reset_data_flags set="method" line="254">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Resets the `flag` value of the QuadTree's `QuadTreeData` contents.</haxe_doc>
		</reset_data_flags>
		<get_count set="method" line="261"><f a=""><x path="Int"/></f></get_count>
		<get_first_null set="method" line="296"><f a="arr">
	<c path="Array"><c path="echo.data.QuadTreeData"/></c>
	<x path="Int"/>
</f></get_first_null>
		<get_leaf get="inline" set="null" line="301"><f a=""><x path="Bool"/></f></get_leaf>
		<set_max_depth get="inline" set="null" line="305"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_max_depth>
		<set_max_contents get="inline" set="null" line="310"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_max_contents>
		<new set="method" line="45">
			<f a="?aabb:?depth" v=":0">
				<c path="echo.util.AABB"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ depth : 0 }</e></m></meta>
		</new>
		<haxe_doc>* Simple QuadTree implementation to assist with broad-phase 2D collisions.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>echo.util.PoolableMacros.build()</e></m>
			<m n=":autoBuild"><e>echo.util.PoolableMacros.build()</e></m>
		</meta>
	</class>
	<class path="echo.util.SAT" params="" file="/home/runner/work/echo/echo/echo/util/SAT.hx">
		<norm final="1" set="null" expr="new Vector2(0, 0)" line="13" static="1">
			<x path="echo.math.Vector2"/>
			<meta><m n=":value"><e>new Vector2(0, 0)</e></m></meta>
		</norm>
		<closest final="1" set="null" expr="new Vector2(0, 0)" line="14" static="1">
			<x path="echo.math.Vector2"/>
			<meta><m n=":value"><e>new Vector2(0, 0)</e></m></meta>
		</closest>
		<point_in_rect public="1" get="inline" set="null" line="16" static="1"><f a="p:r">
	<x path="echo.math.Vector2"/>
	<c path="echo.shape.Rect"/>
	<x path="Bool"/>
</f></point_in_rect>
		<point_in_circle public="1" get="inline" set="null" line="21" static="1"><f a="p:c">
	<x path="echo.math.Vector2"/>
	<c path="echo.shape.Circle"/>
	<x path="Bool"/>
</f></point_in_circle>
		<point_in_polygon public="1" get="inline" set="null" line="25" static="1"><f a="point:polygon">
	<x path="echo.math.Vector2"/>
	<c path="echo.shape.Polygon"/>
	<x path="Bool"/>
</f></point_in_polygon>
		<rect_contains public="1" get="inline" set="null" line="39" static="1"><f a="r:v">
	<c path="echo.shape.Rect"/>
	<x path="echo.math.Vector2"/>
	<x path="Bool"/>
</f></rect_contains>
		<circle_contains public="1" get="inline" set="null" line="43" static="1"><f a="c:v">
	<c path="echo.shape.Circle"/>
	<x path="echo.math.Vector2"/>
	<x path="Bool"/>
</f></circle_contains>
		<polygon_contains public="1" get="inline" set="null" line="47" static="1"><f a="p:v">
	<c path="echo.shape.Polygon"/>
	<x path="echo.math.Vector2"/>
	<x path="Bool"/>
</f></polygon_contains>
		<line_intersects_line public="1" get="inline" set="null" line="51" static="1"><f a="line1:line2">
	<c path="echo.Line"/>
	<c path="echo.Line"/>
	<x path="Null"><c path="echo.data.IntersectionData"/></x>
</f></line_intersects_line>
		<line_intersects_rect public="1" set="method" line="73" static="1"><f a="l:r">
	<c path="echo.Line"/>
	<c path="echo.shape.Rect"/>
	<x path="Null"><c path="echo.data.IntersectionData"/></x>
</f></line_intersects_rect>
		<line_intersects_circle public="1" set="method" line="106" static="1"><f a="l:c">
	<c path="echo.Line"/>
	<c path="echo.shape.Circle"/>
	<x path="Null"><c path="echo.data.IntersectionData"/></x>
</f></line_intersects_circle>
		<line_intersects_polygon public="1" set="method" line="153" static="1"><f a="l:p">
	<c path="echo.Line"/>
	<c path="echo.shape.Polygon"/>
	<x path="Null"><c path="echo.data.IntersectionData"/></x>
</f></line_intersects_polygon>
		<rect_intersects public="1" get="inline" set="null" line="171" static="1"><f a="r:l">
	<c path="echo.shape.Rect"/>
	<c path="echo.Line"/>
	<x path="Null"><c path="echo.data.IntersectionData"/></x>
</f></rect_intersects>
		<circle_intersects public="1" get="inline" set="null" line="175" static="1"><f a="c:l">
	<c path="echo.shape.Circle"/>
	<c path="echo.Line"/>
	<x path="Null"><c path="echo.data.IntersectionData"/></x>
</f></circle_intersects>
		<polygon_intersects public="1" get="inline" set="null" line="179" static="1"><f a="p:l">
	<c path="echo.shape.Polygon"/>
	<c path="echo.Line"/>
	<x path="Null"><c path="echo.data.IntersectionData"/></x>
</f></polygon_intersects>
		<rect_and_rect public="1" set="method" line="189" static="1">
			<f a="rect1:rect2:?flip" v="::false">
				<c path="echo.shape.Rect"/>
				<c path="echo.shape.Rect"/>
				<x path="Bool"/>
				<x path="Null"><c path="echo.data.CollisionData"/></x>
			</f>
			<meta><m n=":value"><e>{ flip : false }</e></m></meta>
			<haxe_doc><![CDATA[* Test two Rects for a Collision.
   * @param rect1
   * @param rect2
   * @param flip
   * @return Null<CollisionData>]]></haxe_doc>
		</rect_and_rect>
		<circle_and_circle public="1" set="method" line="253" static="1">
			<f a="circle1:circle2:?flip" v="::false">
				<c path="echo.shape.Circle"/>
				<c path="echo.shape.Circle"/>
				<x path="Bool"/>
				<x path="Null"><c path="echo.data.CollisionData"/></x>
			</f>
			<meta><m n=":value"><e>{ flip : false }</e></m></meta>
			<haxe_doc><![CDATA[* Test two Circles for a Collision.
   * @param circle1
   * @param circle2
   * @param flip
   * @return Null<CollisionData>]]></haxe_doc>
		</circle_and_circle>
		<polygon_and_polygon public="1" set="method" line="294" static="1">
			<f a="polygon1:polygon2:?flip" v="::false">
				<c path="echo.shape.Polygon"/>
				<c path="echo.shape.Polygon"/>
				<x path="Bool"/>
				<x path="Null"><c path="echo.data.CollisionData"/></x>
			</f>
			<meta><m n=":value"><e>{ flip : false }</e></m></meta>
			<haxe_doc><![CDATA[* Test two Polygons for a Collision. Implementation ported from the [differ](https://github.com/snowkit/differ/blob/master/differ/sat/SAT2D.hx#L191) library.
   * @param polygon1
   * @param polygon2
   * @param flip
   * @return Null<CollisionData>]]></haxe_doc>
		</polygon_and_polygon>
		<rect_and_circle public="1" set="method" line="328" static="1">
			<f a="r:c:?flip" v="::false">
				<c path="echo.shape.Rect"/>
				<c path="echo.shape.Circle"/>
				<x path="Bool"/>
				<x path="Null"><c path="echo.data.CollisionData"/></x>
			</f>
			<meta><m n=":value"><e>{ flip : false }</e></m></meta>
			<haxe_doc><![CDATA[* Test a Rect and a Circle for a Collision.
   * @param r
   * @param c
   * @param flip
   * @return Null<CollisionData>]]></haxe_doc>
		</rect_and_circle>
		<rect_and_polygon public="1" set="method" line="395" static="1">
			<f a="r:p:?flip" v="::false">
				<c path="echo.shape.Rect"/>
				<c path="echo.shape.Polygon"/>
				<x path="Bool"/>
				<x path="Null"><c path="echo.data.CollisionData"/></x>
			</f>
			<meta><m n=":value"><e>{ flip : false }</e></m></meta>
		</rect_and_polygon>
		<circle_and_polygon public="1" set="method" line="422" static="1">
			<f a="c:p:?flip" v="::false">
				<c path="echo.shape.Circle"/>
				<c path="echo.shape.Polygon"/>
				<x path="Bool"/>
				<x path="Null"><c path="echo.data.CollisionData"/></x>
			</f>
			<meta><m n=":value"><e>{ flip : false }</e></m></meta>
			<haxe_doc><![CDATA[* Test a Circle and a Polygon for a Collision. Implementation ported from the [differ](https://github.com/snowkit/differ/blob/master/differ/sat/SAT2D.hx#L13) library.
   * @param c
   * @param p
   * @param flip
   * @return Null<CollisionData>]]></haxe_doc>
		</circle_and_polygon>
		<check_polygons set="method" line="528" static="1">
			<f a="polygon1:polygon2:?flip" v="::false">
				<c path="echo.shape.Polygon"/>
				<c path="echo.shape.Polygon"/>
				<x path="Bool"/>
				<x path="Null"><c path="echo.data.CollisionData"/></x>
			</f>
			<meta><m n=":value"><e>{ flip : false }</e></m></meta>
		</check_polygons>
		<haxe_doc>* Class containing methods to perform collision checks using the Separating Axis Thereom</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="echo.util.TileShape" params="" file="/home/runner/work/echo/echo/echo/util/TileMap.hx" module="echo.util.TileMap"><a>
	<slope_shape>
		<x path="Null"><a>
	<size><e path="echo.util.SlopeSize"/></size>
	<angle><e path="echo.util.SlopeAngle"/></angle>
</a></x>
		<meta><m n=":optional"/></meta>
	</slope_shape>
	<slope_direction>
		<x path="Null"><e path="echo.util.SlopeDirection"/></x>
		<meta><m n=":optional"/></meta>
	</slope_direction>
	<index><x path="Int"/></index>
	<custom_shape>
		<x path="Null"><t path="echo.data.ShapeOptions"/></x>
		<meta><m n=":optional"/></meta>
	</custom_shape>
</a></typedef>
	<enum path="echo.util.SlopeDirection" params="" file="/home/runner/work/echo/echo/echo/util/TileMap.hx" module="echo.util.TileMap">
		<TopLeft/>
		<TopRight/>
		<BottomLeft/>
		<BottomRight/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<enum path="echo.util.SlopeAngle" params="" file="/home/runner/work/echo/echo/echo/util/TileMap.hx" module="echo.util.TileMap">
		<Gentle/>
		<Sharp/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<enum path="echo.util.SlopeSize" params="" file="/home/runner/work/echo/echo/echo/util/TileMap.hx" module="echo.util.TileMap">
		<Thick/>
		<Thin/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<class path="echo.util.TileMap" params="" file="/home/runner/work/echo/echo/echo/util/TileMap.hx">
		<generate public="1" set="method" line="46" static="1">
			<f a="data:tile_width:tile_height:width_in_tiles:height_in_tiles:?offset_x:?offset_y:?start_index:?shapes:?ignore:?material" v=":::::0:0:1:::">
				<c path="Array"><x path="Int"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<c path="Array"><t path="echo.util.TileShape"/></c>
				<c path="Array"><x path="Int"/></c>
				<c path="echo.Material"/>
				<c path="Array"><c path="echo.Body"/></c>
			</f>
			<meta><m n=":value"><e>{ start_index : 1, offset_y : 0, offset_x : 0 }</e></m></meta>
			<haxe_doc><![CDATA[* Generates an optimized Array of Bodies from an Array of `Int`s representing a TileMap.
   * @param data The Array of `Int`s that make up the TileMap
   * @param tile_width The Width of each Tile in the TileMap
   * @param tile_height The Height of each Tile in the TileMap
   * @param width_in_tiles The Width of the TileMap (Measured in Tiles)
   * @param height_in_tiles The Height of the TileMap (Measured in Tiles)
   * @param offset_x The Offset applied to the X Position of each generated Body
   * @param offset_y The Offset applied to the Y Position of each generated Body
   * @param start_index The Index that designates which tiles are collidable. Must be larger than -1.
   * @return Array<Body>]]></haxe_doc>
		</generate>
		<generate_grid public="1" set="method" line="321" static="1">
			<f a="data:tile_width:tile_height:width_in_tiles:height_in_tiles:?offset_x:?offset_y:?start_index:?material" v=":::::0:0:1:">
				<c path="Array"><x path="Int"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<c path="echo.Material"/>
				<c path="Array"><c path="echo.Body"/></c>
			</f>
			<meta><m n=":value"><e>{ start_index : 1, offset_y : 0, offset_x : 0 }</e></m></meta>
			<haxe_doc><![CDATA[* Generates an Array of Bodies from an Array of `Int`s representing a TileMap.
   * @param data The Array of `Int`s that make up the TileMap
   * @param tile_width The Width of each Tile in the TileMap
   * @param tile_height The Height of each Tile in the TileMap
   * @param width_in_tiles The Width of the TileMap (Measured in Tiles)
   * @param height_in_tiles The Height of the TileMap (Measured in Tiles)
   * @param offset_x The Offset applied to the X Position of each generated Body
   * @param offset_y The Offset applied to the Y Position of each generated Body
   * @param start_index The Index that designates which tiles are collidable
   * @return Array<Body>]]></haxe_doc>
		</generate_grid>
	</class>
	<class path="echo.util.Transform" params="" file="/home/runner/work/echo/echo/echo/util/Transform.hx">
		<implements path="echo.util.Disposable"/>
		<translate public="1" get="inline" set="null" line="86" static="1">
			<f a="x:y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="echo.math.Matrix3"/>
			</f>
			<haxe_doc>* Gets the translated `Matrix3 representing the defined `x` and `y`.</haxe_doc>
		</translate>
		<rotate public="1" get="inline" set="null" line="92" static="1">
			<f a="radians">
				<x path="Float"/>
				<x path="echo.math.Matrix3"/>
			</f>
			<haxe_doc>* Gets the rotated `Matrix3` representing the defined `radians`.</haxe_doc>
		</rotate>
		<scale public="1" get="inline" set="null" line="100" static="1">
			<f a="scale_x:scale_y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="echo.math.Matrix3"/>
			</f>
			<haxe_doc>* Gets the scaled `Matrix3` representing the defined `scale_x` and `scale_y`.</haxe_doc>
		</scale>
		<multiply_transposed_matrix public="1" get="inline" set="null" line="117" static="1">
			<f a="v:a">
				<x path="echo.math.Vector3"/>
				<x path="echo.math.Matrix3"/>
				<x path="echo.math.Vector3"/>
			</f>
			<meta><m n=":op"><e>A * B</e></m></meta>
			<haxe_doc>* Multiplies the `Vector3` by a transposed form of the `Matrix3`.
   *
   * Transposed form:
   * ```
   * vec3.x = m00 * x, m01 * y, m02 * z
   * vec3.y = m10 * x, m11 * y, m12 * z
   * vec3.z = m20 * x, m21 * y, m22 * z
   * ```
   * @param v
   * @param a
   * @return Vector3</haxe_doc>
		</multiply_transposed_matrix>
		<x public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc>* The Transform's position on the X axis in world coordinates.</haxe_doc>
		</x>
		<y public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc>* The Transform's position on the Y axis in world coordinates.</haxe_doc>
		</y>
		<rotation public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc>* The Transform's rotation (as degrees) in world coordinates.</haxe_doc>
		</rotation>
		<radians public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc>* The Transform's rotation in world coordinates.</haxe_doc>
		</radians>
		<scale_x public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc>* The Transform's scale on the X axis in world coordinates.</haxe_doc>
		</scale_x>
		<scale_y public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc>* The Transform's scale on the Y axis in world coordinates.</haxe_doc>
		</scale_y>
		<local_x public="1" set="accessor">
			<x path="Float"/>
			<haxe_doc>* The Transform's position on the X axis in local coordinates.</haxe_doc>
		</local_x>
		<local_y public="1" set="accessor">
			<x path="Float"/>
			<haxe_doc>* The Transform's position on the Y axis in local coordinates.</haxe_doc>
		</local_y>
		<local_rotation public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc>* The Transform's rotation (as degrees) in local coordinates.</haxe_doc>
		</local_rotation>
		<local_radians public="1" set="accessor">
			<x path="Float"/>
			<haxe_doc>* The Transform's rotation in local coordinates.</haxe_doc>
		</local_radians>
		<local_scale_x public="1" set="accessor">
			<x path="Float"/>
			<haxe_doc>* The Transform's scale on the X axis in local coordinates.</haxe_doc>
		</local_scale_x>
		<local_scale_y public="1" set="accessor">
			<x path="Float"/>
			<haxe_doc>* The Transform's scale on the Y axis in local coordinates.</haxe_doc>
		</local_scale_y>
		<up public="1" get="accessor" set="null"><x path="echo.math.Vector2"/></up>
		<down public="1" get="accessor" set="null"><x path="echo.math.Vector2"/></down>
		<right public="1" get="accessor" set="null"><x path="echo.math.Vector2"/></right>
		<left public="1" get="accessor" set="null"><x path="echo.math.Vector2"/></left>
		<on_dirty public="1" expr="null">
			<f a="">
				<c path="echo.util.Transform"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* Optional callback method that gets called when the Transform is set as dirty.</haxe_doc>
		</on_dirty>
		<_x expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_x>
		<_y expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_y>
		<_radians expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_radians>
		<_scale_x expr="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</_scale_x>
		<_scale_y expr="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</_scale_y>
		<parent><x path="Null"><c path="echo.util.Transform"/></x></parent>
		<children expr="[]">
			<c path="Array"><c path="echo.util.Transform"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</children>
		<local_to_world_matrix expr="Matrix3.identity">
			<x path="echo.math.Matrix3"/>
			<meta><m n=":value"><e>Matrix3.identity</e></m></meta>
		</local_to_world_matrix>
		<world_to_local_matrix expr="Matrix3.identity">
			<x path="echo.math.Matrix3"/>
			<meta><m n=":value"><e>Matrix3.identity</e></m></meta>
		</world_to_local_matrix>
		<dirty expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</dirty>
		<inverse_dirty expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</inverse_dirty>
		<coordinates_dirty expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</coordinates_dirty>
		<get_parent public="1" get="inline" set="null" line="137">
			<f a=""><x path="Null"><c path="echo.util.Transform"/></x></f>
			<haxe_doc>* Gets this Transform's parent Transform, if it has one.</haxe_doc>
		</get_parent>
		<set_parent public="1" set="method" line="148">
			<f a="parent:?preserve_world_transform" v=":false">
				<x path="Null"><c path="echo.util.Transform"/></x>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ preserve_world_transform : false }</e></m></meta>
			<haxe_doc>* Sets this Transform's parent.
   *
   * TODO - implement `preserve_world_transform` arguement.
   *
   * @param parent
   * @param preserve_world_transform</haxe_doc>
		</set_parent>
		<get_local_matrix public="1" get="inline" set="null" line="167">
			<f a=""><x path="echo.math.Matrix3"/></f>
			<haxe_doc>* Gets the Matrix representing the local coordinates' transformation.
   * @return Matrix3</haxe_doc>
		</get_local_matrix>
		<get_local_to_world_matrix public="1" set="method" line="177">
			<f a=""><x path="echo.math.Matrix3"/></f>
			<haxe_doc>* Gets the Matrix that converts from local coordinates to world coordinates.
   * @return Matrix3</haxe_doc>
		</get_local_to_world_matrix>
		<get_world_to_local_matrix public="1" set="method" line="188">
			<f a=""><x path="echo.math.Matrix3"/></f>
			<haxe_doc>* Gets the Inversed Matrix based on the `local_to_world_matrix`.</haxe_doc>
		</get_world_to_local_matrix>
		<point_to_world public="1" get="inline" set="null" line="235">
			<f a="?x:?y" v="0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="echo.math.Vector2"/>
			</f>
			<meta><m n=":value"><e>{ y : 0, x : 0 }</e></m></meta>
			<haxe_doc>* Transforms a point from local coordinates to world coordinates.
   * @param x
   * @param y
   * @return Vector2</haxe_doc>
		</point_to_world>
		<point_to_local public="1" get="inline" set="null" line="245">
			<f a="?x:?y" v="0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="echo.math.Vector2"/>
			</f>
			<meta><m n=":value"><e>{ y : 0, x : 0 }</e></m></meta>
			<haxe_doc>* Transforms a point from world coordinates to local coordinates.
   * @param x
   * @param y
   * @return Vector2</haxe_doc>
		</point_to_local>
		<direction_to_world public="1" get="inline" set="null" line="255">
			<f a="?x:?y" v="1:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="echo.math.Vector2"/>
			</f>
			<meta><m n=":value"><e>{ y : 0, x : 1 }</e></m></meta>
			<haxe_doc>* Transforms a direction vector from local coordinates to world coordinates.
   * @param x
   * @param y
   * @return Vector2</haxe_doc>
		</direction_to_world>
		<direction_to_local public="1" get="inline" set="null" line="265">
			<f a="?x:?y" v="1:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="echo.math.Vector2"/>
			</f>
			<meta><m n=":value"><e>{ y : 0, x : 1 }</e></m></meta>
			<haxe_doc>* Transforms a direction vector from world coordinates to local coordinates.
   * @param x
   * @param y
   * @return Vector2</haxe_doc>
		</direction_to_local>
		<rotation_to_world public="1" get="inline" set="null" line="274">
			<f a="?degrees" v="0">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>{ degrees : 0 }</e></m></meta>
			<haxe_doc>* Transforms an angle (in degrees) from local rotation to world rotation.
   * @param degrees
   * @return Float</haxe_doc>
		</rotation_to_world>
		<rotation_to_local public="1" get="inline" set="null" line="284">
			<f a="?degrees" v="0">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>{ degrees : 0 }</e></m></meta>
			<haxe_doc>* Transforms an angle (in degrees) from world rotation to local rotation.
   * @param degrees
   * @return Float</haxe_doc>
		</rotation_to_local>
		<scale_to_world public="1" get="inline" set="null" line="295">
			<f a="?scale_x:?scale_y" v="0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="echo.math.Vector2"/>
			</f>
			<meta><m n=":value"><e>{ scale_y : 0, scale_x : 0 }</e></m></meta>
			<haxe_doc>* Transforms a scale vector from local coordinates to world coordinates.
   * @param scale_x
   * @param scale_y
   * @return Vector2</haxe_doc>
		</scale_to_world>
		<scale_to_local public="1" get="inline" set="null" line="305">
			<f a="?scale_x:?scale_y" v="0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="echo.math.Vector2"/>
			</f>
			<meta><m n=":value"><e>{ scale_y : 0, scale_x : 0 }</e></m></meta>
			<haxe_doc>* Transforms a scale vector from world coordinates to local coordinates.
   * @param scale_x
   * @param scale_y
   * @return Vector2</haxe_doc>
		</scale_to_local>
		<get_position public="1" get="inline" set="null" line="312">
			<f a=""><x path="echo.math.Vector2"/></f>
			<haxe_doc>* Gets the Transform's position in world coordinates.</haxe_doc>
		</get_position>
		<set_position public="1" get="inline" set="null" line="320">
			<f a="position">
				<x path="echo.math.Vector2"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets the Transform's position from world coordinates.
   * @param position</haxe_doc>
		</set_position>
		<set_xy public="1" get="inline" set="null" line="325">
			<f a="?x:?y" v="0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ y : 0, x : 0 }</e></m></meta>
		</set_xy>
		<get_scale public="1" get="inline" set="null" line="332">
			<f a=""><x path="echo.math.Vector2"/></f>
			<haxe_doc>* Gets the Transform's scale in world coordinates.</haxe_doc>
		</get_scale>
		<set_scale public="1" get="inline" set="null" line="340">
			<f a="scale">
				<x path="echo.math.Vector2"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets the Transform's scale from world coordinates.
   * @param scale</haxe_doc>
		</set_scale>
		<set_scale_xy public="1" get="inline" set="null" line="345">
			<f a="?x:?y" v="0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ y : 0, x : 0 }</e></m></meta>
		</set_scale_xy>
		<get_local_position public="1" get="inline" set="null" line="352">
			<f a=""><x path="echo.math.Vector2"/></f>
			<haxe_doc>* Gets the Transform's position in local coordinates.</haxe_doc>
		</get_local_position>
		<set_local_position public="1" get="inline" set="null" line="359">
			<f a="position">
				<x path="echo.math.Vector2"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets the Transform's position from local coordinates.
   * @param position</haxe_doc>
		</set_local_position>
		<set_local_xy public="1" get="inline" set="null" line="364">
			<f a="?x:?y" v="0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ y : 0, x : 0 }</e></m></meta>
		</set_local_xy>
		<get_local_scale public="1" get="inline" set="null" line="371">
			<f a=""><x path="echo.math.Vector2"/></f>
			<haxe_doc>* Gets the Transform's scale in local coordinates.</haxe_doc>
		</get_local_scale>
		<set_local_scale_xy public="1" get="inline" set="null" line="375">
			<f a="?x:?y" v="0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ y : 0, x : 0 }</e></m></meta>
		</set_local_scale_xy>
		<set_local_scale public="1" set="method" line="383">
			<f a="scale">
				<x path="echo.math.Vector2"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets the Transform's scale from local coordinates.
   * @param scale</haxe_doc>
		</set_local_scale>
		<dispose public="1" set="method" line="390">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Disposes the Transform. DO NOT use the Transform after disposing it, as it could lead to null reference errors.</haxe_doc>
		</dispose>
		<sync set="method" line="401">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* If the Transform is dirty, the Transform's world coordinates are updated.</haxe_doc>
		</sync>
		<set_dirty public="1" set="method" line="429"><f a=""><x path="Void"/></f></set_dirty>
		<try_set_dirty get="inline" set="null" line="436">
			<f a="?force" v="false">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ force : false }</e></m></meta>
		</try_set_dirty>
		<get_x get="inline" set="null" line="440"><f a=""><x path="Float"/></f></get_x>
		<get_y get="inline" set="null" line="446"><f a=""><x path="Float"/></f></get_y>
		<get_rotation get="inline" set="null" line="452"><f a=""><x path="Float"/></f></get_rotation>
		<get_radians get="inline" set="null" line="458"><f a=""><x path="Float"/></f></get_radians>
		<get_scale_x get="inline" set="null" line="464"><f a=""><x path="Float"/></f></get_scale_x>
		<get_scale_y get="inline" set="null" line="470"><f a=""><x path="Float"/></f></get_scale_y>
		<get_local_rotation get="inline" set="null" line="476"><f a=""><x path="Float"/></f></get_local_rotation>
		<get_right get="inline" set="null" line="480"><f a=""><x path="echo.math.Vector2"/></f></get_right>
		<get_left get="inline" set="null" line="484"><f a=""><x path="echo.math.Vector2"/></f></get_left>
		<get_up get="inline" set="null" line="488"><f a=""><x path="echo.math.Vector2"/></f></get_up>
		<get_down get="inline" set="null" line="492"><f a=""><x path="echo.math.Vector2"/></f></get_down>
		<set_x get="inline" set="null" line="496"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_x>
		<set_y get="inline" set="null" line="502"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_y>
		<set_rotation get="inline" set="null" line="508"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_rotation>
		<set_radians get="inline" set="null" line="514"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_radians>
		<set_scale_x get="inline" set="null" line="520"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_scale_x>
		<set_scale_y get="inline" set="null" line="526"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_scale_y>
		<set_local_x get="inline" set="null" line="532"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_local_x>
		<set_local_y get="inline" set="null" line="537"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_local_y>
		<set_local_rotation get="inline" set="null" line="542"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_local_rotation>
		<set_local_radians get="inline" set="null" line="546"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_local_radians>
		<set_local_scale_x get="inline" set="null" line="551"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_local_scale_x>
		<set_local_scale_y get="inline" set="null" line="556"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_local_scale_y>
		<new public="1" set="method" line="127">
			<f a="?x:?y:?rotation:?scale_x:?scale_y" v="0:0:0:1:1">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ scale_y : 1, scale_x : 1, rotation : 0, y : 0, x : 0 }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="echo.util.ext._ArrayExt.ArrayExt_Fields_" params="" file="/home/runner/work/echo/echo/echo/util/ext/ArrayExt.hx" private="1" module="echo.util.ext.ArrayExt" final="1"><dispose_bodies public="1" get="inline" set="null" line="3" static="1"><f a="arr">
	<c path="Array"><c path="echo.Body"/></c>
	<c path="Array"><c path="echo.Body"/></c>
</f></dispose_bodies></class>
	<class path="echo.util.ext._FloatExt.FloatExt_Fields_" params="" file="/home/runner/work/echo/echo/echo/util/ext/FloatExt.hx" private="1" module="echo.util.ext.FloatExt" final="1">
		<equals public="1" get="inline" set="null" line="11" static="1">
			<f a="a:b:?diff" v="::0.00001">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ diff : 0.00001 }</e></m></meta>
			<haxe_doc>* Checks if two Floats are "equal" within the margin of error defined by the `diff` argument.
 * @param a The first Float to check for equality.
 * @param b The first Float to check for equality.
 * @param diff The margin of error to check by.
 * @return returns true if the floats are equal (within the defined margin of error)</haxe_doc>
		</equals>
		<clamp public="1" get="inline" set="null" line="13" static="1"><f a="value:min:max">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></clamp>
		<rad_to_deg public="1" get="inline" set="null" line="23" static="1">
			<f a="rad">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Converts specified angle in radians to degrees.
 * @return angle in degrees (not normalized to 0...360)</haxe_doc>
		</rad_to_deg>
		<deg_to_rad public="1" get="inline" set="null" line="29" static="1">
			<f a="deg">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Converts specified angle in degrees to radians.
 * @return angle in radians (not normalized to 0...Math.PI*2)</haxe_doc>
		</deg_to_rad>
		<sign public="1" get="inline" set="null" line="31" static="1">
			<f a="value">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<overloads><sign public="1" get="inline" set="null" line="33"><f a="value:deadzone">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
</f></sign></overloads>
		</sign>
	</class>
	<class path="echo.util.ext._IntExt.IntExt_Fields_" params="" file="/home/runner/work/echo/echo/echo/util/ext/IntExt.hx" private="1" module="echo.util.ext.IntExt" final="1">
		<max public="1" get="inline" set="null" line="3" static="1"><f a="a:b">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></max>
		<min public="1" get="inline" set="null" line="7" static="1"><f a="a:b">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></min>
		<sign public="1" get="inline" set="null" line="11" static="1">
			<f a="value">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<overloads><sign public="1" get="inline" set="null" line="13"><f a="value:deadzone">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></sign></overloads>
		</sign>
	</class>
	<class path="echo.util.verlet.Composite" params="" file="/home/runner/work/echo/echo/echo/util/verlet/Composite.hx">
		<dots public="1" expr="[]">
			<c path="Array"><c path="echo.util.verlet.Dot"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</dots>
		<constraints public="1" expr="[]">
			<c path="Array"><c path="echo.util.verlet.Constraint"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</constraints>
		<add_dot public="1" set="method" line="13"><f a="?x:?y">
	<x path="Float"/>
	<x path="Float"/>
	<c path="echo.util.verlet.Dot"/>
</f></add_dot>
		<remove_dot public="1" get="inline" set="null" line="19"><f a="dot">
	<c path="echo.util.verlet.Dot"/>
	<x path="Bool"/>
</f></remove_dot>
		<add_constraint public="1" set="method" line="23"><f a="constraint">
	<c path="echo.util.verlet.Constraint"/>
	<c path="echo.util.verlet.Constraint"/>
</f></add_constraint>
		<remove_constraint public="1" get="inline" set="null" line="28"><f a="constraint">
	<c path="echo.util.verlet.Constraint"/>
	<x path="Bool"/>
</f></remove_constraint>
		<pin public="1" get="inline" set="null" line="32"><f a="index">
	<x path="Int"/>
	<x path="Void"/>
</f></pin>
		<bounds public="1" set="method" line="34"><f a="?aabb">
	<c path="echo.util.AABB"/>
	<c path="echo.util.AABB"/>
</f></bounds>
		<clear public="1" get="inline" set="null" line="50"><f a=""><x path="Void"/></f></clear>
		<toString public="1" set="method" line="55"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="11"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* A Composite contains Dots and Constraints. It can be thought of as a "Body" in the Verlet simulation.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="echo.util.verlet.Constraint" params="" file="/home/runner/work/echo/echo/echo/util/verlet/Constraints.hx" module="echo.util.verlet.Constraints" abstract="1">
		<active public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</active>
		<step abstract="1" public="1" set="method"><f a="dt">
	<x path="Float"/>
	<x path="Void"/>
</f></step>
		<position_count abstract="1" public="1" set="method"><f a=""><x path="Int"/></f></position_count>
		<get_position abstract="1" public="1" set="method"><f a="i">
	<x path="Int"/>
	<x path="echo.math.Vector2"/>
</f></get_position>
		<iterator public="1" get="inline" set="null" line="14"><f a=""><c path="echo.util.verlet.ConstraintIterator"/></f></iterator>
		<get_positions public="1" get="inline" set="null" line="18"><f a=""><c path="Array"><x path="echo.math.Vector2"/></c></f></get_positions>
		<new public="1" set="method" line="5">
			<f a=""><x path="Void"/></f>
			<meta><m n=":compilerGenerated"/></meta>
		</new>
	</class>
	<class path="echo.util.verlet.ConstraintIterator" params="" file="/home/runner/work/echo/echo/echo/util/verlet/Constraints.hx" module="echo.util.verlet.Constraints">
		<c><c path="echo.util.verlet.Constraint"/></c>
		<i><x path="Int"/></i>
		<hasNext public="1" get="inline" set="null" line="32"><f a=""><x path="Bool"/></f></hasNext>
		<next public="1" get="inline" set="null" line="36"><f a=""><x path="echo.math.Vector2"/></f></next>
		<new public="1" get="inline" set="null" line="27"><f a="c">
	<c path="echo.util.verlet.Constraint"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="echo.util.verlet.DistanceConstraint" params="" file="/home/runner/work/echo/echo/echo/util/verlet/Constraints.hx" module="echo.util.verlet.Constraints">
		<extends path="echo.util.verlet.Constraint"/>
		<a public="1"><c path="echo.util.verlet.Dot"/></a>
		<b public="1"><c path="echo.util.verlet.Dot"/></b>
		<stiffness public="1"><x path="Float"/></stiffness>
		<distance public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</distance>
		<step public="1" set="method" line="60" override="1"><f a="dt">
	<x path="Float"/>
	<x path="Void"/>
</f></step>
		<position_count public="1" get="inline" set="null" line="70" override="1"><f a=""><x path="Int"/></f></position_count>
		<get_position public="1" get="inline" set="null" line="72" override="1"><f a="i">
	<x path="Int"/>
	<x path="echo.math.Vector2"/>
</f></get_position>
		<new public="1" set="method" line="47"><f a="a:b:stiffness:?distance">
	<c path="echo.util.verlet.Dot"/>
	<c path="echo.util.verlet.Dot"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="echo.util.verlet.PinConstraint" params="" file="/home/runner/work/echo/echo/echo/util/verlet/Constraints.hx" module="echo.util.verlet.Constraints">
		<extends path="echo.util.verlet.Constraint"/>
		<a public="1"><c path="echo.util.verlet.Dot"/></a>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<step public="1" set="method" line="94" override="1"><f a="dt">
	<x path="Float"/>
	<x path="Void"/>
</f></step>
		<position_count public="1" get="inline" set="null" line="99" override="1"><f a=""><x path="Int"/></f></position_count>
		<get_position public="1" get="inline" set="null" line="101" override="1"><f a="i">
	<x path="Int"/>
	<x path="echo.math.Vector2"/>
</f></get_position>
		<new public="1" set="method" line="88"><f a="a:?x:?y">
	<c path="echo.util.verlet.Dot"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="echo.util.verlet.RotationConstraint" params="" file="/home/runner/work/echo/echo/echo/util/verlet/Constraints.hx" module="echo.util.verlet.Constraints">
		<extends path="echo.util.verlet.Constraint"/>
		<a public="1"><c path="echo.util.verlet.Dot"/></a>
		<b public="1"><c path="echo.util.verlet.Dot"/></b>
		<c public="1"><c path="echo.util.verlet.Dot"/></c>
		<radians public="1"><x path="Float"/></radians>
		<stiffness public="1"><x path="Float"/></stiffness>
		<step public="1" set="method" line="127" override="1"><f a="dt">
	<x path="Float"/>
	<x path="Void"/>
</f></step>
		<position_count public="1" get="inline" set="null" line="147" override="1"><f a=""><x path="Int"/></f></position_count>
		<get_position public="1" get="inline" set="null" line="149" override="1"><f a="i">
	<x path="Int"/>
	<x path="echo.math.Vector2"/>
</f></get_position>
		<new public="1" set="method" line="119"><f a="a:b:c:stiffness">
	<c path="echo.util.verlet.Dot"/>
	<c path="echo.util.verlet.Dot"/>
	<c path="echo.util.verlet.Dot"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="echo.util.verlet.Dot" params="" file="/home/runner/work/echo/echo/echo/util/verlet/Dot.hx">
		<x public="1">
			<x path="Float"/>
			<haxe_doc>* The Dot's X position.</haxe_doc>
		</x>
		<y public="1">
			<x path="Float"/>
			<haxe_doc>* The Dot's Y position.</haxe_doc>
		</y>
		<dx public="1">
			<x path="Float"/>
			<haxe_doc>* The Dot's last X position.</haxe_doc>
		</dx>
		<dy public="1">
			<x path="Float"/>
			<haxe_doc>* The Dot's last Y position.</haxe_doc>
		</dy>
		<ax public="1">
			<x path="Float"/>
			<haxe_doc>* The Dot's X acceleration.</haxe_doc>
		</ax>
		<ay public="1">
			<x path="Float"/>
			<haxe_doc>* The Dot's Y acceleration.</haxe_doc>
		</ay>
		<push public="1" get="inline" set="null" line="41">
			<f a="?x:?y" v="0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ y : 0, x : 0 }</e></m></meta>
		</push>
		<get_position public="1" get="inline" set="null" line="46"><f a=""><x path="echo.math.Vector2"/></f></get_position>
		<get_last_position public="1" get="inline" set="null" line="48"><f a=""><x path="echo.math.Vector2"/></f></get_last_position>
		<get_acceleration public="1" get="inline" set="null" line="50"><f a=""><x path="echo.math.Vector2"/></f></get_acceleration>
		<set_position public="1" get="inline" set="null" line="52"><f a="v">
	<x path="echo.math.Vector2"/>
	<x path="Void"/>
</f></set_position>
		<set_last_position public="1" get="inline" set="null" line="57"><f a="v">
	<x path="echo.math.Vector2"/>
	<x path="Void"/>
</f></set_last_position>
		<set_acceleration public="1" get="inline" set="null" line="62"><f a="v">
	<x path="echo.math.Vector2"/>
	<x path="Void"/>
</f></set_acceleration>
		<toString public="1" set="method" line="67"><f a=""><c path="String"/></f></toString>
		<new public="1" get="inline" set="null" line="35">
			<f a="?x:?y" v="0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ y : 0, x : 0 }</e></m></meta>
		</new>
		<haxe_doc>* The Dot is the basic building block of the Verlet simulation, representing a single moving point.
 * 
 * Each Dot stores its latest position, acceleration, and prior position (from the last time the Verlet simulation stepped forward).</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="echo.util.verlet.Verlet" params="" file="/home/runner/work/echo/echo/echo/util/verlet/Verlet.hx">
		<implements path="echo.util.Disposable"/>
		<rect public="1" set="method" line="58" static="1"><f a="x:y:width:height:stiffness:?distance">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="echo.util.verlet.Composite"/>
</f></rect>
		<rope public="1" set="method" line="74" static="1"><f a="points:stiffness:?pinned">
	<c path="Array"><x path="echo.math.Vector2"/></c>
	<x path="Float"/>
	<c path="Array"><x path="Int"/></c>
	<c path="echo.util.verlet.Composite"/>
</f></rope>
		<cloth public="1" set="method" line="89" static="1"><f a="x:y:width:height:segments:pin_mod:stiffness">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
	<c path="echo.util.verlet.Composite"/>
</f></cloth>
		<x public="1">
			<x path="Float"/>
			<haxe_doc>* The Verlet World's position on the X axis.</haxe_doc>
		</x>
		<y public="1">
			<x path="Float"/>
			<haxe_doc>* The Verlet World's position on the Y axis.</haxe_doc>
		</y>
		<width public="1">
			<x path="Float"/>
			<haxe_doc>* Width of the Verlet World, extending right from the World's X position.</haxe_doc>
		</width>
		<height public="1">
			<x path="Float"/>
			<haxe_doc>* Height of the Verlet World, extending down from the World's Y position.</haxe_doc>
		</height>
		<gravity public="1" set="null">
			<x path="echo.math.Vector2"/>
			<haxe_doc>* The amount of acceleration applied to each `Dot` every Step.</haxe_doc>
		</gravity>
		<drag public="1"><x path="Float"/></drag>
		<composites public="1" set="null" expr="[]">
			<c path="Array"><c path="echo.util.verlet.Composite"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</composites>
		<iterations public="1">
			<x path="Int"/>
			<haxe_doc>* The amount of iterations that occur on Constraints each time the Verlet World is stepped. The higher the number, the more stable the Physics Simulation will be, at the cost of performance.</haxe_doc>
		</iterations>
		<fixed_framerate public="1" set="accessor">
			<x path="Float"/>
			<haxe_doc>* The fixed Step rate of the Verlet World. The Verlet simulation must be stepped forward at a consistent rate, or it's stability will quickly deteriorate.</haxe_doc>
		</fixed_framerate>
		<bounds_left public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</bounds_left>
		<bounds_right public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</bounds_right>
		<bounds_top public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</bounds_top>
		<bounds_bottom public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</bounds_bottom>
		<fixed_accumulator expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</fixed_accumulator>
		<fixed_dt><x path="Float"/></fixed_dt>
		<step public="1" set="method" line="124"><f a="dt:?colliders">
	<x path="Float"/>
	<c path="Array"><c path="echo.Shape"/></c>
	<x path="Void"/>
</f></step>
		<add public="1" get="inline" set="null" line="158"><f a="composite">
	<c path="echo.util.verlet.Composite"/>
	<c path="echo.util.verlet.Composite"/>
</f></add>
		<remove public="1" get="inline" set="null" line="163"><f a="composite">
	<c path="echo.util.verlet.Composite"/>
	<x path="Bool"/>
</f></remove>
		<dispose public="1" get="inline" set="null" line="167"><f a=""><x path="Void"/></f></dispose>
		<set_fixed_framerate get="inline" set="null" line="172"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_fixed_framerate>
		<new public="1" set="method" line="113"><f a="options">
	<t path="echo.data.VerletOptions"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* A Verlet physics simulation, using Dots, Constraints, and Composites. Useful for goofy Softbody visuals and effects!
 * 
 * This simulation is standalone, meaning it doesn't directly integrate with the standard echo simulation.</haxe_doc>
	</class>
	<abstract path="haxe.CallStack" params="" file="/opt/hostedtoolcache/haxe/4.3.2/x64/std/haxe/CallStack.hx">
		<from><icast><c path="Array"><e path="haxe.StackItem"/></c></icast></from>
		<this><c path="Array"><e path="haxe.StackItem"/></c></this>
		<haxe_doc>Get information about the call stack.</haxe_doc>
		<meta>
			<m n=":allow"><e>haxe.Exception</e></m>
			<m n=":using"><e>haxe.CallStack</e></m>
		</meta>
		<impl><class path="haxe._CallStack.CallStack_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.3.2/x64/std/haxe/CallStack.hx" private="1" module="haxe.CallStack" final="1"><meta>
	<m n=":keep"/>
	<m n=":using"><e>haxe.CallStack</e></m>
	<m n=":allow"><e>haxe.Exception</e></m>
</meta></class></impl>
	</abstract>
	<abstract path="haxe.Function" params="" file="/opt/hostedtoolcache/haxe/4.3.2/x64/std/haxe/Constraints.hx" module="haxe.Constraints">
		<this><d/></this>
		<haxe_doc>This type unifies with any function type.

	It is intended to be used as a type parameter constraint. If used as a real
	type, the underlying type will be `Dynamic`.</haxe_doc>
		<meta><m n=":callable"/></meta>
		<impl><class path="haxe._Constraints.Function_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.3.2/x64/std/haxe/Constraints.hx" private="1" module="haxe.Constraints" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<abstract path="haxe.FlatEnum" params="" file="/opt/hostedtoolcache/haxe/4.3.2/x64/std/haxe/Constraints.hx" module="haxe.Constraints">
		<this><d/></this>
		<haxe_doc>This type unifies with an enum instance if all constructors of the enum
	require no arguments.

	It is intended to be used as a type parameter constraint. If used as a real
	type, the underlying type will be `Dynamic`.</haxe_doc>
		<impl><class path="haxe._Constraints.FlatEnum_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.3.2/x64/std/haxe/Constraints.hx" private="1" module="haxe.Constraints" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<abstract path="haxe.NotVoid" params="" file="/opt/hostedtoolcache/haxe/4.3.2/x64/std/haxe/Constraints.hx" module="haxe.Constraints">
		<this><d/></this>
		<haxe_doc>This type unifies with anything but `Void`.

	It is intended to be used as a type parameter constraint. If used as a real
	type, the underlying type will be `Dynamic`.</haxe_doc>
		<impl><class path="haxe._Constraints.NotVoid_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.3.2/x64/std/haxe/Constraints.hx" private="1" module="haxe.Constraints" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<abstract path="haxe.Constructible" params="T" file="/opt/hostedtoolcache/haxe/4.3.2/x64/std/haxe/Constraints.hx" module="haxe.Constraints">
		<this><d/></this>
		<haxe_doc><![CDATA[This type unifies with any instance of classes that have a constructor
	which

	  * is `public` and
	  * unifies with the type used for type parameter `T`.

	If a type parameter `A` is assigned to a type parameter `B` which is constrained
	to `Constructible<T>`, A must be explicitly constrained to
	`Constructible<T>` as well.

	It is intended to be used as a type parameter constraint. If used as a real
	type, the underlying type will be `Dynamic`.]]></haxe_doc>
		<impl><class path="haxe._Constraints.Constructible_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.3.2/x64/std/haxe/Constraints.hx" private="1" module="haxe.Constraints" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<abstract path="haxe.DynamicAccess" params="T" file="/opt/hostedtoolcache/haxe/4.3.2/x64/std/haxe/DynamicAccess.hx">
		<from><icast><d><c path="haxe.DynamicAccess.T"/></d></icast></from>
		<this><d><c path="haxe.DynamicAccess.T"/></d></this>
		<to><icast><d><c path="haxe.DynamicAccess.T"/></d></icast></to>
		<haxe_doc>DynamicAccess is an abstract type for working with anonymous structures
	that are intended to hold collections of objects by the string key.

	For example, these types of structures are often created from JSON.

	Basically, it wraps `Reflect` calls in a `Map`-like interface.</haxe_doc>
		<impl><class path="haxe._DynamicAccess.DynamicAccess_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.3.2/x64/std/haxe/DynamicAccess.hx" private="1" module="haxe.DynamicAccess" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="haxe.EnumTools" params="" file="/opt/hostedtoolcache/haxe/4.3.2/x64/std/haxe/EnumTools.hx" extern="1">
		<getName public="1" params="T" get="inline" set="null" line="52" static="1">
			<f a="e">
				<x path="Enum"><c path="getName.T"/></x>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the name of enum `e`, including its path.

		If `e` is inside a package, the package structure is returned dot-
		separated, with another dot separating the enum name:

			pack1.pack2.(...).packN.EnumName

		If `e` is a sub-type of a Haxe module, that module is not part of the
		package structure.

		If `e` has no package, the enum name is returned.

		If `e` is `null`, the result is unspecified.

		The enum name does not include any type parameters.</haxe_doc>
		</getName>
		<createByName public="1" params="T" get="inline" set="null" line="65" static="1">
			<f a="e:constr:?params">
				<x path="Enum"><c path="createByName.T"/></x>
				<c path="String"/>
				<c path="Array"><d/></c>
				<c path="createByName.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor `constr` with
		arguments `params`.

		If `e` or `constr` is `null`, or if enum `e` has no constructor named
		`constr`, or if the number of elements in `params` does not match the
		expected number of constructor arguments, or if any argument has an
		invalid type, the result is unspecified.</haxe_doc>
		</createByName>
		<createByIndex public="1" params="T" get="inline" set="null" line="81" static="1">
			<f a="e:index:?params">
				<x path="Enum"><c path="createByIndex.T"/></x>
				<x path="Int"/>
				<c path="Array"><d/></c>
				<c path="createByIndex.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor number
		`index` with arguments `params`.

		The constructor indices are preserved from Haxe syntax, so the first
		declared is index 0, the next index 1 etc.

		If `e` or `index` is `null`, or if enum `e` has no constructor
		corresponding to index `index`, or if the number of elements in `params`
		does not match the expected number of constructor arguments, or if any
		argument has an invalid type, the result is unspecified.</haxe_doc>
		</createByIndex>
		<createAll public="1" params="T" get="inline" set="null" line="98" static="1">
			<f a="e">
				<x path="Enum"><c path="createAll.T"/></x>
				<c path="Array"><c path="createAll.T"/></c>
			</f>
			<haxe_doc>Returns a list of all constructors of enum `e` that require no
		arguments.

		This may return the empty Array `[]` if all constructors of `e` require
		arguments.

		Otherwise an instance of `e` constructed through each of its non-
		argument constructors is returned, in the order of the constructor
		declaration.

		If `e` is `null`, the result is unspecified.</haxe_doc>
		</createAll>
		<getConstructors public="1" params="T" get="inline" set="null" line="110" static="1">
			<f a="e">
				<x path="Enum"><c path="getConstructors.T"/></x>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns a list of the names of all constructors of enum `e`.

		The order of the constructor names in the returned Array is preserved
		from the original syntax.

		If `c` is `null`, the result is unspecified.</haxe_doc>
		</getConstructors>
		<haxe_doc>This class provides advanced methods on enums. It is ideally used with
	`using EnumTools` and then acts as an
	  [extension](https://haxe.org/manual/lf-static-extension.html) to the
	  `enum` types.

	If the first argument to any of the methods is `null`, the result is
	unspecified.</haxe_doc>
	</class>
	<class path="haxe.EnumValueTools" params="" file="/opt/hostedtoolcache/haxe/4.3.2/x64/std/haxe/EnumTools.hx" module="haxe.EnumTools" extern="1">
		<equals public="1" params="T" get="inline" set="null" line="138" static="1">
			<f a="a:b">
				<c path="equals.T"/>
				<c path="equals.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Recursively compares two enum instances `a` and `b` by value.

		Unlike `a == b`, this function performs a deep equality check on the
		arguments of the constructors (if there are any).

		If `a` or `b` are `null`, the result is unspecified.</haxe_doc>
		</equals>
		<getName public="1" get="inline" set="null" line="149" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the constructor name of enum instance `e`.

		The result String does not contain any constructor arguments.

		If `e` is `null`, the result is unspecified.</haxe_doc>
		</getName>
		<getParameters public="1" get="inline" set="null" line="163" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="Array"><d/></c>
			</f>
			<haxe_doc>Returns a list of the constructor arguments of enum instance `e`.

		If `e` has no arguments, the result is `[]`.

		Otherwise the result are the values that were used as arguments to `e`,
		in the order of their declaration.

		If `e` is `null`, the result is unspecified.</haxe_doc>
		</getParameters>
		<getIndex public="1" get="inline" set="null" line="175" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the index of enum instance `e`.

		This corresponds to the original syntactic position of `e`. The index of
		the first declared constructor is 0, the next one is 1 etc.

		If `e` is `null`, the result is unspecified.</haxe_doc>
		</getIndex>
		<haxe_doc>This class provides advanced methods on enum values. It is ideally used with
	`using EnumValueTools` and then acts as an
	  [extension](https://haxe.org/manual/lf-static-extension.html) to the
	  `EnumValue` types.

	If the first argument to any of the methods is `null`, the result is
	unspecified.</haxe_doc>
	</class>
	<class path="haxe._Exception.NativeException" params="" file="/opt/hostedtoolcache/haxe/4.3.2/x64/std/js/_std/haxe/Exception.hx" private="1" module="haxe.Exception" extern="1">
		<new public="1" set="method"><f a="?message">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":noCompletion"/>
			<m n=":native"><e>"Error"</e></m>
		</meta>
	</class>
	<class path="haxe.Exception" params="" file="/opt/hostedtoolcache/haxe/4.3.2/x64/std/js/_std/haxe/Exception.hx">
		<extends path="haxe._Exception.NativeException"/>
		<thrown set="method" line="28" static="1">
			<f a="value">
				<x path="Any"/>
				<x path="Any"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</thrown>
		<native public="1" get="accessor" set="null">
			<x path="Any"/>
			<haxe_doc>Native exception, which caused this exception.</haxe_doc>
		</native>
		<__skipStack>
			<x path="Int"/>
			<meta>
				<m n=":ifFeature"><e>"haxe.Exception.get_stack"</e></m>
				<m n=":noCompletion"/>
			</meta>
		</__skipStack>
		<__nativeException>
			<x path="Any"/>
			<meta><m n=":noCompletion"/></meta>
		</__nativeException>
		<__previousException>
			<x path="Null"><c path="haxe.Exception"/></x>
			<meta><m n=":noCompletion"/></meta>
		</__previousException>
		<get_native final="1" set="method" line="96"><f a=""><x path="Any"/></f></get_native>
		<new public="1" set="method" line="40">
			<f a="message:?previous:?native">
				<c path="String"/>
				<c path="haxe.Exception"/>
				<x path="Any"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Create a new Exception instance.

		The `previous` argument could be used for exception chaining.

		The `native` argument is for internal usage only.
		There is no need to provide `native` argument manually and no need to keep it
		upon extending `haxe.Exception` unless you know what you're doing.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[Base class for exceptions.

	If this class (or derivatives) is used to catch an exception, then
	`haxe.CallStack.exceptionStack()` will not return a stack for the exception
	caught. Use `haxe.Exception.stack` property instead:
	```haxe
	try {
		throwSomething();
	} catch(e:Exception) {
		trace(e.stack);
	}
	```

	Custom exceptions should extend this class:
	```haxe
	class MyException extends haxe.Exception {}
	//...
	throw new MyException('terrible exception');
	```

	`haxe.Exception` is also a wildcard type to catch any exception:
	```haxe
	try {
		throw 'Catch me!';
	} catch(e:haxe.Exception) {
		trace(e.message); // Output: Catch me!
	}
	```

	To rethrow an exception just throw it again.
	Haxe will try to rethrow an original native exception whenever possible.
	```haxe
	try {
		var a:Array<Int> = null;
		a.push(1); // generates target-specific null-pointer exception
	} catch(e:haxe.Exception) {
		throw e; // rethrows native exception instead of haxe.Exception
	}
	```]]></haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="haxe._NativeStackTrace.V8Error" params="" file="/opt/hostedtoolcache/haxe/4.3.2/x64/std/js/_std/haxe/NativeStackTrace.hx" private="1" module="haxe.NativeStackTrace" extern="1">
		<prepareStackTrace public="1" static="1"><f a="error:structuredStackTrace">
	<c path="js.lib.Error"/>
	<c path="Array"><t path="haxe.V8CallSite"/></c>
	<x path="Any"/>
</f></prepareStackTrace>
		<meta><m n=":native"><e>"Error"</e></m></meta>
	</class>
	<typedef path="haxe.V8CallSite" params="" file="/opt/hostedtoolcache/haxe/4.3.2/x64/std/js/_std/haxe/NativeStackTrace.hx" module="haxe.NativeStackTrace"><a>
	<getLineNumber set="method"><f a=""><x path="Int"/></f></getLineNumber>
	<getFunctionName set="method"><f a=""><c path="String"/></f></getFunctionName>
	<getFileName set="method"><f a=""><c path="String"/></f></getFileName>
	<getColumnNumber set="method"><f a=""><x path="Int"/></f></getColumnNumber>
</a></typedef>
	<typedef path="haxe._Rest.NativeRest" params="T" file="/opt/hostedtoolcache/haxe/4.3.2/x64/std/haxe/Rest.hx" private="1" module="haxe.Rest"><c path="Array"><c path="haxe._Rest.NativeRest.T"/></c></typedef>
	<abstract path="haxe.Rest" params="T" file="/opt/hostedtoolcache/haxe/4.3.2/x64/std/haxe/Rest.hx">
		<from><icast field="of"><c path="Array"><c path="of.T"/></c></icast></from>
		<this><t path="haxe._Rest.NativeRest"><c path="haxe.Rest.T"/></t></this>
		<to><icast field="toArray"><c path="Array"><c path="haxe.Rest.T"/></c></icast></to>
		<haxe_doc><![CDATA[A special type that represents a "rest" function argument.

	The special `...` syntax can be used for convenience and improved readability:

	```haxe
	function f(...rest:Int) {
		$type(rest); // haxe.Rest<Int>
	}

	f(1, 2, 3);

	final array = [1, 2, 3];
	f(...array);
	```

	Should be used as a type for the last argument of a method, indicating that
	an arbitrary number of arguments of the given type can be passed to that method.

	Allows to use array access by index to get values of rest arguments.
	If the index exceeds the amount of rest arguments passed, the result is unspecified.]]></haxe_doc>
		<meta><m n=":coreApi"/></meta>
		<impl><class path="haxe._Rest.Rest_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.3.2/x64/std/haxe/Rest.hx" private="1" module="haxe.Rest" final="1"><meta>
	<m n=":keep"/>
	<m n=":coreApi"/>
</meta></class></impl>
	</abstract>
	<class path="haxe.ValueException" params="" file="/opt/hostedtoolcache/haxe/4.3.2/x64/std/haxe/ValueException.hx">
		<extends path="haxe.Exception"/>
		<value public="1" set="null">
			<x path="Any"/>
			<haxe_doc>Thrown value.</haxe_doc>
		</value>
		<new public="1" set="method" line="23"><f a="value:?previous:?native">
	<x path="Any"/>
	<c path="haxe.Exception"/>
	<x path="Any"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>An exception containing arbitrary value.

	This class is automatically used for throwing values, which don't extend `haxe.Exception`
	or native exception type.
	For example:
	```haxe
	throw "Terrible error";
	```
	will be compiled to
	```haxe
	throw new ValueException("Terrible error");
	```</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<enum path="haxe.ds.Either" params="L:R" file="/opt/hostedtoolcache/haxe/4.3.2/x64/std/haxe/ds/Either.hx">
		<Left a="v"><c path="haxe.ds.Either.L"/></Left>
		<Right a="v"><c path="haxe.ds.Either.R"/></Right>
		<haxe_doc>Either represents values which are either of type `L` (Left) or type `R`
	(Right).</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<abstract path="haxe.ds.ReadOnlyArray" params="T" file="/opt/hostedtoolcache/haxe/4.3.2/x64/std/haxe/ds/ReadOnlyArray.hx">
		<from><icast><c path="Array"><c path="haxe.ds.ReadOnlyArray.T"/></c></icast></from>
		<this><c path="Array"><c path="haxe.ds.ReadOnlyArray.T"/></c></this>
		<to><icast><t path="Iterable"><c path="haxe.ds.ReadOnlyArray.T"/></t></icast></to>
		<haxe_doc>`ReadOnlyArray` is an abstract over an ordinary `Array` which only exposes
	APIs that don't modify the instance, hence "read-only".

	Note that this doesn't necessarily mean that the instance is *immutable*.
	Other code holding a reference to the underlying `Array` can still modify it,
	and the reference can be obtained with a `cast`.</haxe_doc>
		<meta><m n=":forward">
	<e>copy</e>
	<e>filter</e>
	<e>indexOf</e>
	<e>iterator</e>
	<e>keyValueIterator</e>
	<e>join</e>
	<e>lastIndexOf</e>
	<e>map</e>
	<e>slice</e>
	<e>contains</e>
	<e>toString</e>
</m></meta>
		<impl><class path="haxe.ds._ReadOnlyArray.ReadOnlyArray_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.3.2/x64/std/haxe/ds/ReadOnlyArray.hx" private="1" module="haxe.ds.ReadOnlyArray" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<typedef path="haxe.ds._Vector.VectorData" params="T" file="/opt/hostedtoolcache/haxe/4.3.2/x64/std/haxe/ds/Vector.hx" private="1" module="haxe.ds.Vector"><c path="Array"><c path="haxe.ds._Vector.VectorData.T"/></c></typedef>
	<abstract path="haxe.ds.Vector" params="T" file="/opt/hostedtoolcache/haxe/4.3.2/x64/std/haxe/ds/Vector.hx">
		<this><t path="haxe.ds._Vector.VectorData"><c path="haxe.ds.Vector.T"/></t></this>
		<haxe_doc>A Vector is a storage of fixed size. It can be faster than Array on some
	targets, and is never slower.

	@see https://haxe.org/manual/std-vector.html</haxe_doc>
		<impl><class path="haxe.ds._Vector.Vector_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.3.2/x64/std/haxe/ds/Vector.hx" private="1" module="haxe.ds.Vector" final="1">
	<_new public="1" get="inline" set="null" line="64" static="1">
		<f a="length">
			<x path="Int"/>
			<x path="haxe.ds.Vector"><c path="haxe.ds.Vector.T"/></x>
		</f>
		<meta><m n=":noCompletion"/></meta>
		<haxe_doc>Creates a new Vector of length `length`.

		Initially `this` Vector contains `length` neutral elements:

		- always null on dynamic targets
		- 0, 0.0 or false for Int, Float and Bool respectively on static targets
		- null for other types on static targets

		If `length` is less than or equal to 0, the result is unspecified.</haxe_doc>
		<overloads><_new public="1" get="inline" set="null" line="96">
	<f a="length:defaultValue">
		<x path="Int"/>
		<c path="haxe.ds.Vector.T"/>
		<x path="haxe.ds.Vector"><c path="haxe.ds.Vector.T"/></x>
	</f>
	<meta><m n=":noCompletion"/></meta>
	<haxe_doc>Creates a new Vector of length `length` filled with `defaultValue` elements.

		Can be faster than `new Vector(length)` for iteration on some targets for non-nullable elements.

		If `length` is less than or equal to 0, the result is unspecified.</haxe_doc>
</_new></overloads>
	</_new>
	<meta><m n=":keep"/></meta>
</class></impl>
	</abstract>
	<class path="haxe.ds._Vector.Vector_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.3.2/x64/std/haxe/ds/Vector.hx" private="1" module="haxe.ds.Vector" final="1">
		<_new public="1" get="inline" set="null" line="64" static="1">
			<f a="length">
				<x path="Int"/>
				<x path="haxe.ds.Vector"><c path="haxe.ds.Vector.T"/></x>
			</f>
			<meta><m n=":noCompletion"/></meta>
			<haxe_doc>Creates a new Vector of length `length`.

		Initially `this` Vector contains `length` neutral elements:

		- always null on dynamic targets
		- 0, 0.0 or false for Int, Float and Bool respectively on static targets
		- null for other types on static targets

		If `length` is less than or equal to 0, the result is unspecified.</haxe_doc>
			<overloads><_new public="1" get="inline" set="null" line="96">
	<f a="length:defaultValue">
		<x path="Int"/>
		<c path="haxe.ds.Vector.T"/>
		<x path="haxe.ds.Vector"><c path="haxe.ds.Vector.T"/></x>
	</f>
	<meta><m n=":noCompletion"/></meta>
	<haxe_doc>Creates a new Vector of length `length` filled with `defaultValue` elements.

		Can be faster than `new Vector(length)` for iteration on some targets for non-nullable elements.

		If `length` is less than or equal to 0, the result is unspecified.</haxe_doc>
</_new></overloads>
		</_new>
		<meta><m n=":keep"/></meta>
	</class>
	<abstract path="haxe.extern.EitherType" params="T1:T2" file="/opt/hostedtoolcache/haxe/4.3.2/x64/std/haxe/extern/EitherType.hx">
		<from>
			<icast><c path="haxe.extern.EitherType.T1"/></icast>
			<icast><c path="haxe.extern.EitherType.T2"/></icast>
		</from>
		<this><d/></this>
		<to>
			<icast><c path="haxe.extern.EitherType.T1"/></icast>
			<icast><c path="haxe.extern.EitherType.T2"/></icast>
		</to>
		<haxe_doc><![CDATA[An abstract type allowing values to be either of `T1` or `T2` type.
	Supports implicit casts from/to either types.

	It is useful for interfacing with external code on dynamic platforms
	such as JavaScript or Python.

	Otherwise, use of this type is discouraged.

	@see <https://haxe.org/manual/lf-externs.html>]]></haxe_doc>
		<meta><m n=":transitive"/></meta>
		<impl><class path="haxe.extern._EitherType.EitherType_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.3.2/x64/std/haxe/extern/EitherType.hx" private="1" module="haxe.extern.EitherType" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<typedef path="haxe.extern.Rest" params="T" file="/opt/hostedtoolcache/haxe/4.3.2/x64/std/haxe/extern/Rest.hx">
		<x path="haxe.Rest"><c path="haxe.extern.Rest.T"/></x>
		<haxe_doc><![CDATA[DEPRECATED: use haxe.Rest instead.
	
	A special type that represents "rest" function argument.
	Should be used as a type for the last argument of an extern method,
	representing that arbitrary number of arguments of given type can be
	passed to that method.
	@see <https://haxe.org/manual/lf-externs.html>]]></haxe_doc>
	</typedef>
	<class path="haxe.iterators.ArrayIterator" params="T" file="/opt/hostedtoolcache/haxe/4.3.2/x64/std/haxe/iterators/ArrayIterator.hx">
		<array final="1"><c path="Array"><c path="haxe.iterators.ArrayIterator.T"/></c></array>
		<current expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</current>
		<hasNext public="1" get="inline" set="null" line="44">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>See `Iterator.hasNext`</haxe_doc>
		</hasNext>
		<next public="1" get="inline" set="null" line="52">
			<f a=""><c path="haxe.iterators.ArrayIterator.T"/></f>
			<haxe_doc>See `Iterator.next`</haxe_doc>
		</next>
		<new public="1" get="inline" set="null" line="35">
			<f a="array">
				<c path="Array"><c path="haxe.iterators.ArrayIterator.T"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>Create a new `ArrayIterator`.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[This iterator is used only when `Array<T>` is passed to `Iterable<T>`]]></haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="js.Boot" params="" file="/opt/hostedtoolcache/haxe/4.3.2/x64/std/js/Boot.hx">
		<__string_rec set="method" line="58" static="1">
			<f a="o:s">
				<x path="Null"><a>
	<toString set="null"><f a=""><c path="String"/></f></toString>
	<length set="null"><x path="Int"/></length>
	<hasOwnProperty set="null"><x path="Null"><f a="">
	<c path="String"/>
	<x path="Bool"/>
</f></x></hasOwnProperty>
	<_hx_index set="null"><x path="Int"/></_hx_index>
	<__enum__ set="null"><x path="Bool"/></__enum__>
</a></x>
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":ifFeature"><e>"has_enum"</e></m>
			</meta>
		</__string_rec>
		<__toStr static="1"><c path="js.lib.Function"/></__toStr>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
		</meta>
	</class>
	<class path="js.Lib" params="" file="/opt/hostedtoolcache/haxe/4.3.2/x64/std/js/Lib.hx">
		<require public="1" get="inline" set="null" line="65" static="1">
			<f a="module">
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>Inserts a `require` expression that loads JavaScript object from
		a module or file specified in the `module` argument.

		This is only supported in environments where `require` function
		is available, such as Node.js or RequireJS.</haxe_doc>
		</require>
		<parseInt public="1" get="accessor" set="null" static="1">
			<f a="string:?radix">
				<c path="String"/>
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Native JavaScript `parseInt` function.

		Its specification is different from `Std.parseInt`, so one
		might want to access the native one.</haxe_doc>
		</parseInt>
		<get_parseInt get="inline" set="null" line="77" static="1"><f a=""><f a="string:?radix">
	<c path="String"/>
	<x path="Int"/>
	<x path="Float"/>
</f></f></get_parseInt>
		<nativeThis public="1" get="accessor" set="null" static="1">
			<d/>
			<haxe_doc>`nativeThis` is the JavaScript `this`, which is semantically different
		from the Haxe `this`. Use `nativeThis` only when working with external
		JavaScript code.

		In Haxe, `this` is always bound to a class instance.
		In JavaScript, `this` in a function can be bound to an arbitrary
		variable when the function is called using `func.call(thisObj, ...)` or
		`func.apply(thisObj, [...])`.

		Read more at https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this</haxe_doc>
		</nativeThis>
		<get_nativeThis get="inline" set="null" line="108" static="1"><f a=""><d/></f></get_nativeThis>
		<typeof public="1" get="inline" set="null" line="118" static="1">
			<f a="o">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>Call JavaScript `typeof` operator on the `o` value
		and return a string representing the JavaScript type of a value.

		Read more at https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof</haxe_doc>
		</typeof>
		<global public="1" get="accessor" set="null" static="1">
			<d/>
			<haxe_doc>An alias of the JS "global" object.

		Concretely, it is set as the first defined value in the list of
		`window`, `global`, `self`, and `this` in the top-level of the compiled output.</haxe_doc>
		</global>
		<get_global get="inline" set="null" line="130" static="1">
			<f a=""><d/></f>
			<meta><m n=":has_untyped"/></meta>
		</get_global>
		<haxe_doc>Platform-specific JavaScript Library. Provides some platform-specific functions
	for the JavaScript target.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="js.lib.Error" params="" file="/opt/hostedtoolcache/haxe/4.3.2/x64/std/js/lib/Error.hx" extern="1">
		<message public="1"><c path="String"/></message>
		<name public="1"><c path="String"/></name>
		<stack public="1" set="null"><c path="String"/></stack>
		<new public="1" set="method"><f a="?message">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"Error"</e></m>
		</meta>
	</class>
	<class path="js.lib.EvalError" params="" file="/opt/hostedtoolcache/haxe/4.3.2/x64/std/js/lib/Error.hx" module="js.lib.Error" extern="1">
		<extends path="js.lib.Error"/>
		<new public="1" set="method"><f a="?message">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":native"><e>"EvalError"</e></m></meta>
	</class>
	<class path="js.lib.RangeError" params="" file="/opt/hostedtoolcache/haxe/4.3.2/x64/std/js/lib/Error.hx" module="js.lib.Error" extern="1">
		<extends path="js.lib.Error"/>
		<new public="1" set="method"><f a="?message">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":native"><e>"RangeError"</e></m></meta>
	</class>
	<class path="js.lib.ReferenceError" params="" file="/opt/hostedtoolcache/haxe/4.3.2/x64/std/js/lib/Error.hx" module="js.lib.Error" extern="1">
		<extends path="js.lib.Error"/>
		<new public="1" set="method"><f a="?message">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":native"><e>"ReferenceError"</e></m></meta>
	</class>
	<class path="js.lib.SyntaxError" params="" file="/opt/hostedtoolcache/haxe/4.3.2/x64/std/js/lib/Error.hx" module="js.lib.Error" extern="1">
		<extends path="js.lib.Error"/>
		<new public="1" set="method"><f a="?message">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":native"><e>"SyntaxError"</e></m></meta>
	</class>
	<class path="js.lib.TypeError" params="" file="/opt/hostedtoolcache/haxe/4.3.2/x64/std/js/lib/Error.hx" module="js.lib.Error" extern="1">
		<extends path="js.lib.Error"/>
		<new public="1" set="method"><f a="?message">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":native"><e>"TypeError"</e></m></meta>
	</class>
	<class path="js.lib.URIError" params="" file="/opt/hostedtoolcache/haxe/4.3.2/x64/std/js/lib/Error.hx" module="js.lib.Error" extern="1">
		<extends path="js.lib.Error"/>
		<new public="1" set="method"><f a="?message">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":native"><e>"URIError"</e></m></meta>
	</class>
	<class path="js.lib.Function" params="" file="/opt/hostedtoolcache/haxe/4.3.2/x64/std/js/lib/Function.hx" extern="1">
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>Specifies the number of arguments expected by the function.</haxe_doc>
		</length>
		<name public="1">
			<c path="String"/>
			<haxe_doc>The name of the function.</haxe_doc>
		</name>
		<apply public="1" set="method">
			<f a="thisArg:argsArray">
				<d/>
				<c path="Array"><d/></c>
				<d/>
			</f>
			<haxe_doc>Calls a function and sets its this to the provided value, arguments can be passed as an Array object.</haxe_doc>
		</apply>
		<call public="1" set="method">
			<f a="thisArg:args">
				<d/>
				<t path="haxe.extern.Rest"><d/></t>
				<d/>
			</f>
			<haxe_doc>Calls (executes) a function and sets its this to the provided value, arguments can be passed as they are.</haxe_doc>
		</call>
		<bind public="1" set="method">
			<f a="thisArg:args">
				<d/>
				<t path="haxe.extern.Rest"><d/></t>
				<c path="js.lib.Function"/>
			</f>
			<haxe_doc>Creates a new function which, when called, has its this set to the provided value,
		with a given sequence of arguments preceding any provided when the new function was called.</haxe_doc>
		</bind>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string representing the source code of the function.</haxe_doc>
		</toString>
		<new public="1" set="method">
			<f a="arg:rest">
				<c path="String"/>
				<t path="haxe.extern.Rest"><c path="String"/></t>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new Function object.</haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"Function"</e></m>
		</meta>
	</class>
	<class path="js.lib.Object" params="" file="/opt/hostedtoolcache/haxe/4.3.2/x64/std/js/lib/Object.hx" extern="1">
		<assign public="1" params="T" set="method" static="1">
			<f a="target:sources">
				<c path="assign.T"/>
				<t path="haxe.extern.Rest"><a/></t>
				<c path="assign.T"/>
			</f>
			<haxe_doc>Copies the values of all enumerable own properties from one or more
		source objects to a target object.</haxe_doc>
		</assign>
		<create public="1" params="T" set="method" static="1">
			<f a="proto:?propertiesObject">
				<a/>
				<x path="haxe.DynamicAccess"><t path="js.lib.ObjectPropertyDescriptor"/></x>
				<c path="create.T"/>
			</f>
			<haxe_doc>Creates a new object with the specified prototype object and properties.</haxe_doc>
		</create>
		<defineProperties public="1" params="T" set="method" static="1">
			<f a="obj:props">
				<c path="defineProperties.T"/>
				<x path="haxe.DynamicAccess"><t path="js.lib.ObjectPropertyDescriptor"/></x>
				<c path="defineProperties.T"/>
			</f>
			<haxe_doc>Adds the named properties described by the given descriptors to an object.</haxe_doc>
		</defineProperties>
		<defineProperty public="1" params="T" set="method" static="1">
			<f a="obj:prop:descriptor">
				<c path="defineProperty.T"/>
				<c path="String"/>
				<t path="js.lib.ObjectPropertyDescriptor"/>
				<c path="defineProperty.T"/>
			</f>
			<haxe_doc>Adds the named property described by a given descriptor to an object.</haxe_doc>
			<overloads><defineProperty public="1" params="T" set="method">
	<f a="obj:prop:descriptor">
		<c path="defineProperty.T"/>
		<c path="js.lib.Symbol"/>
		<t path="js.lib.ObjectPropertyDescriptor"/>
		<c path="defineProperty.T"/>
	</f>
	<haxe_doc>Adds the named property described by a given descriptor to an object.</haxe_doc>
</defineProperty></overloads>
		</defineProperty>
		<entries public="1" set="method" static="1">
			<f a="obj">
				<a/>
				<c path="Array"><x path="js.lib.ObjectEntry"/></c>
			</f>
			<haxe_doc>Returns an array containing all of the [key, value] pairs of a given
		object's own enumerable string properties.</haxe_doc>
		</entries>
		<freeze public="1" params="T" set="method" static="1">
			<f a="obj">
				<c path="freeze.T"/>
				<c path="freeze.T"/>
			</f>
			<haxe_doc>Freezes an object: other code can't delete or change any properties.</haxe_doc>
		</freeze>
		<fromEntries public="1" params="T" set="method" static="1">
			<f a="iterable">
				<x path="Any"/>
				<c path="fromEntries.T"/>
			</f>
			<haxe_doc>Returns a new object from an iterable of key-value pairs
		(reverses Object.entries).</haxe_doc>
		</fromEntries>
		<getOwnPropertyDescriptor public="1" set="method" static="1">
			<f a="obj:prop">
				<a/>
				<c path="String"/>
				<x path="Null"><t path="js.lib.ObjectPropertyDescriptor"/></x>
			</f>
			<haxe_doc>Returns a property descriptor for a named property on an object.</haxe_doc>
			<overloads>
				<getOwnPropertyDescriptor public="1" params="T" set="method">
					<f a="target:propertyKey">
						<c path="Array"><c path="getOwnPropertyDescriptor.T"/></c>
						<x path="Int"/>
						<x path="Null"><t path="js.lib.ObjectPropertyDescriptor"/></x>
					</f>
					<haxe_doc>Returns a property descriptor for a named property on an object.</haxe_doc>
				</getOwnPropertyDescriptor>
				<getOwnPropertyDescriptor public="1" set="method">
					<f a="obj:prop">
						<a/>
						<c path="js.lib.Symbol"/>
						<x path="Null"><t path="js.lib.ObjectPropertyDescriptor"/></x>
					</f>
					<haxe_doc>Returns a property descriptor for a named property on an object.</haxe_doc>
				</getOwnPropertyDescriptor>
			</overloads>
		</getOwnPropertyDescriptor>
		<getOwnPropertyNames public="1" set="method" static="1">
			<f a="obj">
				<a/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns an array containing the names of all of the given object's own
		enumerable and non-enumerable properties.</haxe_doc>
		</getOwnPropertyNames>
		<getOwnPropertySymbols public="1" set="method" static="1">
			<f a="obj">
				<a/>
				<c path="Array"><c path="js.lib.Symbol"/></c>
			</f>
			<haxe_doc>Returns an array of all symbol properties found directly upon a given object.</haxe_doc>
		</getOwnPropertySymbols>
		<getPrototypeOf public="1" params="TProto" set="method" static="1">
			<f a="obj">
				<a/>
				<x path="Null"><c path="getPrototypeOf.TProto"/></x>
			</f>
			<haxe_doc>Returns the prototype of the specified object.</haxe_doc>
		</getPrototypeOf>
		<is public="1" params="T" set="method" static="1">
			<f a="value1:value2">
				<c path="is.T"/>
				<c path="is.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Compares if two values are the same value. Equates all NaN values
		(which differs from both Abstract Equality Comparison and
		Strict Equality Comparison).</haxe_doc>
		</is>
		<isExtensible public="1" set="method" static="1">
			<f a="obj">
				<a/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Determines if extending of an object is allowed.</haxe_doc>
		</isExtensible>
		<isFrozen public="1" set="method" static="1">
			<f a="obj">
				<a/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Determines if an object was frozen.</haxe_doc>
		</isFrozen>
		<isSealed public="1" set="method" static="1">
			<f a="obj">
				<a/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Determines if an object is sealed.</haxe_doc>
		</isSealed>
		<keys public="1" set="method" static="1">
			<f a="obj">
				<a/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns an array containing the names of all of the given object's own
		enumerable string properties.</haxe_doc>
		</keys>
		<preventExtensions public="1" params="T" set="method" static="1">
			<f a="obj">
				<c path="preventExtensions.T"/>
				<c path="preventExtensions.T"/>
			</f>
			<haxe_doc>Prevents any extensions of an object.</haxe_doc>
		</preventExtensions>
		<seal public="1" params="T" set="method" static="1">
			<f a="obj">
				<c path="seal.T"/>
				<c path="seal.T"/>
			</f>
			<haxe_doc>Prevents other code from deleting properties of an object.</haxe_doc>
		</seal>
		<setPrototypeOf public="1" params="T" set="method" static="1">
			<f a="obj:prototype">
				<c path="setPrototypeOf.T"/>
				<x path="Null"><a/></x>
				<c path="setPrototypeOf.T"/>
			</f>
			<haxe_doc>Sets the prototype (i.e., the internal Prototype property).</haxe_doc>
		</setPrototypeOf>
		<values public="1" set="method" static="1">
			<f a="obj">
				<a/>
				<c path="Array"><x path="Any"/></c>
			</f>
			<haxe_doc>Returns an array containing the values that correspond to all of
		a given object's own enumerable string properties.</haxe_doc>
		</values>
		<prototype public="1" set="null" static="1">
			<t path="js.lib.ObjectPrototype"/>
			<haxe_doc>Allows the addition of properties to all objects of type Object.</haxe_doc>
		</prototype>
		<new public="1" set="method">
			<f a="?value">
				<x path="Any"/>
				<x path="Void"/>
			</f>
			<haxe_doc>The Object constructor creates an object wrapper.</haxe_doc>
		</new>
		<haxe_doc>The `js.lib.Object` constructor creates an object wrapper.

	Documentation [Object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object) by [Mozilla Contributors](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object$history), licensed under [CC-BY-SA 2.5](https://creativecommons.org/licenses/by-sa/2.5/).</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"Object"</e></m>
		</meta>
	</class>
	<typedef path="js.lib.ObjectPrototype" params="" file="/opt/hostedtoolcache/haxe/4.3.2/x64/std/js/lib/Object.hx" module="js.lib.Object">
		<a>
			<valueOf set="null">
				<c path="js.lib.Function"/>
				<haxe_doc>Returns the primitive value of the specified object.</haxe_doc>
			</valueOf>
			<toString set="null">
				<c path="js.lib.Function"/>
				<haxe_doc>Returns a string representation of the object.</haxe_doc>
			</toString>
			<toLocaleString set="null">
				<c path="js.lib.Function"/>
				<haxe_doc>Calls `toString()`.</haxe_doc>
			</toLocaleString>
			<propertyIsEnumerable set="null">
				<c path="js.lib.Function"/>
				<haxe_doc>Returns a boolean indicating if the internal enumerable attribute is set.</haxe_doc>
			</propertyIsEnumerable>
			<isPrototypeOf set="null">
				<c path="js.lib.Function"/>
				<haxe_doc>Returns a boolean indicating whether the object this method is called
		upon is in the prototype chain of the specified object.</haxe_doc>
			</isPrototypeOf>
			<hasOwnProperty set="null">
				<c path="js.lib.Function"/>
				<haxe_doc>Returns a boolean indicating whether an object contains the specified
		property as a direct property of that object and not inherited through
		the prototype chain.</haxe_doc>
			</hasOwnProperty>
		</a>
		<haxe_doc><![CDATA[Type for
	@see <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object>]]></haxe_doc>
	</typedef>
	<typedef path="js.lib.ObjectPropertyDescriptor" params="" file="/opt/hostedtoolcache/haxe/4.3.2/x64/std/js/lib/Object.hx" module="js.lib.Object">
		<a>
			<writable>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>`true` if and only if the value associated with the property may be
		changed with an assignment operator.

		Defaults to `false`.</haxe_doc>
			</writable>
			<value>
				<x path="Null"><x path="Any"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The value associated with the property.
		Can be any valid JavaScript value (number, object, function, etc).</haxe_doc>
			</value>
			<set>
				<x path="Null"><f a="">
	<x path="Any"/>
	<x path="Void"/>
</f></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>A function which serves as a setter for the property, or undefined if
		there is no setter. When the property is assigned to, this function
		is called with one argument (the value being assigned to the property)
		and with `this` set to the object through which the property is assigned.</haxe_doc>
			</set>
			<get>
				<x path="Null"><f a=""><x path="Any"/></f></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>A function which serves as a getter for the property, or `undefined` if
		there is no getter. When the property is accessed, this function is
		called without arguments and with `this` set to the object through which
		the property is accessed (this may not be the object on which the
		property is defined due to inheritance).
		The return value will be used as the value of the property.</haxe_doc>
			</get>
			<enumerable>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>`true` if and only if this property shows up during enumeration of the
		properties on the corresponding object.

		Defaults to `false`.</haxe_doc>
			</enumerable>
			<configurable>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>`true` if and only if the type of this property descriptor may be
		changed and if the property may be deleted from the corresponding object.

		Defaults to `false`.</haxe_doc>
			</configurable>
		</a>
		<haxe_doc><![CDATA[@see <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty>]]></haxe_doc>
	</typedef>
	<abstract path="js.lib.ObjectEntry" params="" file="/opt/hostedtoolcache/haxe/4.3.2/x64/std/js/lib/Object.hx" module="js.lib.Object">
		<this><c path="Array"><x path="Any"/></c></this>
		<haxe_doc>Key/value access helper for `js.lib.Object.entries()`.</haxe_doc>
		<impl><class path="js.lib._Object.ObjectEntry_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.3.2/x64/std/js/lib/Object.hx" private="1" module="js.lib.Object" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="js.lib.Promise" params="T" file="/opt/hostedtoolcache/haxe/4.3.2/x64/std/js/lib/Promise.hx" extern="1">
		<resolve public="1" params="T" set="method" static="1">
			<f a="thenable">
				<x path="js.lib.Thenable"><c path="resolve.T"/></x>
				<c path="js.lib.Promise"><c path="resolve.T"/></c>
			</f>
			<haxe_doc>Returns a Promise object that is resolved with the given value. If the
		value is Thenable, the returned promise will "follow" that
		thenable, adopting its eventual state;
		otherwise the returned promise will be fulfilled with the value.
		Generally, when it's unknown when value is a promise or not,
		use `Promise.resolve(value)` instead and work with the return value as
		a promise.</haxe_doc>
			<overloads><resolve public="1" params="T" set="method">
	<f a="?value">
		<c path="resolve.T"/>
		<c path="js.lib.Promise"><c path="resolve.T"/></c>
	</f>
	<haxe_doc>Returns a Promise object that is resolved with the given value. If the
		value is Thenable, the returned promise will "follow" that
		thenable, adopting its eventual state;
		otherwise the returned promise will be fulfilled with the value.
		Generally, when it's unknown when value is a promise or not,
		use `Promise.resolve(value)` instead and work with the return value as
		a promise.</haxe_doc>
</resolve></overloads>
		</resolve>
		<reject public="1" params="T" set="method" static="1">
			<f a="?reason">
				<d/>
				<c path="js.lib.Promise"><c path="reject.T"/></c>
			</f>
			<haxe_doc>Returns a Promise object that is rejected with the given reason.</haxe_doc>
		</reject>
		<all public="1" params="T" set="method" static="1">
			<f a="iterable">
				<c path="Array"><c path="js.lib.Promise"><c path="all.T"/></c></c>
				<c path="js.lib.Promise"><c path="Array"><c path="all.T"/></c></c>
			</f>
			<haxe_doc>Returns a promise that either fulfills when all of the promises in the
		iterable argument have fulfilled or rejects as soon as one of the
		promises in the iterable argument rejects. If the returned promise
		fulfills, it is fulfilled with an array of the values from the
		fulfilled promises in the same order as defined in the iterable.
		If the returned promise rejects, it is rejected with the reason from
		the first promise in the iterable that rejected. This method can be
		useful for aggregating results of multiple promises.</haxe_doc>
			<overloads><all public="1" set="method">
	<f a="iterable">
		<c path="Array"><d/></c>
		<c path="js.lib.Promise"><c path="Array"><d/></c></c>
	</f>
	<haxe_doc>Returns a promise that either fulfills when all of the promises in the
		iterable argument have fulfilled or rejects as soon as one of the
		promises in the iterable argument rejects. If the returned promise
		fulfills, it is fulfilled with an array of the values from the
		fulfilled promises in the same order as defined in the iterable.
		If the returned promise rejects, it is rejected with the reason from
		the first promise in the iterable that rejected. This method can be
		useful for aggregating results of multiple promises.</haxe_doc>
</all></overloads>
		</all>
		<allSettled public="1" params="T" set="method" static="1">
			<f a="iterable">
				<c path="Array"><c path="js.lib.Promise"><c path="allSettled.T"/></c></c>
				<c path="js.lib.Promise"><c path="Array"><t path="js.lib.PromiseSettleOutcome"><c path="allSettled.T"/></t></c></c>
			</f>
			<haxe_doc>Returns a promise that resolves after all of the given promises have either fulfilled or rejected,
		with an array of objects that each describes the outcome of each promise.

		It is typically used when you have multiple asynchronous tasks that are not dependent on one another
		to complete successfully, or you'd always like to know the result of each promise.

		In comparison, the Promise returned by `Promise.all` may be more appropriate if the tasks are dependent
		on each other / if you'd like to immediately reject upon any of them rejecting.</haxe_doc>
			<overloads><allSettled public="1" set="method">
	<f a="iterable">
		<c path="Array"><d/></c>
		<c path="js.lib.Promise"><c path="Array"><t path="js.lib.PromiseSettleOutcome"><d/></t></c></c>
	</f>
	<haxe_doc>Returns a promise that resolves after all of the given promises have either fulfilled or rejected,
		with an array of objects that each describes the outcome of each promise.

		It is typically used when you have multiple asynchronous tasks that are not dependent on one another
		to complete successfully, or you'd always like to know the result of each promise.

		In comparison, the Promise returned by `Promise.all` may be more appropriate if the tasks are dependent
		on each other / if you'd like to immediately reject upon any of them rejecting.</haxe_doc>
</allSettled></overloads>
		</allSettled>
		<race public="1" params="T" set="method" static="1">
			<f a="iterable">
				<c path="Array"><c path="js.lib.Promise"><c path="race.T"/></c></c>
				<c path="js.lib.Promise"><c path="race.T"/></c>
			</f>
			<haxe_doc>Returns a promise that fulfills or rejects as soon as one of the
		promises in the iterable fulfills or rejects, with the value or reason
		from that promise.</haxe_doc>
			<overloads><race public="1" set="method">
	<f a="iterable">
		<c path="Array"><d/></c>
		<c path="js.lib.Promise"><d/></c>
	</f>
	<haxe_doc>Returns a promise that fulfills or rejects as soon as one of the
		promises in the iterable fulfills or rejects, with the value or reason
		from that promise.</haxe_doc>
</race></overloads>
		</race>
		<then public="1" params="TOut" set="method">
			<f a="onFulfilled:?onRejected">
				<x path="Null"><x path="js.lib.PromiseHandler">
	<c path="js.lib.Promise.T"/>
	<c path="then.TOut"/>
</x></x>
				<x path="js.lib.PromiseHandler">
					<d/>
					<c path="then.TOut"/>
				</x>
				<c path="js.lib.Promise"><c path="then.TOut"/></c>
			</f>
			<haxe_doc>Appends fulfillment and rejection handlers to the promise and returns a
		new promise resolving to the return value of the called handler, or to
		its original settled value if the promise was not handled
		(i.e. if the relevant handler onFulfilled or onRejected is not a function).</haxe_doc>
		</then>
		<catchError public="1" set="method">
			<f a="onRejected">
				<x path="js.lib.PromiseHandler">
					<d/>
					<c path="js.lib.Promise.T"/>
				</x>
				<c path="js.lib.Promise"><c path="js.lib.Promise.T"/></c>
			</f>
			<meta><m n=":native"><e>"catch"</e></m></meta>
			<haxe_doc>Appends a rejection handler callback to the promise, and returns a new
		promise resolving to the return value of the callback if it is called,
		or to its original fulfillment value if the promise is instead fulfilled.</haxe_doc>
			<overloads><catch public="1" params="TOut" set="method">
	<f a="onRejected">
		<x path="js.lib.PromiseHandler">
			<d/>
			<c path="catchError.TOut"/>
		</x>
		<c path="js.lib.Promise"><x path="haxe.extern.EitherType">
	<c path="js.lib.Promise.T"/>
	<c path="catchError.TOut"/>
</x></c>
	</f>
	<meta><m n=":native"><e>"catch"</e></m></meta>
	<haxe_doc>Appends a rejection handler callback to the promise, and returns a new
		promise resolving to the return value of the callback if it is called,
		or to its original fulfillment value if the promise is instead fulfilled.</haxe_doc>
</catch></overloads>
		</catchError>
		<finally public="1" set="method">
			<f a="onFinally">
				<f a=""><x path="Void"/></f>
				<c path="js.lib.Promise"><c path="js.lib.Promise.T"/></c>
			</f>
			<haxe_doc>Returns a Promise. When the promise is settled, i.e either fulfilled or rejected,
		the specified callback function is executed. This provides a way for code to be run
		whether the promise was fulfilled successfully or rejected once the Promise has been dealt with.</haxe_doc>
		</finally>
		<new public="1" set="method">
			<f a="init">
				<f a="resolve:reject">
					<f a="value">
						<c path="js.lib.Promise.T"/>
						<x path="Void"/>
					</f>
					<f a="reason">
						<d/>
						<x path="Void"/>
					</f>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</new>
		<haxe_doc>The Promise object represents the eventual completion (or failure) of an
	asynchronous operation and its resulting value.

	Documentation [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) by [Mozilla Contributors](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise$history), licensed under [CC-BY-SA 2.5](https://creativecommons.org/licenses/by-sa/2.5/).</haxe_doc>
		<meta><m n=":native"><e>"Promise"</e></m></meta>
	</class>
	<abstract path="js.lib.PromiseHandler" params="T:TOut" file="/opt/hostedtoolcache/haxe/4.3.2/x64/std/js/lib/Promise.hx" module="js.lib.Promise">
		<from>
			<icast><f a="">
	<c path="js.lib.PromiseHandler.T"/>
	<c path="js.lib.Promise"><c path="js.lib.PromiseHandler.TOut"/></c>
</f></icast>
			<icast><f a="">
	<c path="js.lib.PromiseHandler.T"/>
	<x path="js.lib.Thenable"><c path="js.lib.PromiseHandler.TOut"/></x>
</f></icast>
			<icast><f a="">
	<c path="js.lib.PromiseHandler.T"/>
	<c path="js.lib.PromiseHandler.TOut"/>
</f></icast>
		</from>
		<this><f a="">
	<c path="js.lib.PromiseHandler.T"/>
	<d/>
</f></this>
		<haxe_doc>Handler type for the Promise object.</haxe_doc>
		<impl><class path="js.lib._Promise.PromiseHandler_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.3.2/x64/std/js/lib/Promise.hx" private="1" module="js.lib.Promise" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<abstract path="js.lib.Thenable" params="T" file="/opt/hostedtoolcache/haxe/4.3.2/x64/std/js/lib/Promise.hx" module="js.lib.Promise">
		<from><icast><t path="js.lib.ThenableStruct"><c path="js.lib.Thenable.T"/></t></icast></from>
		<this><t path="js.lib.ThenableStruct"><c path="js.lib.Thenable.T"/></t></this>
		<haxe_doc>A value with a `then` method.</haxe_doc>
		<meta>
			<m n=":forward"/>
			<m n=":transitive"/>
		</meta>
		<impl><class path="js.lib._Promise.Thenable_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.3.2/x64/std/js/lib/Promise.hx" private="1" module="js.lib.Promise" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<typedef path="js.lib.ThenableStruct" params="T" file="/opt/hostedtoolcache/haxe/4.3.2/x64/std/js/lib/Promise.hx" module="js.lib.Promise"><a><then params="TOut" set="method"><f a="onFulfilled:?onRejected">
	<x path="Null"><x path="js.lib.PromiseHandler">
	<c path="js.lib.ThenableStruct.T"/>
	<c path="then.TOut"/>
</x></x>
	<x path="js.lib.PromiseHandler">
		<d/>
		<c path="then.TOut"/>
	</x>
	<x path="js.lib.Thenable"><c path="then.TOut"/></x>
</f></then></a></typedef>
	<typedef path="js.lib.PromiseSettleOutcome" params="T" file="/opt/hostedtoolcache/haxe/4.3.2/x64/std/js/lib/Promise.hx" module="js.lib.Promise"><a>
	<value>
		<x path="Null"><c path="js.lib.PromiseSettleOutcome.T"/></x>
		<meta><m n=":optional"/></meta>
	</value>
	<status><x path="js.lib.PromiseSettleStatus"/></status>
	<reason>
		<x path="Null"><d/></x>
		<meta><m n=":optional"/></meta>
	</reason>
</a></typedef>
	<abstract path="js.lib.PromiseSettleStatus" params="" file="/opt/hostedtoolcache/haxe/4.3.2/x64/std/js/lib/Promise.hx" module="js.lib.Promise">
		<this><c path="String"/></this>
		<to><icast><c path="String"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="js.lib._Promise.PromiseSettleStatus_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.3.2/x64/std/js/lib/Promise.hx" private="1" module="js.lib.Promise" final="1"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<class path="js.lib.RegExpMatch" params="" file="/opt/hostedtoolcache/haxe/4.3.2/x64/std/js/lib/RegExp.hx" module="js.lib.RegExp" extern="1">
		<extends path="Array"><c path="String"/></extends>
		<index public="1">
			<x path="Int"/>
			<haxe_doc>The index of the search at which the result was found.</haxe_doc>
		</index>
		<input public="1">
			<c path="String"/>
			<haxe_doc>A copy of the search string.</haxe_doc>
		</input>
		<groups public="1">
			<x path="Null"><x path="haxe.DynamicAccess"><c path="String"/></x></x>
			<haxe_doc>Named capturing groups or undefined if no named capturing groups were defined.
		See [Groups and Ranges](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Groups_and_Ranges) for more information.

		Note: Not all browsers support this feature; refer to the [compatibility table](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Browser_compatibility).</haxe_doc>
		</groups>
		<haxe_doc>A return value of the `RegExp.exec` method.</haxe_doc>
	</class>
	<class path="js.lib.Symbol" params="" file="/opt/hostedtoolcache/haxe/4.3.2/x64/std/js/lib/Symbol.hx" extern="1">
		<for_ public="1" set="method" static="1">
			<f a="key">
				<c path="String"/>
				<c path="js.lib.Symbol"/>
			</f>
			<meta><m n=":native"><e>"for"</e></m></meta>
			<haxe_doc>Searches for existing symbols with the given key and returns it if found.
		Otherwise a new symbol gets created in the global symbol registry with this key.</haxe_doc>
		</for_>
		<keyFor public="1" set="method" static="1">
			<f a="sym">
				<c path="js.lib.Symbol"/>
				<x path="Null"><c path="String"/></x>
			</f>
			<haxe_doc>Retrieves a shared symbol key from the global symbol registry for the given symbol.</haxe_doc>
		</keyFor>
		<iterator public="1" set="null" static="1">
			<c path="js.lib.Symbol"/>
			<haxe_doc>A method returning the default iterator for an object.</haxe_doc>
		</iterator>
		<asyncIterator public="1" set="null" static="1">
			<c path="js.lib.Symbol"/>
			<haxe_doc>A method that returns the default AsyncIterator for an object.</haxe_doc>
		</asyncIterator>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string containing the description of the Symbol.</haxe_doc>
		</toString>
		<ofObject public="1" params="T" get="inline" set="null" line="67">
			<f a="object">
				<a/>
				<x path="Null"><c path="ofObject.T"/></x>
			</f>
			<haxe_doc>Retrieve symbol from a given `object`.

		NOTE: This is a Haxe-specific method that generates an `object[symbol]` expression.</haxe_doc>
		</ofObject>
		<new public="1" set="method">
			<f a="?description">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":selfCall"/></meta>
			<haxe_doc>To create a new primitive symbol, use `new Symbol()` with an optional string as its `description`.

		NOTE: Unlike in plain JavaScript, `new Symbol()` syntax is used in Haxe. This generates a `Symbol(...)`
		expression as required by the JavaScript specification.</haxe_doc>
		</new>
		<meta><m n=":native"><e>"Symbol"</e></m></meta>
	</class>
</haxe>